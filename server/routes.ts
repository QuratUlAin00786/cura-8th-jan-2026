import express, { type Express } from "express";
import { createServer, type Server } from "http";
import { Server as SocketIOServer } from "socket.io";
import { WebSocketServer, WebSocket } from "ws";
import { z } from "zod";
import Stripe from "stripe";
import crypto from "crypto";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import OpenAI from "openai";
import { storage } from "./storage";
import { authService } from "./services/auth";
import { aiService } from "./services/ai";
import { registerSaaSRoutes } from "./saas-routes";
import { tenantMiddleware, authMiddleware, requireRole, requireNonPatientRole, gdprComplianceMiddleware, requireModulePermission, type TenantRequest } from "./middleware/tenant";
import { multiTenantEnforcer, validateOrganizationFilter, withTenantIsolation } from "./middleware/multi-tenant-enforcer";
import { initializeMultiTenantPackage, getMultiTenantPackage } from "./packages/multi-tenant-core";
import { messagingService } from "./messaging-service";
import { isDoctorLike } from './utils/role-utils.js';
// PayPal imports moved to dynamic imports to avoid initialization errors when credentials are missing
import { gdprComplianceService } from "./services/gdpr-compliance";
import { insertGdprConsentSchema, insertGdprDataRequestSchema, updateMedicalImageReportFieldSchema, medicationsDatabase, patientDrugInteractions, insuranceVerifications, type Appointment, organizations, subscriptions, users, patients, symptomChecks, quickbooksConnections, insertClinicHeaderSchema, insertClinicFooterSchema, doctorsFee, invoices, labResults, insertMessageTemplateSchema, passwordResetTokens, saasSubscriptions, organizationIntegrations, insertTreatmentSchema, insertTreatmentsInfoSchema } from "../shared/schema";
import * as schema from "../shared/schema";
import { db, pool } from "./db";
import { and, eq, sql, desc, isNull, isNotNull, or, gte, lte, ne } from "drizzle-orm";
import { processAppointmentBookingChat, generateAppointmentSummary } from "./anthropic";
import { inventoryService } from "./services/inventory";
import { pharmacyService } from "./services/pharmacy";
import { formService } from "./services/forms";
import { emailService } from "./services/email";
import { sendEmail, generatePrescriptionEmailHTML } from "./email";
import multer from "multer";
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { createNotification, createBulkNotifications } from "./notification-helper";
import { startAppointmentReminderScheduler } from "./appointment-reminders";
import * as fs from 'fs';
import * as fse from 'fs-extra';
import { readFile, access } from 'fs/promises';
import { createCanvas, loadImage } from 'canvas';
import sharp from 'sharp';

// Initialize Stripe with secret key only if provided (conditional to avoid crashes)
const stripe = process.env.STRIPE_SECRET_KEY 
  ? new Stripe(process.env.STRIPE_SECRET_KEY, {
      apiVersion: '2025-07-30.basil',
    })
  : null;

// Initialize OpenAI client (same configuration as aiService)
const openai = new OpenAI({ 
  apiKey: process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY_ENV_VAR || "default_key" 
});

/**
 * Helper to validate organizationId after multiTenantEnforcer middleware
 * Throws if organizationId is missing after tenant validation
 */
function requireOrgId(req: TenantRequest): number {
  if (!req.organizationId) {
    throw new Error('Organization ID is required but missing after tenant validation');
  }
  return req.organizationId;
}

/**
 * Security helper: Enforces created_by field with logged-in user ID
 * Prevents client from spoofing creator identity
 * @param req - Request with authenticated user
 * @param payload - Data object to modify
 * @param fieldName - Name of the created_by field (varies by module)
 * @returns Modified payload with enforced created_by field
 */
function enforceCreatedBy<T extends Record<string, any>>(
  req: TenantRequest,
  payload: T,
  fieldName: string = 'createdBy'
): T {
  if (!req.user?.id) {
    throw new Error('User authentication required to set creator');
  }
  // Always overwrite client-provided value with server-side user ID
  return {
    ...payload,
    [fieldName]: req.user.id
  };
}

/**
 * Helper function to convert unsupported image formats (WebP, GIF, BMP, TIFF, etc.) to JPEG
 * PDF libraries typically only support JPEG and PNG
 * @param imageBuffer - The original image buffer
 * @param fileExtension - The file extension (e.g., '.webp', '.gif')
 * @returns Object with converted buffer and MIME type
 */
async function convertImageToSupportedFormat(imageBuffer: Buffer, fileExtension: string): Promise<{ buffer: Buffer; mimeType: string }> {
  const unsupportedFormats = ['.webp', '.gif', '.bmp', '.tiff', '.tif', '.ico', '.jfif', '.pjpeg', '.pjp', '.svg'];
  
  if (!unsupportedFormats.includes(fileExtension.toLowerCase())) {
    // Already a supported format (JPEG or PNG)
    if (fileExtension === '.png') {
      return { buffer: imageBuffer, mimeType: 'image/png' };
    } else {
      return { buffer: imageBuffer, mimeType: 'image/jpeg' };
    }
  }
  
  try {
    console.log(`üîÑ Converting ${fileExtension} image to JPEG for PDF compatibility using sharp`);
    
    // Use sharp for robust image conversion (supports WebP, GIF, BMP, etc.)
    const convertedBuffer = await sharp(imageBuffer)
      .jpeg({ quality: 95 }) // Convert to JPEG with high quality
      .toBuffer();
    
    console.log(`‚úÖ Successfully converted ${fileExtension} to JPEG`);
    return { buffer: convertedBuffer, mimeType: 'image/jpeg' };
  } catch (error) {
    console.error(`‚ùå Failed to convert ${fileExtension} image using sharp:`, error);
    // Return original buffer as fallback (will likely fail PDF embedding)
    return { buffer: imageBuffer, mimeType: 'image/jpeg' };
  }
}

// In-memory storage for voice notes - persistent across server restarts
let voiceNotes: any[] = [];

// Global storage for appointment SSE connections
declare global {
  var appointmentClients: Map<string, { res: express.Response, organizationId: number, userId: number }> | undefined;
}

// Health Score calculation function
function calculateHealthScore(medicalRecords: any[], patientData: any) {
  // Default scores - starting point
  let totalWeightedScore = 0;
  let maxPossibleScore = 0;
  const weights = {
    spo2: 0.20,      // 20%
    bp: 0.20,        // 20%
    hr: 0.15,        // 15%
    labs: 0.20,      // 20%
    bmi: 0.10,       // 10%
    lifestyle: 0.15  // 15%
  };

  // Initialize scores for each category
  const scores = {
    spo2: { points: 10, maxPoints: 20 },      // Default moderate score
    bp: { points: 10, maxPoints: 20 },
    hr: { points: 10, maxPoints: 20 },
    labs: { points: 10, maxPoints: 20 },
    bmi: { points: 10, maxPoints: 20 },
    lifestyle: { points: 10, maxPoints: 20 }
  };

  // Extract health data from medical records notes
  medicalRecords.forEach(record => {
    if (record.notes) {
      const notes = record.notes.toLowerCase();
      
      // Parse Blood Pressure (BP)
      const bpMatch = notes.match(/bp[:\s]*(\d+)\/(\d+)|blood pressure[:\s]*(\d+)\/(\d+)|systolic[:\s]*(\d+)/);
      if (bpMatch) {
        const systolic = parseInt(bpMatch[1] || bpMatch[3] || bpMatch[5]);
        if (systolic >= 110 && systolic <= 130) {
          scores.bp.points = 20;
        } else if ((systolic >= 90 && systolic < 110) || (systolic > 130 && systolic <= 150)) {
          scores.bp.points = 15;
        } else if (systolic < 90 || systolic > 150) {
          scores.bp.points = 5;
        }
      }

      // Parse Heart Rate (HR)
      const hrMatch = notes.match(/hr[:\s]*(\d+)|heart rate[:\s]*(\d+)|pulse[:\s]*(\d+)/);
      if (hrMatch) {
        const heartRate = parseInt(hrMatch[1] || hrMatch[2] || hrMatch[3]);
        if (heartRate >= 60 && heartRate <= 100) {
          scores.hr.points = 20;
        } else if ((heartRate >= 50 && heartRate < 60) || (heartRate > 100 && heartRate <= 120)) {
          scores.hr.points = 15;
        } else if (heartRate < 50 || heartRate > 120) {
          scores.hr.points = 5;
        }
      }

      // Parse SpO2 (Oxygen Saturation)
      const spo2Match = notes.match(/spo2[:\s]*(\d+)|o2 sat[:\s]*(\d+)|oxygen[:\s]*(\d+)/);
      if (spo2Match) {
        const spo2 = parseInt(spo2Match[1] || spo2Match[2] || spo2Match[3]);
        if (spo2 >= 95) {
          scores.spo2.points = 20;
        } else if (spo2 >= 90 && spo2 < 95) {
          scores.spo2.points = 10;
        } else if (spo2 < 90) {
          scores.spo2.points = 0;
        }
      }

      // Parse Temperature
      const tempMatch = notes.match(/temp[:\s]*(\d+\.?\d*)|temperature[:\s]*(\d+\.?\d*)/);
      if (tempMatch) {
        const temp = parseFloat(tempMatch[1] || tempMatch[2]);
        // Assuming Celsius - normal range 36.1-37.2¬∞C
        if (temp >= 36.1 && temp <= 37.2) {
          scores.hr.points = Math.max(scores.hr.points, 20); // Use HR category for temp
        } else if ((temp >= 35.5 && temp < 36.1) || (temp > 37.2 && temp <= 38.0)) {
          scores.hr.points = Math.max(scores.hr.points, 15);
        }
      }

      // Parse BMI or Weight/Height
      const bmiMatch = notes.match(/bmi[:\s]*(\d+\.?\d*)/);
      const weightMatch = notes.match(/weight[:\s]*(\d+\.?\d*)/);
      const heightMatch = notes.match(/height[:\s]*(\d+\.?\d*)/);
      
      if (bmiMatch) {
        const bmi = parseFloat(bmiMatch[1]);
        if (bmi >= 18.5 && bmi <= 24.9) {
          scores.bmi.points = 20;
        } else if ((bmi >= 17 && bmi < 18.5) || (bmi >= 25 && bmi <= 29.9)) {
          scores.bmi.points = 10;
        } else if (bmi < 17 || bmi >= 30) {
          scores.bmi.points = 5;
        }
      } else if (weightMatch && heightMatch) {
        const weight = parseFloat(weightMatch[1]);
        const height = parseFloat(heightMatch[1]);
        const bmi = weight / (height * height); // Assuming height in meters
        if (bmi >= 18.5 && bmi <= 24.9) {
          scores.bmi.points = 20;
        } else if ((bmi >= 17 && bmi < 18.5) || (bmi >= 25 && bmi <= 29.9)) {
          scores.bmi.points = 10;
        } else if (bmi < 17 || bmi >= 30) {
          scores.bmi.points = 5;
        }
      }

      // Parse Labs (Glucose, Cholesterol, HbA1c, etc.)
      const glucoseMatch = notes.match(/glucose[:\s]*(\d+\.?\d*)|blood sugar[:\s]*(\d+\.?\d*)/);
      const cholesterolMatch = notes.match(/cholesterol[:\s]*(\d+\.?\d*)/);
      const hba1cMatch = notes.match(/hba1c[:\s]*(\d+\.?\d*)/);
      
      let labScore = 10; // Default
      let labCount = 0;
      
      if (glucoseMatch) {
        const glucose = parseFloat(glucoseMatch[1] || glucoseMatch[2]);
        if (glucose >= 70 && glucose <= 140) {
          labScore += 20;
        } else if ((glucose >= 60 && glucose < 70) || (glucose > 140 && glucose <= 180)) {
          labScore += 15;
        } else {
          labScore += 5;
        }
        labCount++;
      }
      
      if (cholesterolMatch) {
        const cholesterol = parseFloat(cholesterolMatch[1]);
        if (cholesterol < 200) {
          labScore += 20;
        } else if (cholesterol >= 200 && cholesterol <= 239) {
          labScore += 15;
        } else {
          labScore += 5;
        }
        labCount++;
      }
      
      if (hba1cMatch) {
        const hba1c = parseFloat(hba1cMatch[1]);
        if (hba1c < 5.7) {
          labScore += 20;
        } else if (hba1c >= 5.7 && hba1c <= 6.4) {
          labScore += 15;
        } else {
          labScore += 5;
        }
        labCount++;
      }
      
      if (labCount > 0) {
        scores.labs.points = Math.min(20, labScore / labCount);
      }
    }
  });

  // Parse lifestyle factors from patient data
  if (patientData.medicalHistory?.socialHistory) {
    const social = patientData.medicalHistory.socialHistory;
    let lifestyleScore = 0;
    let factorCount = 0;

    // Smoking
    if (social.smoking?.status) {
      if (social.smoking.status === 'never') {
        lifestyleScore += 20;
      } else if (social.smoking.status === 'former') {
        lifestyleScore += 15;
      } else {
        lifestyleScore += 5;
      }
      factorCount++;
    }

    // Alcohol
    if (social.alcohol?.status) {
      if (social.alcohol.status === 'never' || social.alcohol.status === 'social') {
        lifestyleScore += 20;
      } else if (social.alcohol.status === 'moderate') {
        lifestyleScore += 15;
      } else {
        lifestyleScore += 5;
      }
      factorCount++;
    }

    // Exercise
    if (social.exercise?.frequency) {
      if (social.exercise.frequency === 'daily' || social.exercise.frequency === 'weekly') {
        lifestyleScore += 20;
      } else if (social.exercise.frequency === 'monthly') {
        lifestyleScore += 15;
      } else {
        lifestyleScore += 5;
      }
      factorCount++;
    }

    if (factorCount > 0) {
      scores.lifestyle.points = lifestyleScore / factorCount;
    }
  }

  // Calculate weighted total
  Object.entries(scores).forEach(([category, score]) => {
    const weight = weights[category as keyof typeof weights];
    totalWeightedScore += score.points * weight;
    maxPossibleScore += score.maxPoints * weight;
  });

  // Calculate final percentage
  const healthScorePercentage = Math.round((totalWeightedScore / maxPossibleScore) * 100);

  // Categorize score
  let category = '';
  let color = '';
  if (healthScorePercentage >= 85) {
    category = 'Excellent';
    color = '#6CFFEB'; // Mint
  } else if (healthScorePercentage >= 70) {
    category = 'Good';
    color = '#4A7DFF'; // Blue
  } else if (healthScorePercentage >= 50) {
    category = 'Fair';
    color = '#FFA500'; // Orange
  } else {
    category = 'Poor';
    color = '#FF6B6B'; // Red
  }

  return {
    score: healthScorePercentage,
    category,
    color,
    breakdown: {
      spo2: { points: Math.round(scores.spo2.points), maxPoints: scores.spo2.maxPoints, weight: weights.spo2 },
      bp: { points: Math.round(scores.bp.points), maxPoints: scores.bp.maxPoints, weight: weights.bp },
      hr: { points: Math.round(scores.hr.points), maxPoints: scores.hr.maxPoints, weight: weights.hr },
      labs: { points: Math.round(scores.labs.points), maxPoints: scores.labs.maxPoints, weight: weights.labs },
      bmi: { points: Math.round(scores.bmi.points), maxPoints: scores.bmi.maxPoints, weight: weights.bmi },
      lifestyle: { points: Math.round(scores.lifestyle.points), maxPoints: scores.lifestyle.maxPoints, weight: weights.lifestyle }
    },
    totalRecords: medicalRecords.length,
    lastUpdated: new Date().toISOString()
  };
}

// Server-Sent Events broadcaster for real-time AI insight updates
interface AiInsightSSEEvent {
  type: 'ai_insight.status_updated';
  id: string;
  patientId: string;
  status: string;
  previousStatus?: string;
  updatedAt: string;
  organizationId: number;
}

class AiInsightSSEBroadcaster {
  private connections: Map<number, Set<express.Response>> = new Map();

  addConnection(organizationId: number, res: express.Response) {
    if (!this.connections.has(organizationId)) {
      this.connections.set(organizationId, new Set());
    }
    this.connections.get(organizationId)!.add(res);
    
    console.log(`[SSE] Added connection for organization ${organizationId}. Total connections: ${this.connections.get(organizationId)!.size}`);
    
    // Remove connection on close
    res.on('close', () => {
      this.removeConnection(organizationId, res);
    });
  }

  removeConnection(organizationId: number, res: express.Response) {
    const orgConnections = this.connections.get(organizationId);
    if (orgConnections) {
      orgConnections.delete(res);
      if (orgConnections.size === 0) {
        this.connections.delete(organizationId);
      }
      console.log(`[SSE] Removed connection for organization ${organizationId}. Remaining connections: ${orgConnections.size}`);
    }
  }

  broadcast(organizationId: number, event: AiInsightSSEEvent) {
    const orgConnections = this.connections.get(organizationId);
    if (!orgConnections || orgConnections.size === 0) {
      console.log(`[SSE] No connections for organization ${organizationId}, skipping broadcast`);
      return;
    }

    const eventId = uuidv4();
    const eventData = JSON.stringify(event);
    const sseData = `id: ${eventId}\nevent: ai_insight.status_updated\ndata: ${eventData}\n\n`;

    const deadConnections: express.Response[] = [];
    
    orgConnections.forEach((res) => {
      try {
        if (!res.headersSent && !res.destroyed) {
          res.write(sseData);
          console.log(`[SSE] Broadcasted event to organization ${organizationId}:`, event.type);
        } else {
          deadConnections.push(res);
        }
      } catch (error) {
        console.error(`[SSE] Error broadcasting to connection:`, error);
        deadConnections.push(res);
      }
    });

    // Clean up dead connections
    deadConnections.forEach(res => this.removeConnection(organizationId, res));
  }

  getConnectionCount(organizationId: number): number {
    return this.connections.get(organizationId)?.size || 0;
  }
}

// Global SSE broadcaster instance
const aiInsightBroadcaster = new AiInsightSSEBroadcaster();

// Enhanced error handling helper to distinguish different error types
function handleRouteError(error: any, operation: string, res: express.Response) {
  // Handle Zod validation errors (return 400)
  if (error?.name === 'ZodError') {
    console.error(`[VALIDATION_ERROR] ${operation}:`, error.errors);
    return res.status(400).json({ 
      error: "Validation failed", 
      details: error.errors 
    });
  }
  
  // Handle database transient errors (return 503)
  if (error?.code === 'SERVICE_UNAVAILABLE' && error?.statusCode === 503) {
    console.error(`[DB_TRANSIENT_ERROR] ${operation}:`, error.message);
    return res.status(503).json({ 
      error: error.message || "Service temporarily unavailable. Please try again in a moment.",
      retryAfter: 5 // Suggest retry after 5 seconds
    });
  }
  
  // Handle other database connection errors that might not be caught by retry logic
  if (error?.code === '57P01' || error?.code === 'ECONNRESET' || error?.code === 'ETIMEDOUT' || 
      error?.message?.includes('terminating connection')) {
    console.error(`[DB_CONNECTION_ERROR] ${operation}:`, error.message);
    return res.status(503).json({ 
      error: "Database connection issue. Please try again in a moment.",
      retryAfter: 3
    });
  }
  
  // Handle generic errors (return 500)
  console.error(`[ERROR] ${operation}:`, error);
  return res.status(500).json({ 
    error: `Failed to ${operation.toLowerCase()}` 
  });
}

// Configure multer for file uploads
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
    files: 5 // Maximum 5 files
  },
  fileFilter: (req, file, cb) => {
    // Accept PDF, DOC, DOCX, JPG, PNG files
    const allowedTypes = [
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'image/jpeg',
      'image/jpg',
      'image/png'
    ];
    
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(null, false);
    }
  }
});

// Configure disk storage specifically for photos
const uploadPhoto = multer({
  dest: 'uploads/temp/',
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    // Accept only image files for photos
    const allowedTypes = [
      'image/jpeg',
      'image/jpg',
      'image/png'
    ];
    
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(null, false);
    }
  }
});

// Configure disk storage specifically for voice notes
const uploadVoiceNote = multer({
  dest: 'uploads/temp/',
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB limit for audio files
  },
  fileFilter: (req, file, cb) => {
    // Accept audio files
    const allowedTypes = [
      'audio/mpeg',
      'audio/mp3',
      'audio/wav',
      'audio/webm',
      'audio/ogg',
      'application/octet-stream' // For blob uploads
    ];
    
    if (allowedTypes.includes(file.mimetype) || file.originalname.endsWith('.webm') || file.originalname.endsWith('.wav') || file.originalname.endsWith('.mp3')) {
      cb(null, true);
    } else {
      cb(null, false);
    }
  }
});

// Configure disk storage specifically for medical images  
const uploadMedicalImages = multer({
  storage: multer.diskStorage({
    destination: (req, file, cb) => {
      const uploadDir = path.join(process.cwd(), 'uploads', 'Imaging_Images');
      
      // Create directory if it doesn't exist
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
        console.log('üìÅ Created directory:', uploadDir);
      }
      
      cb(null, uploadDir);
    },
    filename: async (req, file, cb) => {
      try {
        // Get numeric patient ID from request body
        const numericPatientId = req.body.patientId;
        if (!numericPatientId) {
          return cb(new Error('Patient ID is required for file naming'), '');
        }
        
        // Get the tenant from middleware
        const tenantReq = req as any; // TenantRequest
        if (!tenantReq.tenant) {
          return cb(new Error('Tenant information required for patient lookup'), '');
        }
        
        // Get patient to find their string patientId (like "P001")
        const patient = await storage.getPatient(parseInt(numericPatientId), tenantReq.tenant.id);
        if (!patient) {
          return cb(new Error('Patient not found for unique filename generation'), '');
        }
        
        // Extract file extension
        const ext = file.originalname.split('.').pop();
        
        // Create unique filename: patientId_Images.extension (using string patientId like "P001")
        const uniqueFilename = `${patient.patientId}_Images.${ext}`;
        
        console.log('üì∑ SERVER: Creating unique filename for patient:', {
          numericId: numericPatientId,
          stringPatientId: patient.patientId,
          originalName: file.originalname,
          uniqueFilename: uniqueFilename
        });
        
        cb(null, uniqueFilename);
      } catch (error) {
        console.error('üì∑ SERVER: Error generating unique filename:', error);
        cb(new Error('Failed to generate unique filename'), '');
      }
    }
  }),
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB limit for medical images
  },
  fileFilter: (req, file, cb) => {
    // Accept medical image files
    const allowedTypes = [
      'image/jpeg',
      'image/jpg', 
      'image/png',
      'image/gif',
      'image/bmp',
      'image/tiff',
      'image/tif',
      'image/webp',
      'image/svg+xml',
      'image/x-icon',
      'application/dicom', // DICOM files
      'application/octet-stream' // For .dcm files
    ];
    
    if (allowedTypes.includes(file.mimetype) || 
        file.originalname.toLowerCase().endsWith('.dcm') ||
        file.originalname.toLowerCase().endsWith('.dicom')) {
      cb(null, true);
    } else {
      cb(null, false);
    }
  }
});

// Configure disk storage for replace operations - uses temp filename initially
const uploadReplaceImages = multer({
  storage: multer.diskStorage({
    destination: (req, file, cb) => {
      const uploadDir = path.join(process.cwd(), 'uploads', 'Imaging_Images');
      
      // Create directory if it doesn't exist
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
        console.log('üìÅ Created directory:', uploadDir);
      }
      
      cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
      // Use temporary filename for replace operations
      // We'll rename it to the correct filename after upload
      const ext = file.originalname.split('.').pop();
      const tempFilename = `temp_replace_${Date.now()}.${ext}`;
      
      console.log('üîÑ SERVER: Creating temporary filename for replace:', {
        originalName: file.originalname,
        tempFilename: tempFilename
      });
      
      cb(null, tempFilename);
    }
  }),
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB limit for medical images
  },
  fileFilter: (req, file, cb) => {
    // Accept medical image files
    const allowedTypes = [
      'image/jpeg',
      'image/jpg', 
      'image/png',
      'image/gif',
      'image/bmp',
      'image/tiff',
      'image/tif',
      'image/webp',
      'image/svg+xml',
      'image/x-icon',
      'application/dicom', // DICOM files
      'application/octet-stream' // For .dcm files
    ];
    
    if (allowedTypes.includes(file.mimetype) || 
        file.originalname.toLowerCase().endsWith('.dcm') ||
        file.originalname.toLowerCase().endsWith('.dicom')) {
      cb(null, true);
    } else {
      cb(null, false);
    }
  }
});

export async function registerRoutes(app: Express): Promise<Server> {
  
  // DEPLOYMENT HEALTH CHECK - Absolute priority for deployment success
  app.get('/api/health', (req, res) => {
    res.status(200).json({ 
      status: 'ok', 
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      service: 'cura-emr',
      environment: process.env.NODE_ENV || 'development'
    });
  });

  // Stripe payment route for imaging invoices
  app.post("/api/create-payment-intent", async (req, res) => {
    try {
      if (!stripe) {
        return res.status(500).json({ message: "Stripe is not configured" });
      }

      const { amount } = req.body;
      
      if (!amount || amount <= 0) {
        return res.status(400).json({ message: "Invalid amount" });
      }

      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amount * 100), // Convert to pence
        currency: "gbp",
        automatic_payment_methods: {
          enabled: true,
        },
      });

      res.json({ clientSecret: paymentIntent.client_secret });
    } catch (error: any) {
      console.error("Stripe payment intent error:", error);
      res.status(500).json({ 
        message: "Error creating payment intent: " + error.message 
      });
    }
  });

  // Alternative health endpoints for different deployment systems
  app.get('/health', (req, res) => {
    res.status(200).json({ 
      status: 'healthy', 
      timestamp: new Date().toISOString(),
      service: 'cura-emr'
    });
  });

  app.get('/healthz', (req, res) => {
    res.status(200).json({ 
      status: 'healthy', 
      timestamp: new Date().toISOString()
    });
  });

  // Serve uploaded files (clinical photos, imaging reports, etc.)
  // Configure headers to allow PDF viewing in iframes with no restrictions
  app.use('/uploads', (req, res, next) => {
    // Remove all frame restrictions to allow PDF viewing
    res.removeHeader('X-Frame-Options');
    // Set proper MIME type for PDFs
    if (req.path.endsWith('.pdf')) {
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', 'inline'); // Force inline viewing, not download
    }
    next();
  });
  app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));
  
  // EMERGENCY PRODUCTION FIX - Absolute priority route BEFORE everything else
  // SECURITY: Only available in development environment
  app.post('/api/emergency-saas-setup', async (req, res) => {
    // CRITICAL SECURITY CHECK: Block in production
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'Emergency setup not available in production' });
    }
    try {
      console.log('[EMERGENCY] Emergency SaaS setup triggered');
      const bcrypt = await import('bcrypt');
      const hashedPassword = await bcrypt.default.hash('admin123', 10);
      
      // Use existing storage to create SaaS admin - more reliable than direct DB access
      const existingUser = await storage.getUserByUsername('saas_admin', 0);
      
      if (!existingUser) {
        const saasUser = await storage.createUser({
          username: 'saas_admin',
          email: 'saas_admin@curaemr.ai',
          passwordHash: hashedPassword,
          firstName: 'SaaS',
          lastName: 'Administrator',
          organizationId: 0,
          role: 'admin',
          isActive: true,
          isSaaSOwner: true
        });
        
        console.log(`[EMERGENCY] Created SaaS admin user with ID: ${saasUser.id}`);
        res.json({ 
          success: true, 
          message: 'Emergency SaaS setup complete - user created',
          userId: saasUser.id,
          timestamp: new Date().toISOString()
        });
      } else {
        // Update existing user to ensure proper flags
        await storage.updateUser(existingUser.id, 0, {
          passwordHash: hashedPassword,
          isActive: true,
          isSaaSOwner: true
        });
        
        console.log(`[EMERGENCY] Updated existing SaaS admin user with ID: ${existingUser.id}`);
        res.json({ 
          success: true, 
          message: 'Emergency SaaS setup complete - user updated',
          userId: existingUser.id,
          timestamp: new Date().toISOString()
        });
      }
    } catch (error) {
      console.error('[EMERGENCY] Setup error:', error);
      res.status(500).json({ error: 'Emergency setup failed', details: (error as Error).message });
    }
  });

  // PRODUCTION DEMO USERS SETUP - Creates demo users for production login screen
  // SECURITY: Only available in development environment
  app.post('/api/production-demo-setup', async (req, res) => {
    // CRITICAL SECURITY CHECK: Block in production
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'Demo setup not available in production' });
    }
    try {
      console.log('[PRODUCTION DEMO] Creating production demo users...');
      
      // Production-ready password hashes for demo credentials
      const productionHashes = {
        admin123: '$2b$12$wBdwP8DhNP3XuviUaPHgB.y.G/Px2AAOYi7w.W8vJaiywet.cJ7Ae',
        doctor123: '$2b$12$jY/ugs1.lFZPYN./Yhjxue7inIwU7JtFiHyPN.wLvSC5Ep43XvFOi',
        patient123: '$2b$12$aDR..3VlJ9/ON8RHbLY3kuYTBrjxv26qVwQuh4nWn/tRbQH.X3Aje',
        nurse123: '$2b$12$VANG.x51jkairEWTXbY9xOzyUpbb3vNSdylcqZxa4/TOyvO2rOgoG'
      };

      // Ensure Demo Healthcare Clinic organization exists (organization ID: 2)
      let demoOrg;
      try {
        demoOrg = await storage.getOrganization(2);
        if (!demoOrg) {
          demoOrg = await storage.createOrganization({
            name: 'Demo Healthcare Clinic',
            subdomain: 'demo',
            brandName: 'Demo Healthcare Clinic',
            contactEmail: 'admin@demo.com',
            contactPhone: '+44 123 456 7890',
            address: '123 Demo Street',
            city: 'London',
            country: 'UK',
            settings: {
              theme: { primaryColor: '#4A7DFF' },
              compliance: { gdprEnabled: true, dataResidency: 'UK' },
              features: { aiEnabled: true, billingEnabled: true }
            }
          });
          console.log(`[PRODUCTION DEMO] Created demo organization with ID: ${demoOrg.id}`);
        }
      } catch (error) {
        console.log('[PRODUCTION DEMO] Using existing organization ID 2');
        demoOrg = { id: 2, name: 'Demo Healthcare Clinic' };
      }

      const organizationId = 2; // Fixed organization ID for demo
      const createdUsers = [];
      const updatedUsers = [];

      // Demo users configuration
      const demoUsers = [
        {
          email: 'admin@cura.com',
          username: 'admin',
          password: 'admin123',
          firstName: 'Admin',
          lastName: 'User',
          role: 'admin' as const
        },
        {
          email: 'doctor@cura.com',
          username: 'doctor',
          password: 'doctor123',
          firstName: 'Dr. John',
          lastName: 'Smith',
          role: 'doctor' as const
        },
        {
          email: 'patient@cura.com',
          username: 'patient',
          password: 'patient123',
          firstName: 'Mary',
          lastName: 'Johnson',
          role: 'patient' as const
        },
        {
          email: 'nurse@cura.com',
          username: 'nurse',
          password: 'nurse123',
          firstName: 'Sarah',
          lastName: 'Williams',
          role: 'nurse' as const
        }
      ];

      // Create or update each demo user
      for (const userData of demoUsers) {
        try {
          // Check if user already exists
          let existingUser = await storage.getUserByEmail(userData.email, organizationId);
          
          if (!existingUser) {
            // User doesn't exist, create new
            const newUser = await storage.createUser({
              email: userData.email,
              username: userData.username,
              passwordHash: productionHashes[userData.password as keyof typeof productionHashes],
              firstName: userData.firstName,
              lastName: userData.lastName,
              role: userData.role,
              organizationId: organizationId,
              isActive: true,
              isSaaSOwner: false
            });
            
            createdUsers.push(`${userData.role}: ${userData.email}`);
            console.log(`[PRODUCTION DEMO] Created user: ${userData.email} (${userData.role})`);
          } else {
            // User exists, update password hash to ensure consistency
            await storage.updateUser(existingUser.id, organizationId, {
              passwordHash: productionHashes[userData.password as keyof typeof productionHashes],
              isActive: true
            });
            
            updatedUsers.push(`${userData.role}: ${userData.email}`);
            console.log(`[PRODUCTION DEMO] Updated user: ${userData.email} (${userData.role})`);
          }
        } catch (userError) {
          console.error(`[PRODUCTION DEMO] Error processing user ${userData.email}:`, userError);
          throw new Error(`Failed to create/update user ${userData.email}: ${userError instanceof Error ? userError.message : 'Unknown error'}`);
        }
      }

      const response = {
        success: true,
        message: 'Production demo users setup completed successfully',
        organization: {
          id: organizationId,
          name: demoOrg.name
        },
        users: {
          created: createdUsers,
          updated: updatedUsers,
          total: createdUsers.length + updatedUsers.length
        },
        credentials: {
          admin: 'admin@cura.com / admin123',
          doctor: 'doctor@cura.com / doctor123', 
          patient: 'patient@cura.com / patient123',
          nurse: 'nurse@cura.com / nurse123'
        },
        timestamp: new Date().toISOString()
      };

      console.log('[PRODUCTION DEMO] ‚úÖ Demo users setup completed successfully');
      res.json(response);
      
    } catch (error) {
      console.error('[PRODUCTION DEMO] ‚ùå Setup failed:', error);
      res.status(500).json({ 
        success: false,
        error: 'Production demo setup failed',
        message: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      });
    }
  });

  const formShareRouter = express.Router();

  formShareRouter.get("/forms/share/:token/meta", async (req: TenantRequest, res) => {
    try {
      const meta = await formService.getShareMetadata(req.params.token);
      res.json(meta);
    } catch (error) {
      console.error("Error fetching share metadata:", error);
      res.status(400).json({ error: (error as Error).message || "Invalid or expired link" });
    }
  });

  formShareRouter.get("/forms/share/:token", async (req: TenantRequest, res) => {
    try {
      const payload = await formService.getShareByToken(req.params.token);
      res.json({
        share: {
          id: payload.share.id,
          formId: payload.share.formId,
          status: payload.share.status,
          expiresAt: payload.share.expiresAt,
        },
        form: payload.form,
      });
    } catch (error) {
      console.error("Invalid form share link:", error);
      res.status(400).json({ error: (error as Error).message || "Invalid or expired link" });
    }
  });

  formShareRouter.post("/forms/share/:token/responses", async (req: TenantRequest, res) => {
    try {
      const answers = Array.isArray(req.body.answers) ? req.body.answers : [];
      if (!answers.length) {
        return res.status(400).json({ error: "answers array is required" });
      }

      const response = await formService.submitResponse(req.params.token, answers);
      res.status(201).json(response);
    } catch (error) {
      console.error("Error saving form response:", error);
      res.status(400).json({ error: (error as Error).message || "Failed to submit form" });
    }
  });

  app.use("/api", formShareRouter);

  // Initialize Multi-Tenant Core Package
  const multiTenantPackage = initializeMultiTenantPackage(storage as any, {
    enforceStrictTenantIsolation: true,
    auditAllDataAccess: true,
    validateCrossTenantOperations: true,
    logUnauthorizedAccess: true,
    enablePerformanceMonitoring: true
  });

  // Debug endpoint BEFORE middleware - to diagnose tenant issues v6 FORCE CACHE CLEAR
  app.get("/api/status", async (req, res) => {
    const host = req.get("host");
    const extractedSubdomain = host ? host.split('.')[0] : "none";
    
    // SECURITY: Block emergency SaaS setup in production
    if (req.query.setup === 'saas' && req.query.emergency === 'true') {
      // CRITICAL SECURITY CHECK: Block in production
      if (process.env.NODE_ENV === 'production') {
        return res.status(403).json({ error: 'Emergency setup not available in production' });
      }
      try {
        const bcrypt = require('bcrypt');
        const hashedPassword = await bcrypt.hash('admin123', 10);
        
        // Create SaaS admin using existing storage that works
        const existingUser = await storage.getUserByUsername('saas_admin', 0);
        if (!existingUser) {
          await storage.createUser({
            username: 'saas_admin',
            email: 'saas_admin@curaemr.ai',
            passwordHash: hashedPassword,
            firstName: 'SaaS',
            lastName: 'Administrator',
            organizationId: 0,
            role: 'admin' as const,
            isActive: true,
            isSaaSOwner: true
          });
        }
        
        return res.json({
          status: "SAAS_SETUP_COMPLETE",
          message: "SaaS admin user ready",
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        return res.json({
          status: "SAAS_SETUP_FAILED", 
          error: (error as Error).message,
          timestamp: new Date().toISOString()
        });
      }
    }
    
    res.json({ 
      status: "MULTI-TENANT-ENFORCED", 
      host, 
      extractedSubdomain,
      env: process.env.NODE_ENV,
      timestamp: new Date().toISOString(),
      version: "v8-with-saas-emergency-fix",
      multiTenantConfig: {
        strictIsolation: true,
        auditEnabled: true,
        validationEnabled: true
      }
    });
  });

  // Production Data Sync endpoint - triggers database seeding for production
  // SECURITY: Only available in development environment
  app.post('/api/production-sync', async (req, res) => {
    // CRITICAL SECURITY CHECK: Block in production
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'Production sync not available in production' });
    }
    try {
      console.log('[PRODUCTION SYNC] Starting database seeding...');
      
      // Import and run the seeding function
      const { seedDatabase } = await import('./seed-data');
      await seedDatabase();
      
      res.json({
        success: true,
        message: 'Production database seeded successfully',
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('[PRODUCTION SYNC] Seeding failed:', error);
      res.status(500).json({ 
        error: 'Production sync failed', 
        message: (error as Error).message 
      });
    }
  });

  // Register critical SaaS routes DIRECTLY before ANY middleware
  // These MUST work in production - direct implementation without external dependencies
  
  // SaaS Debug endpoint - direct implementation
  app.get('/api/saas/debug', async (req, res) => {
    try {
      const hasSaaSUser = await storage.getUserByUsername('saas_admin', 0);
      res.json({
        debug: true,
        environment: process.env.NODE_ENV || 'unknown',
        hostname: req.hostname,
        hasSaaSAdmin: !!hasSaaSUser,
        saasAdminActive: hasSaaSUser?.isActive || false,
        timestamp: new Date().toISOString(),
        status: 'DIRECT_ROUTE_BYPASSING_MIDDLEWARE'
      });
    } catch (error) {
      res.status(500).json({ error: 'Debug failed', message: (error as Error).message });
    }
  });

  // SaaS Login endpoint - direct implementation
  app.post('/api/saas/login', async (req, res) => {
    try {
      const { username, password } = req.body;
      console.log(`[DIRECT SAAS] Login attempt: ${username}`);
      
      const user = await storage.getUserByUsername(username, 0);
      if (!user || !user.isSaaSOwner) {
        return res.status(401).json({ error: "Authentication failed. Please check your credentials." });
      }

      const isValidPassword = await bcrypt.compare(password, user.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ error: "Authentication failed. Please check your credentials." });
      }
      // SECURITY: Require SAAS_JWT_SECRET in production
      const SAAS_JWT_SECRET = process.env.SAAS_JWT_SECRET;
      if (!SAAS_JWT_SECRET) {
        if (process.env.NODE_ENV === 'production') {
          throw new Error('SAAS_JWT_SECRET environment variable is required in production');
        }
        // Only allow default in development
        return res.status(500).json({ error: 'JWT secret configuration required' });
      }
      const token = jwt.sign(
        { id: user.id, username: user.username, isSaaSOwner: true },
        SAAS_JWT_SECRET,
        { expiresIn: '24h' }
      );

      res.json({
        success: true,
        token,
        owner: {
          id: user.id,
          username: user.username,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName
        }
      });
    } catch (error) {
      console.error('[DIRECT SAAS] Login error:', error);
      res.status(500).json({ error: "Login failed" });
    }
  });

  // Initialize multi-tenant middleware stack BEFORE any routes
  multiTenantPackage.initializeMiddleware(app);
  
  // Get tenant-aware storage
  const tenantStorage = multiTenantPackage.getTenantStorage();

  // Secure admin endpoint for demo medical records bootstrapping  
  app.post('/api/admin/demo-medical-records-bootstrap', authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      // SECURITY: Strict production requirements
      if (process.env.NODE_ENV === 'production') {
        if (!process.env.SETUP_TOKEN) {
          return res.status(403).json({ error: 'Setup token required in production' });
        }
        if (process.env.ALLOW_DEMO_BOOTSTRAP !== 'true') {
          return res.status(403).json({ error: 'Demo bootstrap not enabled in production' });
        }
      }
      
      const { seedProductionMedicalRecords } = await import("./production-medical-records");
      
      // SECURITY: Strict setup token verification  
      const setupToken = req.headers['x-setup-token'] as string;
      if (process.env.SETUP_TOKEN) {
        if (!setupToken || setupToken !== process.env.SETUP_TOKEN) {
          console.log(`[BOOTSTRAP] Invalid or missing setup token`);
          return res.status(403).json({ error: 'Invalid setup token' });
        }
      }
      
      // SECURITY: Strict demo-only enforcement
      const orgSubdomain = req.tenant?.subdomain;
      if (!orgSubdomain) {
        return res.status(400).json({ error: 'Organization context required' });
      }
      
      // In production, ONLY allow demo organization (no exceptions)
      if (process.env.NODE_ENV === 'production' && orgSubdomain !== 'demo') {
        console.log(`[BOOTSTRAP] Production bootstrap denied for organization: ${orgSubdomain} (only demo allowed in production)`);
        return res.status(403).json({ error: 'Production bootstrap only allowed for demo organization' });
      }
      
      // In development, allow demo or if explicitly enabled
      if (process.env.NODE_ENV !== 'production' && orgSubdomain !== 'demo' && process.env.ALLOW_DEMO_BOOTSTRAP !== 'true') {
        console.log(`[BOOTSTRAP] Bootstrap denied for organization: ${orgSubdomain} (not demo and ALLOW_DEMO_BOOTSTRAP not set)`);
        return res.status(403).json({ error: 'Bootstrap only allowed for demo organization or if explicitly enabled' });
      }
      
      console.log(`[BOOTSTRAP] Starting medical records bootstrap for organization: ${orgSubdomain}`);
      console.log(`[BOOTSTRAP] Initiated by admin user: ${req.user?.email} (ID: ${req.user?.id})`);
      
      // Call the refactored function with proper scoping
      const result = await seedProductionMedicalRecords({
        orgSubdomain: orgSubdomain,
        maxPatients: 1,
        minRecordsPerPatient: 2
      });
      
      if (!result.success) {
        console.log(`[BOOTSTRAP] Failed: ${result.error}`);
        return res.status(400).json({ 
          error: result.error,
          createdCount: result.createdCount
        });
      }
      
      // SECURITY: PHI-safe audit logging (no medical content)
      console.log(`[BOOTSTRAP] ‚úÖ Successfully bootstrapped ${result.createdCount} medical records`);
      console.log(`[BOOTSTRAP] Organization: ${orgSubdomain} (ID: ${result.organizationId})`);
      console.log(`[BOOTSTRAP] Processed ${result.results?.length || 0} patients`);
      
      // SECURITY: PHI-safe response (no medical record content)
      const patientsProcessed = result.results?.map(r => ({
        patientId: r.patientId,
        createdCount: r.createdCount,
        skipped: r.skipped
      })) || [];
      
      res.json({
        success: true,
        message: 'Demo medical records bootstrap completed successfully',
        createdCount: result.createdCount,
        organizationId: result.organizationId,
        orgSubdomain: result.orgSubdomain,
        patientsProcessed: patientsProcessed,
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('[BOOTSTRAP] Medical records bootstrap error:', error);
      res.status(500).json({ 
        error: 'Medical records bootstrap failed',
        details: process.env.NODE_ENV === 'development' ? (error as Error).message : undefined
      });
    }
  });

  // Register remaining SaaS administration routes
  registerSaaSRoutes(app);

  // Universal login endpoint (no tenant required - determines subdomain from user's organization)
  app.post("/api/auth/universal-login", async (req: express.Request, res: express.Response) => {
    try {
      const { email, password } = z.object({
        email: z.string(),
        password: z.string().min(3)
      }).parse(req.body);

      console.log(`[UNIVERSAL LOGIN] Attempt for: ${email}`);

      // Lookup user globally (no organization filter)
      let user = await storage.getUserByEmailGlobal(email);
      
      if (!user || !user.isActive) {
        console.log(`[UNIVERSAL LOGIN] User not found or inactive: ${email}`);
        return res.status(401).json({ error: "Invalid credentials" });
      }

      console.log(`[UNIVERSAL LOGIN] Found user: ${user.email} - Org ID: ${user.organizationId}`);

      const isValidPassword = await authService.comparePassword(password, user.passwordHash);
      if (!isValidPassword) {
        console.log(`[UNIVERSAL LOGIN] Invalid password for user: ${email}`);
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const token = authService.generateToken(user);
      
      // Get organization subdomain to include in response
      const organization = await storage.getOrganization(user.organizationId);

      if (!organization) {
        console.error(`[UNIVERSAL LOGIN] Organization not found for user ${email}, org ID: ${user.organizationId}`);
        return res.status(500).json({ error: "Organization not found" });
      }

      console.log(`[UNIVERSAL LOGIN] Success! User: ${user.email}, Subdomain: ${organization.subdomain}`);

      res.json({
        token,
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          department: user.department,
          organizationId: user.organizationId
        },
        organization: {
          id: organization.id,
          name: organization.name,
          subdomain: organization.subdomain
        }
      });
    } catch (error) {
      console.error("[UNIVERSAL LOGIN] Error:", error);
      res.status(500).json({ error: "Login failed" });
    }
  });

  // Password change endpoint (requires authentication)
  app.patch("/api/user/change-password", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { currentPassword, newPassword } = z.object({
        currentPassword: z.string().min(1, "Current password is required"),
        newPassword: z.string().min(8, "New password must be at least 8 characters long")
      }).parse(req.body);

      // Get current user
      const userId = req.user!.id;
      const organizationId = requireOrgId(req);
      const user = await storage.getUser(userId, organizationId);
      
      if (!user || !user.isActive) {
        return res.status(404).json({ error: "User not found or inactive" });
      }

      // Verify current password
      const isValidPassword = await bcrypt.compare(currentPassword, user.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ error: "Current password is incorrect" });
      }

      // Hash new password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);

      // Update password in database via storage layer
      await storage.updateUser(userId, organizationId, { passwordHash: newPasswordHash });

      // Send email notification
      const userName = `${user.firstName} ${user.lastName}`;
      let emailSent = false;
      try {
        emailSent = await emailService.sendPasswordChangeNotification(user.email, userName);
        if (emailSent) {
          console.log(`[PASSWORD CHANGE] Email notification sent to ${user.email}`);
        } else {
          console.log(`[PASSWORD CHANGE] Email notification failed for ${user.email}`);
        }
      } catch (emailError) {
        console.error('[PASSWORD CHANGE] Email notification failed:', emailError);
        // Don't fail the password change if email fails
      }

      res.json({ 
        success: true, 
        message: emailSent 
          ? "Password changed successfully. A confirmation email has been sent to your registered email address." 
          : "Password changed successfully."
      });
    } catch (error) {
      console.error("[PASSWORD CHANGE] Error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors[0].message });
      }
      res.status(500).json({ error: "Failed to change password" });
    }
  });

  // Authentication routes (no auth required)
  app.post("/api/auth/login", async (req: TenantRequest, res) => {
    try {
      const { email, password } = z.object({
        email: z.string(),
        password: z.string().min(3) // Allow shorter passwords for demo
      }).parse(req.body);

      console.log(`Login attempt for: ${email} with organization: ${req.tenant!.id}`);

      // Try to find user by email first, then by username
      let user = await storage.getUserByEmail(email, req.tenant!.id);
      if (!user) {
        user = await storage.getUserByUsername(email, req.tenant!.id);
      }
      
      if (!user || !user.isActive) {
        console.log(`User not found or inactive: ${email}`);
        return res.status(401).json({ error: "Invalid credentials" });
      }

      console.log(`Found user: ${user.email} (${user.username}) - Role: ${user.role}`);

      const isValidPassword = await authService.comparePassword(password, user.passwordHash);
      if (!isValidPassword) {
        console.log(`Invalid password for user: ${email}`);
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const token = authService.generateToken(user);
      
      // Update last login - remove this for now due to schema issues
      // await storage.updateUser(user.id, user.organizationId, { lastLoginAt: new Date() });

      // Get organization subdomain to include in response
      const organization = await storage.getOrganization(user.organizationId);

      res.json({
        token,
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          department: user.department,
          organizationId: user.organizationId
        },
        organization: organization ? {
          id: organization.id,
          name: organization.name,
          subdomain: organization.subdomain
        } : null
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ error: "Login failed" });
    }
  });

  // Password Reset Request endpoint (no auth required)
  app.post("/api/auth/forgot-password", async (req: express.Request, res: express.Response) => {
    try {
      const { email } = z.object({
        email: z.string().email()
      }).parse(req.body);

      console.log(`[PASSWORD RESET] Request for email: ${email}`);

      // Find user by email across all organizations
      const user = await db.select().from(users).where(eq(users.email, email)).limit(1);
      
      if (!user || user.length === 0 || !user[0].isActive) {
        // For security, return success even if user not found
        console.log(`[PASSWORD RESET] User not found or inactive: ${email}`);
        return res.json({ message: "If the email exists, a password reset link has been sent." });
      }

      const foundUser = user[0];

      // Generate secure reset token (this will be sent in email)
      const resetToken = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour from now

      // Hash the token before storing in database for security
      const hashedToken = await authService.hashPassword(resetToken);

      // Store hashed token in database
      await db.insert(passwordResetTokens).values({
        userId: foundUser.id,
        token: hashedToken,
        expiresAt,
        isUsed: false
      });

      // Send password reset email with unhashed token
      await emailService.sendPasswordResetEmail(
        foundUser.email,
        resetToken,
        foundUser.firstName
      );

      console.log(`[PASSWORD RESET] Email sent to: ${email}`);

      res.json({ message: "If the email exists, a password reset link has been sent." });
    } catch (error) {
      console.error("[PASSWORD RESET] Error:", error);
      res.status(500).json({ error: "Failed to process password reset request" });
    }
  });

  // Password Reset Confirmation endpoint (no auth required)
  app.post("/api/auth/reset-password", async (req: express.Request, res: express.Response) => {
    try {
      const { token, newPassword } = z.object({
        token: z.string(),
        newPassword: z.string().min(6, "Password must be at least 6 characters")
      }).parse(req.body);

      console.log(`[PASSWORD RESET] Attempting to reset password with token`);

      // Get all non-expired, unused tokens
      const allTokens = await db.select()
        .from(passwordResetTokens)
        .where(eq(passwordResetTokens.isUsed, false));

      // Find matching token by comparing hashes
      let matchedTokenData = null;
      for (const tokenRecord of allTokens) {
        const isMatch = await authService.comparePassword(token, tokenRecord.token);
        if (isMatch && new Date() <= tokenRecord.expiresAt) {
          matchedTokenData = tokenRecord;
          break;
        }
      }

      if (!matchedTokenData) {
        console.log(`[PASSWORD RESET] Invalid or expired token`);
        return res.status(400).json({ error: "Invalid or expired reset token" });
      }

      const tokenData = matchedTokenData;

      // Get user
      const userRecord = await db.select()
        .from(users)
        .where(eq(users.id, tokenData.userId))
        .limit(1);

      if (!userRecord || userRecord.length === 0) {
        console.log(`[PASSWORD RESET] User not found for token`);
        return res.status(400).json({ error: "User not found" });
      }

      const user = userRecord[0];

      // Hash new password
      const hashedPassword = await authService.hashPassword(newPassword);

      // Update user password
      await db.update(users)
        .set({ passwordHash: hashedPassword })
        .where(eq(users.id, user.id));

      // Mark token as used
      await db.update(passwordResetTokens)
        .set({ isUsed: true })
        .where(eq(passwordResetTokens.id, tokenData.id));

      // Send confirmation email
      await emailService.sendPasswordResetConfirmationEmail(
        user.email,
        user.firstName
      );

      console.log(`[PASSWORD RESET] Password successfully reset for user: ${user.email}`);

      res.json({ message: "Password successfully reset. You can now log in with your new password." });
    } catch (error) {
      console.error("[PASSWORD RESET] Error:", error);
      res.status(500).json({ error: "Failed to reset password" });
    }
  });

  // Token validation endpoint (separate auth check)
  app.get("/api/auth/validate", async (req: TenantRequest, res) => {
    try {
      const token = authService.extractTokenFromHeader(req.get("Authorization"));
      
      if (!token) {
        return res.status(401).json({ error: "No token provided" });
      }

      const payload = authService.verifyToken(token);
      if (!payload) {
        return res.status(401).json({ error: "Invalid token" });
      }

      // Get user details
      const user = await storage.getUser(payload.userId, payload.organizationId);
      if (!user || !user.isActive) {
        return res.status(401).json({ error: "User not found or inactive" });
      }

      // Get organization subdomain to include in response
      const organization = await storage.getOrganization(user.organizationId);

      res.json({
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          department: user.department,
          organizationId: user.organizationId
        },
        organization: organization ? {
          id: organization.id,
          name: organization.name,
          subdomain: organization.subdomain
        } : null
      });
    } catch (error) {
      console.error("Token validation error:", error);
      res.status(401).json({ error: "Token validation failed" });
    }
  });

  // Tenant info endpoint (unprotected for initial load)
  app.get("/api/tenant/info", tenantMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.tenant) {
        return res.status(404).json({ error: "Tenant not found" });
      }
      
      res.json(req.tenant);
    } catch (error) {
      console.error("Tenant info error:", error);
      res.status(500).json({ error: "Failed to fetch tenant information" });
    }
  });

  // Organization settings endpoint (requires authentication)
  app.patch("/api/organization/settings", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const normalizedRequestBody = {
        ...req.body,
        permissions: normalizedPermissions,
      };
      console.log("Normalized permissions payload:", JSON.stringify(normalizedPermissions, null, 2));
      const updateData = z.object({
        name: z.string().optional(),
        brandName: z.string().optional(),
        region: z.string().optional(),
        settings: z.object({
          theme: z.object({
            primaryColor: z.string().optional()
          }).optional(),
          compliance: z.object({
            gdprEnabled: z.boolean().optional()
          }).optional(),
          features: z.object({
            aiEnabled: z.boolean().optional(),
            billingEnabled: z.boolean().optional()
          }).optional()
        }).optional()
      }).parse(req.body);

      const updatedOrganization = await storage.updateOrganization(req.tenant!.id, updateData);
      
      if (!updatedOrganization) {
        return res.status(404).json({ error: "Organization not found" });
      }

      res.json(updatedOrganization);
    } catch (error) {
      console.error("Organization settings update error:", error);
      res.status(500).json({ error: "Failed to update organization settings" });
    }
  });

  // QuickBooks OAuth callback - MUST be before authMiddleware since OAuth popup has no session
  app.get("/api/quickbooks/auth/callback", tenantMiddleware, async (req: TenantRequest, res) => {
    try {
      console.log("[QUICKBOOKS] OAuth callback received!");
      const { code, realmId, state } = req.query;
      
      if (!code || !realmId) {
        console.log("[QUICKBOOKS] Missing code or realmId");
        return res.status(400).send(`
          <html>
            <body>
              <h1>Error: Invalid OAuth callback</h1>
              <p>Missing required parameters</p>
            </body>
          </html>
        `);
      }

      console.log("[QUICKBOOKS] Code:", code);
      console.log("[QUICKBOOKS] Realm ID:", realmId);
      console.log("[QUICKBOOKS] State:", state);
      
      // Extract organization ID from state parameter
      let organizationId: number | undefined;
      if (state) {
        try {
          const stateData = JSON.parse(Buffer.from(state as string, 'base64').toString());
          organizationId = stateData.orgId;
          console.log("[QUICKBOOKS] Extracted orgId from state:", organizationId);
        } catch (e) {
          console.log("[QUICKBOOKS] Failed to parse state, falling back to tenant context");
        }
      }
      
      // Fallback to tenant context if state parsing failed
      if (!organizationId) {
        organizationId = req.tenant?.id;
      }
      
      if (!organizationId) {
        throw new Error("Organization ID not found in state or tenant context");
      }
      
      // Exchange authorization code for access and refresh tokens manually
      const redirectUri = process.env.QUICKBOOKS_REDIRECT_URI || `${process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}` : 'http://localhost:5000'}/api/quickbooks/auth/callback`;
      
      console.log("[QUICKBOOKS] Exchanging authorization code for tokens...");
      console.log("[QUICKBOOKS] Redirect URI:", redirectUri);
      
      // Manually exchange token using axios
      const axios = (await import('axios')).default;
      const authHeader = Buffer.from(`${process.env.QUICKBOOKS_CLIENT_ID}:${process.env.QUICKBOOKS_CLIENT_SECRET}`).toString('base64');
      
      const requestBody = `grant_type=authorization_code&code=${encodeURIComponent(code as string)}&redirect_uri=${encodeURIComponent(redirectUri)}`;
      console.log("[QUICKBOOKS] Request body length:", requestBody.length);
      
      const tokenResponse = await axios.post(
        'https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer',
        requestBody,
        {
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Authorization': `Basic ${authHeader}`,
          },
        }
      );
      
      const token = tokenResponse.data;
      
      console.log("[QUICKBOOKS] Token exchange successful!");
      console.log("[QUICKBOOKS] Access token received:", !!token.access_token);
      console.log("[QUICKBOOKS] Refresh token received:", !!token.refresh_token);
      console.log("[QUICKBOOKS] Expires in:", token.expires_in, "seconds");

      console.log("[QUICKBOOKS] Saving connection to database for organization:", organizationId);
      
      // Check if connection already exists
      const existingConnection = await db.select()
        .from(quickbooksConnections)
        .where(and(
          eq(quickbooksConnections.organizationId, organizationId),
          eq(quickbooksConnections.realmId, realmId as string)
        ))
        .limit(1);

      // Determine baseUrl based on environment
      const baseUrl = process.env.QUICKBOOKS_ENVIRONMENT === 'production' 
        ? 'https://quickbooks.api.intuit.com' 
        : 'https://sandbox-quickbooks.api.intuit.com';

      if (existingConnection.length > 0) {
        // Update existing connection
        console.log("[QUICKBOOKS] Updating existing connection");
        await db.update(quickbooksConnections)
          .set({
            accessToken: token.access_token,
            refreshToken: token.refresh_token,
            tokenExpiry: new Date(Date.now() + (token.expires_in * 1000)),
            isActive: true,
          })
          .where(eq(quickbooksConnections.id, existingConnection[0].id));
      } else {
        // Create new connection
        console.log("[QUICKBOOKS] Creating new connection");
        await db.insert(quickbooksConnections).values({
          organizationId,
          companyId: realmId as string, // Use realmId as companyId
          companyName: "QuickBooks Company", // Placeholder - will be updated after fetching company info
          realmId: realmId as string,
          accessToken: token.access_token,
          refreshToken: token.refresh_token,
          tokenExpiry: new Date(Date.now() + (token.expires_in * 1000)),
          baseUrl,
          isActive: true,
          syncSettings: {},
        });
      }

      console.log("[QUICKBOOKS] Connection saved successfully!");
      console.log("[QUICKBOOKS] About to send HTML response...");

      // Set proper headers to prevent caching and ensure HTML rendering
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate');
      res.setHeader('X-Frame-Options', 'SAMEORIGIN');
      console.log("[QUICKBOOKS] Headers set, building HTML...");
      
      const successHtml = `<!DOCTYPE html>
        <html>
          <head>
            <title>QuickBooks Connected</title>
            <style>
              body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
                margin: 0;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              }
              .success-container {
                background: white;
                padding: 3rem;
                border-radius: 16px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                text-align: center;
                max-width: 400px;
              }
              .checkmark {
                width: 80px;
                height: 80px;
                border-radius: 50%;
                background: #10b981;
                margin: 0 auto 1.5rem;
                display: flex;
                align-items: center;
                justify-content: center;
                animation: scaleIn 0.5s ease-out;
              }
              @keyframes scaleIn {
                from { transform: scale(0); }
                to { transform: scale(1); }
              }
              .checkmark svg {
                width: 50px;
                height: 50px;
                stroke: white;
                stroke-width: 3;
                fill: none;
                stroke-linecap: round;
                stroke-dasharray: 60;
                stroke-dashoffset: 60;
                animation: drawCheck 0.5s ease-out 0.3s forwards;
              }
              @keyframes drawCheck {
                to { stroke-dashoffset: 0; }
              }
              h1 {
                color: #10b981;
                font-size: 1.75rem;
                margin: 0 0 0.5rem;
              }
              p {
                color: #6b7280;
                margin: 0.5rem 0;
                line-height: 1.5;
              }
              .realm-id {
                font-family: monospace;
                background: #f3f4f6;
                padding: 0.5rem 1rem;
                border-radius: 8px;
                margin-top: 1rem;
                font-size: 0.875rem;
                color: #4b5563;
              }
            </style>
          </head>
          <body>
            <div class="success-container">
              <div class="checkmark">
                <svg viewBox="0 0 52 52">
                  <path d="M14 27l9 9 19-19" />
                </svg>
              </div>
              <h1>Successfully Connected!</h1>
              <p>Your QuickBooks account has been linked to Cura.</p>
              <div class="realm-id">Realm ID: ${realmId}</div>
            </div>
            <script>
              // Send message to parent window immediately (no console.log to avoid wrapping)
              if (window.parent && window.parent !== window) {
                window.parent.postMessage({ type: 'quickbooks-connected', realmId: '${realmId}' }, '*');
                // Log after sending to confirm
                setTimeout(() => console.log('[QB CALLBACK] Message sent to parent, realmId: ${realmId}'), 100);
              }
              // Fallback for popup window
              else if (window.opener) {
                window.opener.postMessage({ type: 'quickbooks-connected', realmId: '${realmId}' }, '*');
                window.close();
              }
            </script>
          </body>
        </html>`;
      
      console.log("[QUICKBOOKS] HTML length:", successHtml.length);
      console.log("[QUICKBOOKS] Sending response now...");
      res.send(successHtml);
      console.log("[QUICKBOOKS] Response sent successfully!");
    } catch (error) {
      console.error("[QUICKBOOKS] Error handling OAuth callback:", error);
      res.status(500).json({ error: "Failed to handle OAuth callback" });
    }
  });

  // Serve static files from uploads folder (public read-only access)
  // Headers already set by earlier middleware at line 724
  app.use("/uploads", express.static(path.join(process.cwd(), "uploads")));

  // Protected routes (auth required)
  app.use("/api", authMiddleware);

  // GDPR Compliance Routes
  app.post("/api/gdpr/consent", requireRole(["admin", "patient"]), async (req: TenantRequest, res) => {
    try {
      const consentData = insertGdprConsentSchema.parse({
        ...req.body,
        organizationId: req.tenant!.id
      });
      
      const consent = await gdprComplianceService.recordConsent(consentData);
      res.json(consent);
    } catch (error) {
      console.error("GDPR consent creation error:", error);
      res.status(500).json({ error: "Failed to record consent" });
    }
  });

  app.patch("/api/gdpr/consent/:id/withdraw", requireRole(["admin", "patient"]), async (req: TenantRequest, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      
      await gdprComplianceService.withdrawConsent(parseInt(id), req.tenant!.id, reason);
      res.json({ success: true });
    } catch (error) {
      console.error("GDPR consent withdrawal error:", error);
      res.status(500).json({ error: "Failed to withdraw consent" });
    }
  });

  app.post("/api/gdpr/data-request", requireRole(["admin", "patient"]), async (req: TenantRequest, res) => {
    try {
      // Calculate due date (30 days as per GDPR) before validation
      const dueDate = new Date();
      dueDate.setDate(dueDate.getDate() + 30);
      
      const requestData = insertGdprDataRequestSchema.parse({
        ...req.body,
        organizationId: req.tenant!.id,
        dueDate
      });
      
      const dataRequest = await gdprComplianceService.submitDataRequest(requestData);
      res.json(dataRequest);
    } catch (error) {
      console.error("GDPR data request error:", error);
      res.status(500).json({ error: "Failed to submit data request" });
    }
  });

  app.get("/api/gdpr/patient/:patientId/data-export", requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const { patientId } = req.params;
      const { requestId } = req.query;
      
      const exportData = await gdprComplianceService.exportPatientData(
        parseInt(patientId), 
        req.tenant!.id, 
        parseInt(requestId as string)
      );
      
      res.json(exportData);
    } catch (error) {
      console.error("GDPR data export error:", error);
      res.status(500).json({ error: "Failed to export patient data" });
    }
  });

  app.post("/api/gdpr/patient/:patientId/erasure", requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const { patientId } = req.params;
      const { requestId, reason } = req.body;
      
      await gdprComplianceService.processDataErasure(
        parseInt(patientId), 
        req.tenant!.id, 
        requestId, 
        reason
      );
      
      res.json({ success: true });
    } catch (error) {
      console.error("GDPR data erasure error:", error);
      res.status(500).json({ error: "Failed to process data erasure" });
    }
  });

  app.get("/api/gdpr/patient/:patientId/consent-status", requireRole(["admin", "doctor", "patient"]), async (req: TenantRequest, res) => {
    try {
      const { patientId } = req.params;
      const { consentType } = req.query;
      
      const consentStatus = await gdprComplianceService.checkConsentStatus(
        parseInt(patientId), 
        req.tenant!.id, 
        consentType as string
      );
      
      res.json(consentStatus);
    } catch (error) {
      console.error("GDPR consent status error:", error);
      res.status(500).json({ error: "Failed to check consent status" });
    }
  });

  app.get("/api/gdpr/compliance-report", requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const { period = "monthly" } = req.query;
      
      const report = await gdprComplianceService.generateComplianceReport(
        req.tenant!.id, 
        period as "monthly" | "quarterly" | "annual"
      );
      
      res.json(report);
    } catch (error) {
      console.error("GDPR compliance report error:", error);
      res.status(500).json({ error: "Failed to generate compliance report" });
    }
  });

  // Dashboard routes
  app.get("/api/dashboard/stats", async (req: TenantRequest, res) => {
    try {
      const stats = await storage.getDashboardStats(req.tenant!.id);
      res.json(stats);
    } catch (error) {
      console.error("Dashboard stats error:", error);
      res.status(500).json({ error: "Failed to fetch dashboard stats" });
    }
  });

  app.get("/api/dashboard/ai-insights", async (req: TenantRequest, res) => {
    try {
      const insights = await storage.getAiInsightsByOrganization(req.tenant!.id, 10);
      res.json(insights);
    } catch (error) {
      console.error("AI insights error:", error);
      res.status(500).json({ error: "Failed to fetch AI insights" });
    }
  });

  // Get current organization's subscription
  app.get("/api/subscriptions/current", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      // Query the database for the subscription
      const result = await db
        .select()
        .from(subscriptions)
        .where(eq(subscriptions.organizationId, organizationId))
        .limit(1);
      
      if (result.length === 0) {
        return res.status(404).json({ error: "No subscription found for this organization" });
      }
      
      // Count actual users in the organization (excluding SaaS owners)
      const userCountResult = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(users)
        .where(and(
          eq(users.organizationId, organizationId),
          eq(users.isSaaSOwner, false)
        ));
      
      const actualUserCount = userCountResult[0]?.count || 0;
      
      // Return subscription with actual user count
      res.json({
        ...result[0],
        currentUsers: actualUserCount
      });
    } catch (error) {
      console.error("Subscription fetch error:", error);
      res.status(500).json({ error: "Failed to fetch subscription" });
    }
  });

  // Get billing history (payment history) for current organization
  app.get("/api/billing-history", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const { saasPayments } = await import("../shared/schema");
      
      const payments = await db
        .select()
        .from(saasPayments)
        .where(eq(saasPayments.organizationId, organizationId))
        .orderBy(desc(saasPayments.paymentDate));
      
      res.json(payments);
    } catch (error) {
      console.error("Billing history fetch error:", error);
      res.status(500).json({ error: "Failed to fetch billing history" });
    }
  });

  // Download billing invoice PDF for a specific payment
  app.get("/api/billing-history/:paymentId/invoice", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const paymentId = parseInt(req.params.paymentId);
      const { saasPayments, saasSubscriptions, saasPackages, organizations } = await import("../shared/schema");
      
      // Get payment record
      const [payment] = await db
        .select()
        .from(saasPayments)
        .where(and(
          eq(saasPayments.id, paymentId),
          eq(saasPayments.organizationId, organizationId)
        ));
      
      if (!payment) {
        return res.status(404).json({ error: "Payment not found" });
      }
      
      // Get organization details
      const [org] = await db
        .select()
        .from(organizations)
        .where(eq(organizations.id, organizationId));
      
      // Get subscription and package details
      let packageName = "Subscription";
      if (payment.subscriptionId) {
        const [subscription] = await db
          .select()
          .from(saasSubscriptions)
          .where(eq(saasSubscriptions.id, payment.subscriptionId));
        
        if (subscription?.packageId) {
          const [pkg] = await db
            .select()
            .from(saasPackages)
            .where(eq(saasPackages.id, subscription.packageId));
          if (pkg) {
            packageName = pkg.name;
          }
        }
      }
      
      // Generate PDF using pdf-lib
      const { PDFDocument, rgb, StandardFonts } = await import('pdf-lib');
      const pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage([595, 842]); // A4 size
      const { width, height } = page.getSize();
      
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
      
      const darkText = rgb(0.1, 0.1, 0.1);
      const mutedText = rgb(0.4, 0.4, 0.4);
      const primaryBlue = rgb(0.2, 0.4, 0.8);
      
      let yPosition = height - 50;
      
      // Header
      page.drawText('INVOICE', {
        x: 50,
        y: yPosition,
        size: 28,
        font: boldFont,
        color: primaryBlue
      });
      
      page.drawText(payment.invoiceNumber, {
        x: width - 200,
        y: yPosition,
        size: 14,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 40;
      
      // Invoice details
      page.drawText(`Date: ${payment.paymentDate ? new Date(payment.paymentDate).toLocaleDateString('en-GB') : new Date().toLocaleDateString('en-GB')}`, {
        x: 50,
        y: yPosition,
        size: 10,
        font,
        color: mutedText
      });
      
      page.drawText(`Status: ${payment.paymentStatus.toUpperCase()}`, {
        x: width - 200,
        y: yPosition,
        size: 10,
        font,
        color: payment.paymentStatus === 'completed' ? rgb(0.1, 0.6, 0.1) : mutedText
      });
      
      yPosition -= 40;
      
      // Bill To section
      page.drawText('Bill To:', {
        x: 50,
        y: yPosition,
        size: 12,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 18;
      
      page.drawText(org?.name || 'Organization', {
        x: 50,
        y: yPosition,
        size: 11,
        font,
        color: darkText
      });
      
      yPosition -= 50;
      
      // Line separator
      page.drawLine({
        start: { x: 50, y: yPosition },
        end: { x: width - 50, y: yPosition },
        thickness: 1,
        color: rgb(0.85, 0.85, 0.85)
      });
      
      yPosition -= 30;
      
      // Table header
      page.drawText('Description', {
        x: 50,
        y: yPosition,
        size: 10,
        font: boldFont,
        color: mutedText
      });
      
      page.drawText('Period', {
        x: 250,
        y: yPosition,
        size: 10,
        font: boldFont,
        color: mutedText
      });
      
      page.drawText('Amount', {
        x: width - 100,
        y: yPosition,
        size: 10,
        font: boldFont,
        color: mutedText
      });
      
      yPosition -= 25;
      
      // Table row
      page.drawText(packageName, {
        x: 50,
        y: yPosition,
        size: 11,
        font,
        color: darkText
      });
      
      const periodStart = new Date(payment.periodStart).toLocaleDateString('en-GB', { day: '2-digit', month: 'short' });
      const periodEnd = new Date(payment.periodEnd).toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
      page.drawText(`${periodStart} - ${periodEnd}`, {
        x: 250,
        y: yPosition,
        size: 11,
        font,
        color: darkText
      });
      
      page.drawText(`${payment.currency} ${parseFloat(payment.amount).toFixed(2)}`, {
        x: width - 100,
        y: yPosition,
        size: 11,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 40;
      
      // Line separator
      page.drawLine({
        start: { x: 50, y: yPosition },
        end: { x: width - 50, y: yPosition },
        thickness: 1,
        color: rgb(0.85, 0.85, 0.85)
      });
      
      yPosition -= 25;
      
      // Total
      page.drawText('Total:', {
        x: width - 180,
        y: yPosition,
        size: 12,
        font: boldFont,
        color: darkText
      });
      
      page.drawText(`${payment.currency} ${parseFloat(payment.amount).toFixed(2)}`, {
        x: width - 100,
        y: yPosition,
        size: 14,
        font: boldFont,
        color: primaryBlue
      });
      
      yPosition -= 40;
      
      // Payment method
      page.drawText(`Payment Method: ${payment.paymentMethod.replace('_', ' ').toUpperCase()}`, {
        x: 50,
        y: yPosition,
        size: 10,
        font,
        color: mutedText
      });
      
      // Footer
      page.drawText('Thank you for your business!', {
        x: 50,
        y: 80,
        size: 10,
        font,
        color: mutedText
      });
      
      let pdfBytes = await pdfDoc.save();
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${payment.invoiceNumber}.pdf"`);
      res.send(Buffer.from(pdfBytes));
    } catch (error) {
      console.error("Invoice download error:", error);
      res.status(500).json({ error: "Failed to generate invoice" });
    }
  });

  // Get search suggestions for billing search
  app.get("/api/billing/search-suggestions", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const query = (req.query.query as string || "").toLowerCase().trim();
      
      if (query.length < 2) {
        return res.json([]);
      }

      const organizationId = req.tenant!.id;
      
      // Query invoices for suggestions
      const invoices = await db
        .select({
          invoiceNumber: schema.invoices.invoiceNumber,
          patientId: schema.invoices.patientId,
          patientName: schema.invoices.patientName,
        })
        .from(schema.invoices)
        .where(
          and(
            eq(schema.invoices.organizationId, organizationId),
            or(
              sql`LOWER(${schema.invoices.invoiceNumber}) LIKE ${`%${query}%`}`,
              sql`LOWER(CAST(${schema.invoices.patientId} AS TEXT)) LIKE ${`%${query}%`}`,
              sql`LOWER(${schema.invoices.patientName}) LIKE ${`%${query}%`}`
            )
          )
        )
        .limit(30);

      // Build suggestions array with deduplication
      const suggestions: Array<{
        type: 'invoice_id' | 'patient_id' | 'patient_name';
        value: string;
        display: string;
        searchValue: string;
      }> = [];
      
      const seenValues = new Set<string>();

      // Add invoice number suggestions
      invoices.forEach(inv => {
        if (inv.invoiceNumber && inv.invoiceNumber.toLowerCase().includes(query)) {
          const key = `invoice:${inv.invoiceNumber}`;
          if (!seenValues.has(key)) {
            seenValues.add(key);
            suggestions.push({
              type: 'invoice_id',
              value: inv.invoiceNumber,
              display: `Invoice: ${inv.invoiceNumber}`,
              searchValue: inv.invoiceNumber
            });
          }
        }
      });

      // Add patient ID suggestions
      invoices.forEach(inv => {
        if (inv.patientId && String(inv.patientId).toLowerCase().includes(query)) {
          const key = `patient_id:${inv.patientId}`;
          if (!seenValues.has(key)) {
            seenValues.add(key);
            suggestions.push({
              type: 'patient_id',
              value: String(inv.patientId),
              display: `Patient ID: ${inv.patientId}`,
              searchValue: String(inv.patientId)
            });
          }
        }
      });

      // Add patient name suggestions
      invoices.forEach(inv => {
        if (inv.patientName && inv.patientName.toLowerCase().includes(query)) {
          const key = `patient_name:${inv.patientName}`;
          if (!seenValues.has(key)) {
            seenValues.add(key);
            suggestions.push({
              type: 'patient_name',
              value: inv.patientName,
              display: `Patient: ${inv.patientName}`,
              searchValue: inv.patientName
            });
          }
        }
      });

      // Return top 10 suggestions
      res.json(suggestions.slice(0, 10));
    } catch (error) {
      console.error("Search suggestions fetch error:", error);
      res.status(500).json({ error: "Failed to fetch search suggestions" });
    }
  });

  // Generate anatomical treatment plan using OpenAI
  app.post("/api/ai/generate-treatment-plan", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const { 
        patientId,
        muscleGroup, 
        analysisType, 
        treatment, 
        treatmentIntensity, 
        sessionFrequency,
        primarySymptoms,
        severityScale,
        followUpPlan
      } = req.body;
      
      if (!patientId || !muscleGroup || !analysisType || !treatment) {
        return res.status(400).json({ error: "Required fields missing" });
      }

      console.log(`[GENERATE-TREATMENT-PLAN] Starting AI treatment plan generation for patient ${patientId}`);
      
      let treatmentPlan = "";
      try {
        // Generate treatment plan using OpenAI
        treatmentPlan = await aiService.generateAnatomicalTreatmentPlan({
          muscleGroup,
          analysisType,
          treatment,
          treatmentIntensity,
          sessionFrequency,
          primarySymptoms,
          severityScale,
          followUpPlan
        });
        console.log(`[GENERATE-TREATMENT-PLAN] OpenAI succeeded`);
      } catch (aiError) {
        console.log(`[GENERATE-TREATMENT-PLAN] OpenAI failed, using fallback template`);
        console.error(`[GENERATE-TREATMENT-PLAN] OpenAI Error:`, (aiError as Error)?.message || aiError);
        
        // Fallback treatment plan template
        treatmentPlan = `PROFESSIONAL ANATOMICAL TREATMENT PLAN

Target Area: ${muscleGroup.replace(/_/g, ' ').toUpperCase()}
Analysis Type: ${analysisType.replace(/_/g, ' ')}
Primary Treatment: ${treatment.replace(/_/g, ' ')}

CLINICAL ASSESSMENT:
The patient presents with symptoms affecting the ${muscleGroup.replace(/_/g, ' ')} region. Based on the ${analysisType.replace(/_/g, ' ')} analysis, the following treatment protocol is recommended.

Primary Symptoms: ${primarySymptoms || 'Not specified'}
Severity Rating: ${severityScale || 'Not specified'}

TREATMENT PROTOCOL:
1. Initial Assessment
   - Comprehensive evaluation of ${muscleGroup.replace(/_/g, ' ')} function and condition
   - Baseline documentation with clinical photography
   - Patient history and contraindication screening

2. Primary Treatment: ${treatment.replace(/_/g, ' ')}
   - Treatment Intensity: ${treatmentIntensity || 'Standard'}
   - Session Frequency: ${sessionFrequency || 'As recommended'}
   - Progressive monitoring of muscle response and patient tolerance
   - Adjustment of treatment parameters based on individual response

3. Monitoring and Follow-up
   - Regular assessment of treatment efficacy
   - Documentation of progressive improvements
   - ${followUpPlan || 'Follow-up assessment in 2-3 weeks'}

PATIENT EDUCATION:
- Expected timeline for visible results: 7-14 days
- Potential side effects and their management
- Post-treatment care instructions
- Activity restrictions and recommendations

SAFETY CONSIDERATIONS:
- Patient should be advised of all potential risks and contraindications
- Informed consent must be obtained prior to treatment
- Emergency protocols should be reviewed with patient
- Contact information for post-treatment concerns provided

This treatment plan should be reviewed and adjusted based on individual patient response and clinical judgment.`;
      }

      res.json({ 
        success: true, 
        treatmentPlan
      });
    } catch (error) {
      console.error("Treatment plan generation error:", error);
      res.status(500).json({ error: "Failed to generate treatment plan" });
    }
  });

  // Generate new AI insights using OpenAI
  app.post("/api/ai/generate-insights", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const { patientId } = req.body;
      
      if (!patientId) {
        return res.status(400).json({ error: "Patient ID is required" });
      }

      // Get patient data
      const patient = await storage.getPatient(parseInt(patientId), req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Get medical records
      const medicalRecords = await storage.getMedicalRecordsByPatient(parseInt(patientId), req.tenant!.id);

      console.log(`[GENERATE-INSIGHTS] Starting AI insight generation for patient ${patientId}`);
      
      let aiInsightsData = [];
      try {
        // Generate AI insights using OpenAI
        aiInsightsData = await aiService.analyzePatientRisk(patient, medicalRecords);
        console.log(`[GENERATE-INSIGHTS] OpenAI succeeded with ${aiInsightsData.length} insights`);
      } catch (aiError) {
        console.log(`[GENERATE-INSIGHTS] OpenAI failed, using fallback mock insights for patient ${patient.firstName} ${patient.lastName}`);
        console.error(`[GENERATE-INSIGHTS] OpenAI Error:`, (aiError as Error)?.message || aiError);
        
        // Fallback to mock insights when OpenAI fails
        aiInsightsData = [
          {
            type: "risk_assessment",
            title: "Clinical Risk Assessment",
            description: `Comprehensive risk analysis for ${patient.firstName} ${patient.lastName} shows moderate cardiovascular risk based on current medical history and demographics.`,
            severity: "medium",
            actionRequired: true,
            confidence: 85
          },
          {
            type: "preventive",
            title: "Preventive Care Recommendations",
            description: "Patient is due for routine preventive screenings including blood pressure monitoring, cholesterol check, and diabetes screening based on age and risk factors.",
            severity: "low",
            actionRequired: false,
            confidence: 78
          },
          {
            type: "diagnostic",
            title: "Diagnostic Considerations",
            description: "Based on medical history patterns, consider additional monitoring for chronic conditions and regular follow-up assessments.",
            severity: "low",
            actionRequired: false,
            confidence: 72
          }
        ];
        console.log(`[GENERATE-INSIGHTS] Created ${aiInsightsData.length} fallback insights`);
      }

      // Store new insights in database
      const savedInsights = [];
      for (const insightData of aiInsightsData) {
        try {
          console.log('Creating AI insight with data:', {
            organizationId: req.tenant!.id,
            patientId: parseInt(patientId),
            type: insightData.type,
            title: insightData.title,
            severity: insightData.severity
          });
          
          const insight = await storage.createAiInsight({
            organizationId: req.tenant!.id,
            patientId: parseInt(patientId),
            type: insightData.type,
            title: insightData.title,
            description: insightData.description,
            severity: insightData.severity,
            actionRequired: insightData.actionRequired,
            confidence: insightData.confidence.toString(),
            status: "active"
          });
          
          console.log('Successfully created AI insight:', insight.id);
          savedInsights.push(insight);
        } catch (insertError) {
          console.error('Failed to create AI insight:', insertError, 'Data:', insightData);
          // Continue with other insights even if one fails
        }
      }

      res.json({ 
        success: true, 
        insights: savedInsights,
        generated: savedInsights.length,
        patientName: `${patient.firstName} ${patient.lastName}`,
        usingFallbackData: aiInsightsData.length > 0 && !aiInsightsData[0].title?.includes("AI-generated")
      });
    } catch (error) {
      console.error("AI insight generation error:", error);
      res.status(500).json({ error: "Failed to generate AI insights" });
    }
  });

  // Patient routes
  app.get("/api/patients", authMiddleware, requireRole(["admin", "doctor", "nurse", "patient"]), async (req: TenantRequest, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const isActiveParam = req.query.isActive as string;
      
      // Parse isActive parameter: if provided, convert to boolean, otherwise undefined (return all)
      let isActive: boolean | undefined = undefined;
      if (isActiveParam !== undefined) {
        isActive = isActiveParam === 'true';
      }
      
      const patients = await storage.getPatientsByOrganization(req.tenant!.id, limit, isActive);
      res.json(patients);
    } catch (error) {
      console.error("Patients fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patients" });
    }
  });

  // Check patient email availability - checks if email exists in patients, users, or organizations
  app.get("/api/patients/check-email", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { email } = req.query;
      const currentOrgId = req.tenant!.id;

      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }

      // Check if email exists in patients table (same organization)
      const patientsInSameOrg = await storage.getPatientsByOrganization(currentOrgId, 1000);
      const patientInSameOrg = patientsInSameOrg.find(p => p.email === email);

      // Check if email exists in patients table (other organizations)
      const allPatients = await storage.getPatientsByOrganization(0, 1000); // Get all patients globally
      const patientInDifferentOrg = allPatients.find(p => p.email === email && p.organizationId !== currentOrgId);

      // Check if email exists in users table (same organization)
      const existingUser = await storage.getUserByEmailGlobal(email as string);
      const userInSameOrg = existingUser && existingUser.organizationId === currentOrgId;
      const userInDifferentOrg = existingUser && existingUser.organizationId !== currentOrgId;

      // Check if email exists in organizations table
      const [existingOrg] = await db
        .select()
        .from(organizations)
        .where(eq(organizations.email, email as string));
      const orgIsDifferent = existingOrg && existingOrg.id !== currentOrgId;

      // Determine if email is available
      const emailAvailable = !patientInSameOrg && !userInSameOrg && !patientInDifferentOrg && !userInDifferentOrg && !orgIsDifferent;
      const associatedWithAnotherOrg = patientInDifferentOrg || userInDifferentOrg || orgIsDifferent;

      // Prevent caching
      res.setHeader(
        "Cache-Control",
        "no-store, no-cache, must-revalidate, proxy-revalidate",
      );
      res.setHeader("Pragma", "no-cache");
      res.setHeader("Expires", "0");

      res.json({ 
        emailAvailable,
        associatedWithAnotherOrg: !emailAvailable && associatedWithAnotherOrg
      });
    } catch (error) {
      console.error("Error checking patient email availability:", error);
      res.status(500).json({ error: "Failed to check email availability" });
    }
  });

  // IMPORTANT: Specific routes must come before parameterized routes
  app.get("/api/patients/my-prescriptions", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      console.log("üè• MY-PRESCRIPTIONS DEBUG: Starting request for user:", req.user?.email);
      
      // Find the patient record by the authenticated user's email
      const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
      console.log("üè• MY-PRESCRIPTIONS DEBUG: Found patients count:", patients.length);
      
      const patient = patients.find(p => p.email === req.user!.email);
      console.log("üè• MY-PRESCRIPTIONS DEBUG: Found matching patient:", patient ? { id: patient.id, email: patient.email } : null);
      
      if (!patient) {
        console.log("üè• MY-PRESCRIPTIONS DEBUG: No patient found for email:", req.user!.email);
        return res.status(404).json({ error: "Patient record not found for authenticated user" });
      }
      
      console.log("üè• MY-PRESCRIPTIONS DEBUG: Getting prescriptions for patient ID:", patient.id);
      const prescriptions = await storage.getPrescriptionsByPatient(patient.id, req.tenant!.id);
      console.log("üè• MY-PRESCRIPTIONS DEBUG: Found prescriptions count:", prescriptions.length);
      
      res.json({
        prescriptions,
        totalCount: prescriptions.length,
        patientId: patient.id
      });
    } catch (error) {
      console.error("Error fetching patient prescriptions:", error);
      res.status(500).json({ error: "Failed to load prescriptions" });
    }
  });

  // Calculate patient health score - MUST come before /api/patients/:id
  app.get("/api/patients/health-score", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User authentication required" });
      }

      // Find patient by user email
      const patients = await storage.getPatientsByOrganization(req.tenant!.id);
      const matchingPatient = patients.find(p => p.email === req.user?.email);
      
      if (!matchingPatient) {
        return res.status(404).json({ error: "Patient record not found" });
      }

      // Get medical records for this patient
      const records = await storage.getMedicalRecordsByPatient(matchingPatient.id, req.tenant!.id);
      
      // Calculate health score
      const healthScore = calculateHealthScore(records, matchingPatient);
      
      res.json(healthScore);
    } catch (error) {
      console.error("Health score calculation error:", error);
      res.status(500).json({ error: "Failed to calculate health score" });
    }
  });

  app.get("/api/patients/:id", async (req: TenantRequest, res) => {
    try {
      console.log("üîç PATIENTS/:ID DEBUG - Raw ID param:", req.params.id);
      const patientId = parseInt(req.params.id);
      console.log("üîç PATIENTS/:ID DEBUG - Parsed ID:", patientId);
      
      if (isNaN(patientId)) {
        console.error("üîç PATIENTS/:ID DEBUG - Invalid ID provided:", req.params.id);
        return res.status(400).json({ error: "Invalid patient ID provided" });
      }
      
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Get AI insights for this patient
      const aiInsights = await storage.getAiInsightsByPatient(patientId, req.tenant!.id);

      res.json({
        ...patient,
        aiInsights
      });
    } catch (error) {
      console.error("Patient fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patient" });
    }
  });

  // Delete patient
  app.delete("/api/patients/:id", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      
      // Verify patient exists and belongs to organization
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Delete patient (this will cascade delete related records)
      const deleted = await storage.deletePatient(patientId, req.tenant!.id);
      
      if (!deleted) {
        return res.status(404).json({ error: "Failed to delete patient" });
      }

      res.json({ success: true, message: "Patient deleted successfully" });
    } catch (error) {
      console.error("Patient deletion error:", error);
      res.status(500).json({ error: "Failed to delete patient" });
    }
  });

  // Get patient medical records only
  app.get("/api/patients/:id/records", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const records = await storage.getMedicalRecordsByPatient(patientId, req.tenant!.id);
      res.json(records);
    } catch (error) {
      console.error("Medical records fetch error:", error);
      res.status(500).json({ error: "Failed to fetch medical records" });
    }
  });


  // Get patient history by ID
  app.get("/api/patients/:id/history", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Return patient's medical history and family history
      const history = {
        familyHistory: patient.medicalHistory?.familyHistory || {},
        socialHistory: patient.medicalHistory?.socialHistory || {},
        allergies: patient.medicalHistory?.allergies || [],
        chronicConditions: patient.medicalHistory?.chronicConditions || [],
        medications: patient.medicalHistory?.medications || [],
        immunizations: patient.medicalHistory?.immunizations || []
      };

      res.json(history);
    } catch (error) {
      console.error("Patient history fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patient history" });
    }
  });

  // Get patient prescriptions by ID
  app.get("/api/patients/:id/prescriptions", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      
      // Get prescriptions directly from prescriptions table
      const prescriptions = await storage.getPrescriptionsByPatient(patientId, req.tenant!.id);
      
      // Format prescriptions for frontend
      const formattedPrescriptions = prescriptions.map(prescription => ({
        id: prescription.id,
        medicationName: prescription.medicationName || 'Unknown medication',
        dosage: prescription.dosage || 'Not specified',
        frequency: prescription.frequency || 'Not specified',
        duration: prescription.duration || 'Not specified',
        instructions: prescription.instructions || 'No instructions',
        prescribedBy: 'Dr. Unknown', // TODO: Link to doctor via doctorId
        prescribedDate: prescription.prescribedAt || prescription.createdAt,
        status: prescription.status || 'active',
        diagnosis: prescription.diagnosis || 'No diagnosis specified',
        medications: prescription.medications || [],
        providerId: prescription.doctorId,
        createdAt: prescription.createdAt
      }));

      res.json(formattedPrescriptions);
    } catch (error) {
      console.error("Patient prescriptions fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patient prescriptions" });
    }
  });

  // Get patient lab results by ID
  app.get("/api/patients/:id/pending-results", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const organizationId = requireOrgId(req);

      if (isNaN(patientId)) {
        return res.status(400).json({ error: "Invalid patient ID" });
      }

      // Fetch pending records from all relevant tables
      const pendingPrescriptions = await storage.getPrescriptionsByStatus(patientId, organizationId, "pending");
      const pendingLabResults = await storage.getLabResultsByStatus(patientId, organizationId, "pending"); 
      const pendingAiInsights = await storage.getAiInsightsByStatus(patientId, organizationId, "pending");
      const pendingClaims = await storage.getClaimsByStatus(patientId, organizationId, "pending");
      const pendingVoiceNotes = await storage.getVoiceNotesByStatus(patientId, organizationId, "pending");
      
      // Get all medical records (since they don't have status field)
      const allMedicalRecords = await storage.getMedicalRecordsByPatient(patientId, organizationId);

      // Calculate totals
      const totalCount = 
        (pendingPrescriptions?.length || 0) +
        (pendingLabResults?.length || 0) +
        (pendingAiInsights?.length || 0) +
        (pendingClaims?.length || 0) +
        (pendingVoiceNotes?.length || 0) +
        (allMedicalRecords?.length || 0);

      res.json({
        totalCount,
        prescriptions: pendingPrescriptions || [],
        labResults: pendingLabResults || [],
        medicalRecords: allMedicalRecords || [],
        aiInsights: pendingAiInsights || [],
        voiceNotes: pendingVoiceNotes || [],
        claims: pendingClaims || []
      });
    } catch (error) {
      return handleRouteError(error, "fetch patient pending results", res);
    }
  });

  app.get("/api/patients/:id/lab-results", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      
      // Get lab results for this patient
      const labResults = await storage.getLabResultsByPatient(patientId, req.tenant!.id);
      
      // Format lab results for frontend display
      const formattedLabResults = labResults.map(labResult => {
        // If results array has data, use the first result for main display
        const primaryResult = labResult.results && labResult.results.length > 0 ? labResult.results[0] : null;
        
        return {
          id: labResult.id,
          testId: labResult.testId || 'Not specified',
          testName: labResult.testType || 'Lab Test',
          name: labResult.testType || 'Lab Test',
          testType: labResult.testType,
          status: labResult.status || 'completed',
          testDate: labResult.completedAt || labResult.collectedAt || labResult.orderedAt || labResult.createdAt,
          orderedAt: labResult.orderedAt,
          collectedAt: labResult.collectedAt,
          completedAt: labResult.completedAt,
          priority: labResult.priority || 'routine',
          // Use primary result values or fallback
          result: primaryResult?.value || 'N/A',
          value: primaryResult?.value || 'N/A',
          referenceRange: primaryResult?.referenceRange || 'Not specified',
          units: primaryResult?.unit || 'Not specified',
          unit: primaryResult?.unit || 'Not specified',
          // Additional fields
          results: labResult.results || [],
          criticalValues: labResult.criticalValues || false,
          notes: labResult.notes || '',
          doctorName: labResult.doctorName || 'Unknown',
          orderedBy: labResult.orderedBy,
          createdAt: labResult.createdAt
        };
      });
      
      res.json(formattedLabResults);
    } catch (error) {
      console.error("Patient lab results fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patient lab results" });
    }
  });

  // Get patient medical imaging by ID
  app.get("/api/patients/:id/medical-imaging", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      
      // Get medical imaging for this patient
      const imaging = await storage.getMedicalImagesByPatient(patientId, req.tenant!.id);
      
      res.json(imaging || []);
    } catch (error) {
      console.error("Patient medical imaging fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patient medical imaging" });
    }
  });

  // Get patient insurance information by ID
  app.get("/api/patients/:id/insurance", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Return patient's insurance information
      res.json(patient.insuranceInfo || {});
    } catch (error) {
      console.error("Patient insurance fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patient insurance information" });
    }
  });

  // Get patient address information by ID
  app.get("/api/patients/:id/address", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Return patient's address information
      res.json(patient.address || {});
    } catch (error) {
      console.error("Patient address fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patient address information" });
    }
  });

  // Get patient emergency contact by ID
  app.get("/api/patients/:id/emergency-contact", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Return patient's emergency contact information
      res.json(patient.emergencyContact || {});
    } catch (error) {
      console.error("Patient emergency contact fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patient emergency contact information" });
    }
  });

  // Get patient invoices by ID
  app.get("/api/patients/:id/invoices", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Get invoices for this patient using patientId string
      const invoices = await storage.getInvoicesByPatient(patient.patientId, req.tenant!.id);
      
      res.json(invoices || []);
    } catch (error) {
      console.error("Patient invoices fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patient invoices" });
    }
  });

  // Get patient payments by ID
  app.get("/api/patients/:id/payments", async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Get all invoices for this patient (default to empty array if undefined)
      const invoices = await storage.getInvoicesByPatient(patient.patientId, req.tenant!.id) || [];
      
      // Get payments for each invoice
      const allPayments = [];
      for (const invoice of invoices) {
        const payments = await storage.getPaymentsByInvoice(invoice.id, req.tenant!.id) || [];
        allPayments.push(...payments);
      }
      
      res.json(allPayments);
    } catch (error) {
      console.error("Patient payments fetch error:", error);
      res.status(500).json({ error: "Failed to fetch patient payments" });
    }
  });

  // Create medical record for patient
  app.post("/api/patients/:id/records", authMiddleware, requireNonPatientRole(), async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      
      const recordData = z.object({
        type: z.enum(["consultation", "prescription", "lab_result", "imaging", "history", "examination", "assessment", "summary", "vitals"]),
        title: z.string().min(1),
        notes: z.string().optional(),
        diagnosis: z.string().optional(),
        treatment: z.string().optional(),
        prescription: z.object({
          medications: z.array(z.object({
            name: z.string(),
            dosage: z.string(),
            frequency: z.string(),
            duration: z.string(),
            instructions: z.string().optional()
          })).optional()
        }).optional(),
        followUpRequired: z.boolean().optional(),
        followUpDate: z.string().optional(),
        referrals: z.array(z.object({
          specialist: z.string(),
          reason: z.string(),
          urgency: z.string()
        })).optional()
      }).parse(req.body);

      const record = await storage.createMedicalRecord({
        ...recordData,
        organizationId: req.tenant!.id,
        patientId,
        providerId: req.user!.id,
        recordType: recordData.type, // Add required recordType
        content: recordData.notes || recordData.title, // Add required content
        prescription: recordData.prescription || {},
        attachments: [],
        aiSuggestions: {}
      });

      res.status(201).json(record);
    } catch (error) {
      console.error("Medical record creation error:", error);
      res.status(500).json({ error: "Failed to create medical record" });
    }
  });

  app.post("/api/patients", requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      console.log("üîç [PATIENT_CREATION] Received request body:", JSON.stringify(req.body, null, 2));
      console.log("üîç [PATIENT_CREATION] Insurance info from body:", JSON.stringify(req.body.insuranceInfo, null, 2));
      console.log("üîç [PATIENT_CREATION] Insurance info type:", typeof req.body.insuranceInfo);
      console.log("üîç [PATIENT_CREATION] Insurance info keys:", req.body.insuranceInfo ? Object.keys(req.body.insuranceInfo) : 'null/undefined');
      
      const patientData = z.object({
        firstName: z.string().min(2, "First name must be at least 2 characters").max(30, "First name cannot exceed 30 characters"),
        lastName: z.string().min(2, "Last name must be at least 2 characters").max(30, "Last name cannot exceed 30 characters"),
        dateOfBirth: z.string().transform(str => new Date(str)),
        genderAtBirth: z.string().optional(),
        email: z.string().email().optional(),
        phone: z.string().optional(),
        nhsNumber: z.string().optional(),
        address: z.object({
          street: z.string().optional(),
          city: z.string().optional(),
          state: z.string().optional(),
          postcode: z.string().optional(),
          country: z.string().optional()
        }).optional(),
        emergencyContact: z.object({
          name: z.string().optional(),
          relationship: z.string().optional(),
          phone: z.string().optional()
        }).optional(),
        insuranceInfo: z.object({
          provider: z.string().optional(),
          policyNumber: z.string().optional(),
          groupNumber: z.string().optional(),
          memberNumber: z.string().optional(),
          planType: z.string().optional(),
          effectiveDate: z.string().optional(),
          expirationDate: z.string().optional(),
          copay: z.number().optional(),
          deductible: z.number().optional(),
          isActive: z.boolean().optional()
        }).optional(),
        medicalHistory: z.object({
          allergies: z.array(z.string()).optional(),
          chronicConditions: z.array(z.string()).optional(),
          medications: z.array(z.string()).optional(),
          familyHistory: z.object({
            father: z.array(z.string()).optional(),
            mother: z.array(z.string()).optional(),
            siblings: z.array(z.string()).optional(),
            grandparents: z.array(z.string()).optional()
          }).optional(),
          socialHistory: z.object({
            smoking: z.object({
              status: z.enum(["never", "former", "current"]).optional(),
              packsPerDay: z.number().optional(),
              yearsSmoked: z.number().optional(),
              quitDate: z.string().optional()
            }).optional(),
            alcohol: z.object({
              status: z.enum(["never", "occasional", "moderate", "heavy"]).optional(),
              drinksPerWeek: z.number().optional()
            }).optional(),
            drugs: z.object({
              status: z.enum(["never", "former", "current"]).optional(),
              substances: z.array(z.string()).optional(),
              notes: z.string().optional()
            }).optional(),
            occupation: z.string().optional(),
            maritalStatus: z.enum(["single", "married", "divorced", "widowed", "partner"]).optional(),
            education: z.string().optional(),
            exercise: z.object({
              frequency: z.enum(["none", "occasional", "regular", "daily"]).optional(),
              type: z.string().optional(),
              duration: z.string().optional()
            }).optional()
          }).optional(),
          immunizations: z.array(z.object({
            id: z.string(),
            vaccine: z.string(),
            date: z.string(),
            provider: z.string(),
            lot: z.string().optional(),
            site: z.string().optional(),
            notes: z.string().optional()
          })).optional()
        }).optional()
      }).parse(req.body);

      console.log("üîç [PATIENT_CREATION] After Zod validation - insuranceInfo:", JSON.stringify(patientData.insuranceInfo, null, 2));
      console.log("üîç [PATIENT_CREATION] After Zod validation - insuranceInfo type:", typeof patientData.insuranceInfo);

      // Generate patient ID
      const patientCount = await storage.getPatientsByOrganization(req.tenant!.id, 999999);
      const patientId = `P${(patientCount.length + 1).toString().padStart(6, '0')}`;

      // Use database transaction to ensure atomicity
      const patient = await db.transaction(async (tx) => {
        // Step 1: Create user record in users table with hashed password
        console.log("üîµ [PATIENT_CREATION] Starting transaction...");
        const hashedPassword = await bcrypt.hash("cura123", 10);
        console.log("üîµ [PATIENT_CREATION] Password hashed successfully");
        
        const [newUser] = await tx.insert(users).values({
          organizationId: req.tenant!.id,
          email: patientData.email || `patient_${Date.now()}@placeholder.com`,
          username: patientData.email || `patient_${Date.now()}`,
          passwordHash: hashedPassword,
          firstName: patientData.firstName,
          lastName: patientData.lastName,
          role: 'patient',
          department: null,
          medicalSpecialtyCategory: null,
          subSpecialty: null,
          workingDays: [],
          workingHours: {},
          permissions: {},
          isActive: true,
          isSaaSOwner: false
        }).returning();
        
        console.log("‚úÖ [PATIENT_CREATION] User created successfully:", { id: newUser.id, email: newUser.email, role: newUser.role });

        // Step 2: Create patient record with user_id foreign key
        const medicalHistoryData = {
          allergies: patientData.medicalHistory?.allergies || [],
          chronicConditions: patientData.medicalHistory?.chronicConditions || [],
          medications: patientData.medicalHistory?.medications || [],
          familyHistory: {
            father: [],
            mother: [],
            siblings: [],
            grandparents: [],
            ...patientData.medicalHistory?.familyHistory
          },
          socialHistory: {
            smoking: { status: "never" },
            alcohol: { status: "never" },
            drugs: { status: "never" },
            occupation: "",
            maritalStatus: "single",
            education: "",
            exercise: { frequency: "none" },
            ...patientData.medicalHistory?.socialHistory
          },
          immunizations: patientData.medicalHistory?.immunizations || [],
          ...patientData.medicalHistory
        };

        const patientInsertData = {
          ...patientData,
          organizationId: req.tenant!.id,
          userId: newUser.id, // Foreign key to users table
          patientId,
          address: patientData.address || {},
          emergencyContact: patientData.emergencyContact || {},
          insuranceInfo: patientData.insuranceInfo || {},
          medicalHistory: medicalHistoryData
        };

        console.log("üîç [PATIENT_CREATION] Data being inserted into database - insuranceInfo:", JSON.stringify(patientInsertData.insuranceInfo, null, 2));

        const [patientRecord] = await tx.insert(patients).values(enforceCreatedBy(req, patientInsertData as any)).returning();
        
        console.log("‚úÖ [PATIENT_CREATION] Patient record created successfully:", { id: patientRecord.id, patientId: patientRecord.patientId, userId: newUser.id });

        // Step 3: Create insurance verification record if insurance info is provided
        console.log("üîç [INSURANCE_CHECK] Checking insurance info:", {
          hasInsuranceInfo: !!patientData.insuranceInfo,
          provider: patientData.insuranceInfo?.provider,
          policyNumber: patientData.insuranceInfo?.policyNumber,
          providerLength: (patientData.insuranceInfo?.provider?.trim() ?? "").length,
          policyNumberLength: (patientData.insuranceInfo?.policyNumber?.trim() ?? "").length,
          conditionResult: !!(patientData.insuranceInfo && (patientData.insuranceInfo.provider?.trim() || patientData.insuranceInfo.policyNumber?.trim()))
        });
        
        // Check if either provider or policyNumber has a non-empty value (trim to handle whitespace-only strings)
        if (patientData.insuranceInfo && (patientData.insuranceInfo.provider?.trim() || patientData.insuranceInfo.policyNumber?.trim())) {
          console.log("‚úÖ [INSURANCE_CHECK] Condition passed - Creating insurance verification record");
          const insuranceData: any = {
            organizationId: req.tenant!.id,
            patientId: patientRecord.id,
            patientName: `${patientData.firstName} ${patientData.lastName}`,
            provider: patientData.insuranceInfo.provider || '',
            policyNumber: patientData.insuranceInfo.policyNumber || '',
            groupNumber: patientData.insuranceInfo.groupNumber || null,
            memberNumber: patientData.insuranceInfo.memberNumber || null,
            nhsNumber: patientData.nhsNumber || null,
            planType: patientData.insuranceInfo.planType || null,
            coverageType: 'primary' as const,
            status: patientData.insuranceInfo.isActive ? ('active' as const) : ('inactive' as const),
            eligibilityStatus: 'pending' as const,
            effectiveDate: patientData.insuranceInfo.effectiveDate ? new Date(patientData.insuranceInfo.effectiveDate) : null,
            expirationDate: patientData.insuranceInfo.expirationDate ? new Date(patientData.insuranceInfo.expirationDate) : null,
            lastVerified: null,
            benefits: {
              deductible: patientData.insuranceInfo.deductible || 0,
              copay: patientData.insuranceInfo.copay || 0
            }
          };

          const [insuranceRecord] = await tx.insert(insuranceVerifications).values(insuranceData as any).returning();
          console.log("‚úÖ [PATIENT_CREATION] Insurance verification record created:", { id: insuranceRecord.id, provider: insuranceRecord.provider });
        }

        console.log("üéâ [PATIENT_CREATION] Transaction completed successfully!");

        return patientRecord;
      });

      // Generate AI insights for new patient
      if (req.tenant!.settings?.features?.aiEnabled) {
        try {
          const insights = await aiService.generatePreventiveCareReminders(patient);
          
          for (const insight of insights) {
            await storage.createAiInsight({
              organizationId: req.tenant!.id,
              patientId: patient.id,
              type: insight.type,
              title: insight.title,
              description: insight.description,
              severity: insight.severity,
              actionRequired: insight.actionRequired,
              confidence: insight.confidence.toString()
            });
          }
        } catch (aiError) {
          console.error("AI insights generation failed:", aiError);
        }
      }

      res.status(201).json(patient);
    } catch (error) {
      console.error("‚ùå [PATIENT_CREATION] Patient creation error:", error);
      if (error instanceof Error) {
        console.error("‚ùå [PATIENT_CREATION] Error message:", error.message);
        console.error("‚ùå [PATIENT_CREATION] Error stack:", error.stack);
      }
      res.status(500).json({ error: "Failed to create patient" });
    }
  });

  // Update patient medical history
  app.patch("/api/patients/:id/medical-history", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const medicalHistoryUpdate = req.body;

      console.log("=== MEDICAL HISTORY UPDATE DEBUG ===");
      console.log("Patient ID:", patientId);
      console.log("Received familyHistory:", JSON.stringify(medicalHistoryUpdate.familyHistory, null, 2));

      const patient = await storage.getPatient(patientId, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      console.log("Current medical history:", JSON.stringify(patient.medicalHistory, null, 2));

      // Preserve all existing medical history and merge with updates
      const updatedMedicalHistory = {
        ...patient.medicalHistory,
        ...medicalHistoryUpdate,
        // Ensure arrays are properly handled
        allergies: medicalHistoryUpdate.allergies || patient.medicalHistory?.allergies || [],
        chronicConditions: medicalHistoryUpdate.chronicConditions || patient.medicalHistory?.chronicConditions || [],
        medications: medicalHistoryUpdate.medications || patient.medicalHistory?.medications || [],
        familyHistory: {
          ...patient.medicalHistory?.familyHistory,
          ...medicalHistoryUpdate.familyHistory
        },
        socialHistory: {
          ...patient.medicalHistory?.socialHistory,
          ...medicalHistoryUpdate.socialHistory
        },
        immunizations: medicalHistoryUpdate.immunizations || patient.medicalHistory?.immunizations || []
      };

      console.log("Final merged medical history:", JSON.stringify(updatedMedicalHistory, null, 2));

      const updatedPatient = await storage.updatePatient(patientId, req.tenant!.id, {
        medicalHistory: updatedMedicalHistory
      });

      console.log("Updated patient medical history:", JSON.stringify(updatedPatient?.medicalHistory, null, 2));
      console.log("=== END DEBUG ===");

      res.json(updatedPatient);
    } catch (error) {
      console.error("Error updating patient medical history:", error);
      res.status(500).json({ error: "Failed to update medical history" });
    }
  });

  // Update patient data (comprehensive schema)
  app.patch("/api/patients/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      
      // Check permissions: doctors, nurses, and admins can update any patient
      // Patients can only update their own record
      const userRole = req.user?.role;
      const userEmail = req.user?.email;
      
      if (userRole === "patient") {
        // For patients, verify they're updating their own record
        const patient = await storage.getPatient(patientId, req.tenant!.id);
        if (!patient) {
          return res.status(404).json({ error: "Patient not found" });
        }
        
        if (patient.email !== userEmail) {
          return res.status(403).json({ error: "Patients can only update their own records" });
        }
      } else if (!["doctor", "nurse", "admin"].includes(userRole || "")) {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      
      const updateData = z.object({
        firstName: z.string().trim().min(1, "First name is required").optional(),
        lastName: z.string().trim().min(1, "Last name is required").optional(),
        dateOfBirth: z.string().trim().min(1, "Date of birth is required").refine(
          (val) => !isNaN(Date.parse(val)),
          { message: "Please enter a valid date" }
        ).optional(),
        genderAtBirth: z.string().trim().optional(),
        email: z.string().trim().email("Please enter a valid email address").optional().or(z.literal("")),
        phone: z.string().trim().min(1, "Phone number is required").regex(
          /^[\+]?[0-9\s\-\(\)]{10,}$/,
          "Please enter a valid phone number"
        ).optional(),
        nhsNumber: z.string().trim().optional(),
        address: z.object({
          street: z.string().trim().optional(),
          city: z.string().trim().optional(),
          state: z.string().trim().optional(),
          postcode: z.string().trim().optional(),
          country: z.string().trim().optional()
        }).optional(),
        insuranceInfo: z.object({
          provider: z.string().trim().optional(),
          policyNumber: z.string().trim().optional(),
          groupNumber: z.string().trim().optional(),
          memberNumber: z.string().trim().optional(),
          planType: z.string().trim().optional(),
          effectiveDate: z.string().trim().optional(),
          expirationDate: z.string().trim().optional(),
          copay: z.coerce.number({ invalid_type_error: "Must be a number" }).min(0, "Cannot be negative").optional(),
          deductible: z.coerce.number({ invalid_type_error: "Must be a number" }).min(0, "Cannot be negative").optional(),
          isActive: z.boolean().optional()
        }).optional(),
        emergencyContact: z.object({
          name: z.string().trim().optional(),
          relationship: z.string().trim().optional(),
          phone: z.string().trim().regex(
            /^[\+]?[0-9\s\-\(\)]{10,}$/,
            "Please enter a valid phone number"
          ).optional(),
          email: z.string().trim().email("Please enter a valid email address").optional().or(z.literal(""))
        }).optional(),
        medicalHistory: z.object({
          allergies: z.array(z.string()).optional(),
          chronicConditions: z.array(z.string()).optional(),
          medications: z.array(z.string()).optional(),
          familyHistory: z.object({
            father: z.array(z.string()).optional(),
            mother: z.array(z.string()).optional(),
            siblings: z.array(z.string()).optional(),
            grandparents: z.array(z.string()).optional()
          }).optional(),
          socialHistory: z.object({
            smoking: z.object({ status: z.string() }).optional(),
            alcohol: z.object({ status: z.string() }).optional(),
            drugs: z.object({ status: z.string() }).optional(),
            exercise: z.object({ frequency: z.string() }).optional(),
            education: z.string().optional(),
            occupation: z.string().optional(),
            maritalStatus: z.string().optional()
          }).optional(),
          immunizations: z.array(z.string()).optional()
        }).optional(),
        communicationPreferences: z.object({
          preferredMethod: z.enum(["email", "sms", "phone"]).optional(),
          language: z.string().optional(),
          marketingConsent: z.boolean().optional()
        }).optional(),
        flags: z.array(z.string()).optional(),
        riskLevel: z.enum(["low", "medium", "high", "critical"]).optional(),
        isActive: z.boolean().optional()
      }).parse(req.body);

      const patient = await storage.getPatient(patientId, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Convert dateOfBirth string to proper format for storage
      const storageUpdateData: any = { ...updateData };
      if (updateData.dateOfBirth) {
        // Since the database uses { mode: 'string' }, we keep it as string but ensure it's in YYYY-MM-DD format
        const parsedDate = new Date(updateData.dateOfBirth);
        storageUpdateData.dateOfBirth = parsedDate.toISOString().split('T')[0]; // YYYY-MM-DD format
      }

      const updatedPatient = await storage.updatePatient(patientId, req.tenant!.id, storageUpdateData);

      if (!updatedPatient) {
        return res.status(404).json({ error: "Failed to update patient" });
      }

      // Sync patient updates to the corresponding user record if userId exists
      if (patient.userId) {
        const userUpdates: any = {};
        
        // Map patient fields to user fields
        if (updateData.email !== undefined) {
          userUpdates.email = updateData.email;
        }
        if (updateData.firstName !== undefined) {
          userUpdates.firstName = updateData.firstName;
        }
        if (updateData.lastName !== undefined) {
          userUpdates.lastName = updateData.lastName;
        }
        if (updateData.phone !== undefined) {
          userUpdates.phone = updateData.phone;
        }
        
        // Only update user if there are fields to sync
        if (Object.keys(userUpdates).length > 0) {
          try {
            console.log(`Syncing patient ${patientId} updates to user ${patient.userId}:`, userUpdates);
            await storage.updateUser(patient.userId, req.tenant!.id, userUpdates);
            console.log(`Successfully synced patient updates to user ${patient.userId}`);
          } catch (userUpdateError) {
            console.error(`Failed to sync patient updates to user ${patient.userId}:`, userUpdateError);
            // Don't fail the request, just log the error - patient update was successful
          }
        }
      }

      // Send notification for important patient updates
      if (patient.userId && (updateData.riskLevel || updateData.flags)) {
        let notificationTitle = "Patient Record Updated";
        let notificationMessage = "Your medical record has been updated.";
        let priority: "low" | "normal" | "high" | "critical" = "normal";
        
        // Customize notification based on what changed
        if (updateData.riskLevel) {
          if (updateData.riskLevel === "critical" || updateData.riskLevel === "high") {
            notificationTitle = "Important Medical Alert";
            notificationMessage = `Your risk level has been updated to ${updateData.riskLevel}. Please contact your healthcare provider.`;
            priority = updateData.riskLevel === "critical" ? "critical" : "high";
          } else {
            notificationMessage = `Your risk level has been updated to ${updateData.riskLevel}.`;
          }
        } else if (updateData.flags && updateData.flags.length > 0) {
          notificationTitle = "Medical Alert Added";
          notificationMessage = "A new medical alert has been added to your record. Please review.";
          priority = "high";
        }
        
        await createNotification({
          organizationId: req.tenant!.id,
          userId: patient.userId,
          title: notificationTitle,
          message: notificationMessage,
          type: "patient_update",
          priority: priority,
          actionUrl: `/patients/${patientId}`,
          metadata: {
            patientId: patient.id,
            patientName: `${patient.firstName} ${patient.lastName}`,
            department: "Medical Records",
          }
        });
      }

      res.json(updatedPatient);
    } catch (error) {
      handleRouteError(error, "Update patient", res);
    }
  });


  // Update medical record endpoint
  app.patch("/api/patients/:patientId/records/:recordId", authMiddleware, requireNonPatientRole(), async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.patientId);
      const recordId = parseInt(req.params.recordId);
      
      const updateData = z.object({
        type: z.enum(["consultation", "prescription", "lab_result", "imaging", "history", "examination", "assessment", "summary", "vitals"]).optional(),
        title: z.string().optional(),
        notes: z.string().optional(),
        diagnosis: z.string().optional(),
        treatment: z.string().optional(),
        prescription: z.object({
          medications: z.array(z.object({
            name: z.string(),
            dosage: z.string(),
            frequency: z.string(),
            duration: z.string()
          })).optional()
        }).optional()
      }).parse(req.body);

      const existingRecord = await storage.getMedicalRecord(recordId, req.tenant!.id);
      if (!existingRecord || existingRecord.patientId !== patientId) {
        return res.status(404).json({ error: "Medical record not found" });
      }

      const updatedRecord = await storage.updateMedicalRecord(recordId, req.tenant!.id, {
        ...updateData,
        prescription: updateData.prescription || existingRecord.prescription || {}
      });

      if (!updatedRecord) {
        return res.status(404).json({ error: "Failed to update medical record" });
      }

      res.json(updatedRecord);
    } catch (error) {
      console.error("Medical record update error:", error);
      res.status(500).json({ error: "Failed to update medical record" });
    }
  });

  // Delete medical record endpoint
  app.delete("/api/patients/:patientId/records/:recordId", authMiddleware, requireNonPatientRole(), async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.patientId);
      const recordId = parseInt(req.params.recordId);

      const existingRecord = await storage.getMedicalRecord(recordId, req.tenant!.id);
      if (!existingRecord || existingRecord.patientId !== patientId) {
        return res.status(404).json({ error: "Medical record not found" });
      }

      const deleted = await storage.deleteMedicalRecord(recordId, req.tenant!.id);

      if (!deleted) {
        return res.status(404).json({ error: "Failed to delete medical record" });
      }

      res.json({ success: true, message: "Medical record deleted successfully" });
    } catch (error) {
      console.error("Medical record delete error:", error);
      res.status(500).json({ error: "Failed to delete medical record" });
    }
  });

  // Enhanced patient reminder endpoint with communication tracking
  // Prescription safety check endpoint
  app.post("/api/prescription/safety-check", authMiddleware, requireRole(["doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const safetyData = z.object({
        patientId: z.number(),
        medications: z.array(z.object({
          name: z.string(),
          dosage: z.string(),
          frequency: z.string().optional(),
          duration: z.string().optional()
        }))
      }).parse(req.body);

      const patient = await storage.getPatient(safetyData.patientId, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      const safetyAnalysis = await aiService.analyzePrescription(
        safetyData.medications,
        {
          age: new Date().getFullYear() - new Date(patient.dateOfBirth).getFullYear(),
          allergies: patient.medicalHistory?.allergies || [],
          conditions: patient.medicalHistory?.chronicConditions || []
        }
      );

      res.json({
        success: true,
        patientId: safetyData.patientId,
        analysis: safetyAnalysis,
        riskLevel: safetyAnalysis.interactions.length > 0 || safetyAnalysis.allergyWarnings.length > 0 || safetyAnalysis.contraindications.length > 0 ? "high" : "low",
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error("Prescription safety check error:", error);
      res.status(500).json({ error: "Failed to perform safety check" });
    }
  });

  app.post("/api/patients/:id/send-reminder", requireRole(["doctor", "nurse", "receptionist", "admin"]), async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      
      const reminderData = z.object({
        type: z.enum(["appointment_reminder", "medication_reminder", "follow_up_reminder", "emergency_alert", "preventive_care", "billing_notice", "health_check"]).default("appointment_reminder"),
        message: z.string().optional(),
        method: z.enum(["email", "sms", "whatsapp", "phone", "system"]).default("system"),
        scheduledFor: z.string().nullable().optional(),
        timezone: z.string().optional()
      }).parse(req.body);

      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      console.log(`üîî Processing ${reminderData.type} for patient ${patient.firstName} ${patient.lastName}`);
      console.log(`üì± Method received: "${reminderData.method}" (type: ${typeof reminderData.method})`);
      console.log(`üìù Message: ${reminderData.message || 'Default reminder message'}`);
      console.log(`üìû Is phone method: ${reminderData.method === 'phone'} | Is sms: ${reminderData.method === 'sms'}`);

      const messageText = reminderData.message || `Hi ${patient.firstName}, this is a reminder from your healthcare provider.`;
      const now = new Date();
      
      // Check if this is a scheduled message (scheduledFor is in the future)
      const isScheduled = reminderData.scheduledFor && new Date(reminderData.scheduledFor) > now;
      
      let messageSent = false;
      let messageResult = null;
      let status = 'pending';
      
      if (isScheduled) {
        // Schedule for future - don't send now
        status = 'scheduled';
        console.log(`üìÖ Message scheduled for: ${reminderData.scheduledFor} (${reminderData.timezone || 'UTC'})`);
      } else {
        // Send immediately
        if ((reminderData.method === 'sms' || reminderData.method === 'whatsapp') && patient.phone) {
          try {
            messageResult = await messagingService.sendMessage({
              to: patient.phone,
              message: messageText,
              type: reminderData.method as 'sms' | 'whatsapp'
            });
            
            if (messageResult.success) {
              messageSent = true;
              status = 'sent';
              console.log(`‚úÖ ${reminderData.method.toUpperCase()} successfully sent to ${patient.phone}`);
            } else {
              status = 'failed';
              console.error(`‚ùå Failed to send ${reminderData.method.toUpperCase()}: ${messageResult.error}`);
            }
          } catch (error) {
            status = 'failed';
            console.error(`‚ùå Error sending ${reminderData.method.toUpperCase()} to ${patient.phone}:`, error);
          }
        } else if (reminderData.method === 'phone' && patient.phone) {
          // Voice call via Twilio TTS
          try {
            messageResult = await messagingService.makeVoiceCall(patient.phone, messageText);
            
            if (messageResult.success) {
              messageSent = true;
              status = 'sent';
              console.log(`‚úÖ VOICE CALL successfully initiated to ${patient.phone}`);
            } else {
              status = 'failed';
              console.error(`‚ùå Failed to make VOICE CALL: ${messageResult.error}`);
            }
          } catch (error) {
            status = 'failed';
            console.error(`‚ùå Error making VOICE CALL to ${patient.phone}:`, error);
          }
        } else if (reminderData.method === 'email' && patient.email) {
          try {
            const emailResult = await emailService.sendGeneralReminder(
              patient.email,
              `${patient.firstName} ${patient.lastName}`,
              reminderData.type,
              messageText
            );
            
            if (emailResult) {
              messageSent = true;
              status = 'sent';
              console.log(`‚úÖ EMAIL successfully sent to ${patient.email}`);
            } else {
              status = 'failed';
              console.error(`‚ùå Failed to send EMAIL to ${patient.email}`);
            }
          } catch (error) {
            status = 'failed';
            console.error(`‚ùå Error sending EMAIL to ${patient.email}:`, error);
          }
        }
      }

      // Save communication to database
      const communicationData = {
        organizationId: req.tenant!.id,
        patientId,
        sentBy: req.user!.id,
        type: reminderData.type,
        method: reminderData.method,
        status,
        message: messageText,
        scheduledFor: isScheduled && reminderData.scheduledFor ? new Date(reminderData.scheduledFor) : null,
        sentAt: messageSent ? now : null,
        createdAt: now,
        errorMessage: status === 'failed' ? (messageResult?.error || 'Failed to send') : null,
        metadata: {
          reminderType: reminderData.type,
          messageSent,
          timezone: reminderData.timezone || null,
          provider: reminderData.method === 'sms' || reminderData.method === 'whatsapp' ? 'Twilio' : reminderData.method === 'email' ? 'SendGrid' : 'System'
        }
      };

      const savedCommunication = await storage.createPatientCommunication(communicationData);

      let responseMessage = '';
      if (isScheduled) {
        responseMessage = `${reminderData.method.toUpperCase()} reminder scheduled for ${patient.firstName} ${patient.lastName} at ${new Date(reminderData.scheduledFor!).toLocaleString()}`;
      } else if (messageSent) {
        responseMessage = `${reminderData.method.toUpperCase()} reminder successfully sent to ${patient.firstName} ${patient.lastName}`;
      } else {
        responseMessage = `Reminder logged for ${patient.firstName} ${patient.lastName} (${reminderData.method === 'email' && !patient.email ? 'No email address available' : !patient.phone ? 'No phone number available' : 'System notification only'})`;
      }

      res.json({ 
        success: true, 
        message: responseMessage,
        patientId,
        reminderType: reminderData.type,
        messageSent,
        isScheduled,
        scheduledFor: isScheduled ? reminderData.scheduledFor : null,
        messageDetails: messageResult,
        communicationId: savedCommunication.id
      });
    } catch (error) {
      console.error("Send reminder error:", error);
      res.status(500).json({ error: "Failed to send reminder" });
    }
  });

  // Patient flag endpoint
  app.post("/api/patients/:id/flags", requireRole(["doctor", "nurse", "receptionist", "admin"]), async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      
      const flagData = z.object({
        type: z.enum([
          "medical_alert", "allergy_warning", "medication_interaction", 
          "high_risk", "special_needs", "insurance_issue", 
          "payment_overdue", "follow_up_required"
        ]).optional(),
        flagType: z.enum(["urgent", "follow-up", "billing", "general"]).optional(),
        reason: z.string().min(1),
        severity: z.enum(["low", "medium", "high", "critical"]).optional(),
        priority: z.enum(["low", "medium", "high", "urgent"]).optional()
      }).parse(req.body);

      // Use the new type field if provided, otherwise fall back to flagType
      const finalFlagType = flagData.type || flagData.flagType || "general";
      const finalPriority = flagData.severity || flagData.priority || "medium";

      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Create the flag string with type and priority
      const flagString = `${finalFlagType}:${finalPriority}:${flagData.reason}`;
      
      // Get current flags array and add the new flag
      const currentFlags = patient.flags || [];
      if (!currentFlags.includes(flagString)) {
        currentFlags.push(flagString);
        
        // Update patient with new flag and risk level based on flag severity
        await storage.updatePatient(patientId, req.tenant!.id, {
          flags: currentFlags,
          riskLevel: finalPriority // Update risk level to match flag severity
        });
      }

      // Fetch updated patient to return current state
      const updatedPatient = await storage.getPatient(patientId, req.tenant!.id);

      res.json({ 
        success: true, 
        message: `${finalFlagType} flag (${finalPriority} priority) added to ${patient.firstName} ${patient.lastName}`,
        patientId,
        flagType: finalFlagType,
        priority: finalPriority,
        reason: flagData.reason,
        totalFlags: updatedPatient?.flags?.length || 0,
        flags: updatedPatient?.flags || []
      });
    } catch (error) {
      console.error("Patient flag error:", error);
      res.status(500).json({ error: "Failed to create patient flag" });
    }
  });

  // Delete patient flag endpoint
  app.delete("/api/patients/:id/flags/:flagIndex", requireRole(["doctor", "nurse", "receptionist", "admin"]), async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const flagIndex = parseInt(req.params.flagIndex);
      
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      const currentFlags = patient.flags || [];
      if (flagIndex < 0 || flagIndex >= currentFlags.length) {
        return res.status(400).json({ error: "Invalid flag index" });
      }

      // Remove the flag at the specified index
      const updatedFlags = currentFlags.filter((_, index) => index !== flagIndex);
      
      // Update patient with new flags array
      await storage.updatePatient(patientId, req.tenant!.id, {
        flags: updatedFlags
      });

      // Fetch updated patient to return current state
      const updatedPatient = await storage.getPatient(patientId, req.tenant!.id);

      res.json({ 
        success: true, 
        message: `Flag removed from ${patient.firstName} ${patient.lastName}`,
        patientId,
        totalFlags: updatedPatient?.flags?.length || 0,
        flags: updatedPatient?.flags || []
      });
    } catch (error) {
      console.error("Delete flag error:", error);
      res.status(500).json({ error: "Failed to delete flag" });
    }
  });

  // Get patient communications
  app.get("/api/patients/:id/communications", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      const communications = await storage.getPatientCommunications(patientId, req.tenant!.id);
      res.json(communications);
    } catch (error) {
      console.error('Error fetching patient communications:', error);
      res.status(500).json({ error: 'Failed to fetch communications' });
    }
  });

  // Appointments routes - Enhanced with role-based access control
  app.get("/api/appointments", authMiddleware, requireRole(["admin", "doctor", "nurse", "patient"]), async (req: TenantRequest, res) => {
    try {
      const { start, end, doctorId, patientId, providerId, date } = req.query;
      const userRole = req.user!.role;
      const userId = req.user!.id;
      
      let appointments: Appointment[] = [];
      
      // Special case: Slot availability checking (providerId + date)
      // Allow ALL users to check slot availability for booking purposes
      if (providerId && date) {
        appointments = await storage.getAppointmentsByProvider(
          parseInt(providerId as string), 
          req.tenant!.id
        );
        
        // Filter by date
        const dateStr = date as string;
        appointments = appointments.filter(apt => {
          const aptDate = apt.scheduledAt instanceof Date 
            ? apt.scheduledAt.toISOString().substring(0, 10)
            : apt.scheduledAt.substring(0, 10);
          return aptDate === dateStr;
        });
        
        // Return minimal data for availability checking (no sensitive patient info)
        const availabilityData = appointments.map(apt => ({
          id: apt.id,
          providerId: apt.providerId,
          scheduledAt: apt.scheduledAt,
          duration: apt.duration,
          status: apt.status
        }));
        
        return res.json(availabilityData);
      }
      
      // Role-based access control as per architect specifications
      if (userRole === 'admin' || userRole === 'receptionist') {
        // Admin/receptionist can see all appointments with optional filters
        if (doctorId) {
          appointments = await storage.getAppointmentsByProvider(
            parseInt(doctorId as string), 
            req.tenant!.id
          );
        } else if (patientId) {
          appointments = await storage.getAppointmentsByPatient(
            parseInt(patientId as string), 
            req.tenant!.id
          );
        } else {
          // Get all appointments for organization
          appointments = await storage.getAppointmentsByOrganization(req.tenant!.id);
        }
      } else if (userRole === 'doctor') {
        // Doctors can only see their own appointments unless they have read_all permission
        const user = req.user! as any;
        const hasReadAllPermission = user.permissions?.modules?.appointments?.view === true;
        
        if (hasReadAllPermission && doctorId) {
          // Doctor with read_all permission can see other doctors' appointments
          appointments = await storage.getAppointmentsByProvider(
            parseInt(doctorId as string), 
            req.tenant!.id
          );
        } else {
          // Restrict to doctor's own appointments
          appointments = await storage.getAppointmentsByProvider(userId, req.tenant!.id);
        }
      } else if (userRole === 'patient') {
        // Patients can only see their own appointments
        // Find the patient record by email (since userId may be null)
        const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
        const user = req.user! as any; // Cast to access firstName/lastName properties
        
        // Match by email first (primary method), fallback to userId
        const patient = patients.find(p => p.email === user.email) || patients.find(p => p.userId === userId);
        
        if (patient) {
          appointments = await storage.getAppointmentsByPatient(patient.id, req.tenant!.id);
        } else {
          appointments = [];
        }
      } else if (userRole === 'nurse') {
        // Nurses can see all appointments for now - can be restricted further if needed
        appointments = await storage.getAppointmentsByOrganization(req.tenant!.id);
      } else {
        // Default: no access for other roles
        return res.status(403).json({ error: "Access denied" });
      }
      
      // Apply date range filters if provided
      if (start || end) {
        const startDate = start ? new Date(start as string) : new Date(0);
        const endDate = end ? new Date(end as string) : new Date('2099-12-31');
        
        appointments = appointments.filter(apt => {
          const aptDate = new Date(apt.scheduledAt);
          return aptDate >= startDate && aptDate <= endDate;
        });
      }
      
      res.json(appointments);
    } catch (error) {
      console.error("Appointments fetch error:", error);
      res.status(500).json({ error: "Failed to fetch appointments" });
    }
  });

  // Update appointment
  app.put("/api/appointments/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const appointmentId = parseInt(req.params.id);
      const userRole = req.user!.role;
      const userId = req.user!.id;

      // Verify the appointment exists and user has permission to edit it
      const existingAppointment = await storage.getAppointment(appointmentId, req.tenant!.id);
      if (!existingAppointment) {
        return res.status(404).json({ error: "Appointment not found" });
      }

      // Role-based access control for updating appointments
      let canUpdate = false;
      
      if (userRole === 'admin' || userRole === 'receptionist') {
        // Admin/receptionist can update any appointment
        canUpdate = true;
      } else if (userRole === 'doctor') {
        // Doctors can only update their own appointments or with proper permissions
        const hasEditPermission = (req.user as any)?.permissions?.modules?.appointments?.edit === true;
        canUpdate = existingAppointment.providerId === userId || hasEditPermission;
      } else if (userRole === 'patient') {
        // Patients can update their own appointments
        // Find the patient record by email first (primary), fallback to userId
        const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
        const patient = patients.find(p => p.email === req.user!.email) || patients.find(p => p.userId === userId);
        canUpdate = Boolean(patient && existingAppointment.patientId === patient.id);
      } else if (userRole === 'nurse') {
        // Nurses can update appointments with proper permissions
        const hasEditPermission = (req.user as any)?.permissions?.modules?.appointments?.edit === true;
        canUpdate = hasEditPermission;
      }

      if (!canUpdate) {
        return res.status(403).json({ error: "Access denied - cannot update this appointment" });
      }

      // Prepare update data (only allow updating certain fields)
      const allowedUpdates: any = {};
      const { title, description, scheduledAt, duration, status, type, location, isVirtual } = req.body;
      
      if (title !== undefined) allowedUpdates.title = title;
      if (description !== undefined) allowedUpdates.description = description;
      if (scheduledAt !== undefined) {
        // Store scheduledAt string directly without timezone conversion
        allowedUpdates.scheduledAt = scheduledAt;
      }
      if (duration !== undefined) allowedUpdates.duration = duration;
      if (status !== undefined) allowedUpdates.status = status;
      if (type !== undefined) allowedUpdates.type = type;
      if (location !== undefined) allowedUpdates.location = location;
      if (isVirtual !== undefined) allowedUpdates.isVirtual = isVirtual;

      // Update the appointment
      const updatedAppointment = await storage.updateAppointment(
        appointmentId,
        req.tenant!.id,
        allowedUpdates
      );

      if (updatedAppointment) {
        console.log(`‚úÖ Appointment ${appointmentId} updated successfully by user ${userId} (${userRole})`);
        
        // Broadcast update to all connected clients
        if (global.appointmentClients) {
          const updateMessage = JSON.stringify({
            type: 'appointment_updated',
            appointment: updatedAppointment,
            timestamp: Date.now()
          });
          
          global.appointmentClients.forEach((client) => {
            if (client.organizationId === req.tenant!.id) {
              try {
                client.res.write(`data: ${updateMessage}\n\n`);
              } catch (error: any) {
                console.log(`[SSE] Failed to send update to client:`, error.message);
              }
            }
          });
        }
        
        res.json(updatedAppointment);
      } else {
        res.status(400).json({ error: "Failed to update appointment" });
      }
    } catch (error) {
      console.error("Appointment update error:", error);
      res.status(500).json({ error: "Failed to update appointment. Please try again." });
    }
  });

  // Real-time appointment updates via Server-Sent Events
  app.get("/api/appointments/stream", authMiddleware, async (req: TenantRequest, res) => {
    console.log(`[SSE] New appointment stream connection for org ${req.tenant!.id}, user ${req.user!.id}`);
    
    // Set up SSE headers
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Authorization, Content-Type',
    });

    const organizationId = req.tenant!.id;
    const userId = req.user!.id;
    const clientId = `${organizationId}-${userId}-${Date.now()}`;
    
    // Store client connection for broadcasting
    if (!global.appointmentClients) {
      global.appointmentClients = new Map();
    }
    global.appointmentClients.set(clientId, { res, organizationId, userId });

    // Send initial connection confirmation
    res.write(`data: ${JSON.stringify({ type: 'connected', clientId })}\n\n`);

    // Ping to keep connection alive
    const pingInterval = setInterval(() => {
      res.write(`data: ${JSON.stringify({ type: 'ping', timestamp: Date.now() })}\n\n`);
    }, 30000);

    // Handle client disconnect
    req.on('close', () => {
      console.log(`[SSE] Client ${clientId} disconnected`);
      clearInterval(pingInterval);
      global.appointmentClients?.delete(clientId);
    });

    req.on('error', () => {
      console.log(`[SSE] Client ${clientId} error`);
      clearInterval(pingInterval);
      global.appointmentClients?.delete(clientId);
    });
  });

  // Broadcast appointment events to all connected clients in the same organization
  const broadcastAppointmentEvent = (organizationId: number, eventType: string, data: any) => {
    if (!global.appointmentClients) return;
    
    const eventData = {
      type: eventType,
      data,
      timestamp: Date.now(),
      organizationId
    };

    console.log(`[SSE] Broadcasting ${eventType} to org ${organizationId}`);
    
    for (const [clientId, client] of global.appointmentClients.entries()) {
      if (client.organizationId === organizationId) {
        try {
          client.res.write(`data: ${JSON.stringify(eventData)}\n\n`);
        } catch (error) {
          console.error(`[SSE] Error broadcasting to client ${clientId}:`, error);
          global.appointmentClients.delete(clientId);
        }
      }
    }
  };

  // Check appointment conflicts before creation
  app.post("/api/appointments/check-conflicts", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { patientId, providerId, scheduledAt } = req.body;
      const organizationId = req.tenant!.id;
      
      if (!patientId || !providerId || !scheduledAt) {
        return res.status(400).json({ error: "patientId, providerId, and scheduledAt are required" });
      }
      
      // Parse the date/time directly from ISO string WITHOUT timezone conversion
      // scheduledAt format: "2025-12-12T12:45:00"
      const dateStr = scheduledAt.substring(0, 10); // "2025-12-12"
      const timeStr = scheduledAt.substring(11, 16); // "12:45"
      
      console.log(`[CONFLICT CHECK] Checking for conflicts: patientId=${patientId}, providerId=${providerId}, date=${dateStr}, time=${timeStr}`);
      
      // Check for patient conflicts (patient has appointment at same date/time with any doctor)
      const patientConflicts = await db.select()
        .from(schema.appointments)
        .where(and(
          eq(schema.appointments.organizationId, organizationId),
          eq(schema.appointments.patientId, patientId),
          sql`DATE(${schema.appointments.scheduledAt}) = ${dateStr}`,
          sql`TO_CHAR(${schema.appointments.scheduledAt}, 'HH24:MI') = ${timeStr}`,
          ne(schema.appointments.status, 'cancelled')
        ));
      
      // Check for provider conflicts (doctor has appointment at same date/time with any patient)
      const providerConflicts = await db.select()
        .from(schema.appointments)
        .where(and(
          eq(schema.appointments.organizationId, organizationId),
          eq(schema.appointments.providerId, providerId),
          sql`DATE(${schema.appointments.scheduledAt}) = ${dateStr}`,
          sql`TO_CHAR(${schema.appointments.scheduledAt}, 'HH24:MI') = ${timeStr}`,
          ne(schema.appointments.status, 'cancelled')
        ));
      
      console.log(`[CONFLICT CHECK] Found ${patientConflicts.length} patient conflicts, ${providerConflicts.length} provider conflicts`);
      
      res.json({
        hasConflict: patientConflicts.length > 0 || providerConflicts.length > 0,
        patientConflict: patientConflicts,
        providerConflict: providerConflicts
      });
    } catch (error) {
      console.error("Error checking appointment conflicts:", error);
      res.status(500).json({ error: "Failed to check conflicts" });
    }
  });

  app.post("/api/appointments", authMiddleware, async (req: TenantRequest, res, next) => {
    // Special case: Allow patients to book their own appointments
    if (req.user?.role === 'patient') {
      console.log('[APPOINTMENTS] Patient booking allowed - bypassing module permission check');
      return next();
    }
    // For all other roles, check module permission
    return requireModulePermission('appointments', 'create')(req, res, next);
  }, async (req: TenantRequest, res) => {
    try {
      console.log("Appointment creation request received:", req.body);
      console.log("Tenant ID:", req.tenant?.id);
      
      const normalizedBody = {
        ...req.body,
        appointmentType: req.body.appointmentType ?? req.body.appointment_type,
        treatmentId: req.body.treatmentId ?? req.body.treatment_id ?? null,
        consultationId: req.body.consultationId ?? req.body.consultation_id ?? null,
      };

      const appointmentData = z.object({
        patientId: z.any().transform((val) => {
          // Handle null, undefined, empty string, or NaN
          if (val === null || val === undefined || val === "" || (typeof val === "number" && isNaN(val))) {
            return null;
          }
          return val;
        }),
        providerId: z.number(),
        assignedRole: z.string().optional(),
        title: z.string().optional(),
        description: z.string().optional(),
        appointmentDate: z.string().optional(),
        scheduledAt: z.string().optional(),
        duration: z.number().default(30),
        type: z.enum(["consultation", "follow_up", "procedure"]).default("consultation"),
        appointmentType: z.enum(["consultation", "treatment"]).default("consultation"),
        treatmentId: z.number().int().optional().nullable(),
        consultationId: z.number().int().optional().nullable(),
        location: z.string().optional(),
        department: z.string().optional(),
        notes: z.string().optional(),
        status: z.string().optional(),
        isVirtual: z.boolean().default(false),
        createdBy: z.number().optional()
      }).parse(normalizedBody);

      console.log("Parsed appointment data:", appointmentData);

      // Handle patientId conversion
      let numericPatientId: number;
      if (appointmentData.patientId === null) {
        console.log("Patient ID is null, returning error");
        return res.status(400).json({ error: "Patient ID is required" });
      } else if (typeof appointmentData.patientId === "string") {
        // If it's a string (like "P000007"), find the patient by patientId
        console.log("Looking up patient by patientId:", appointmentData.patientId);
        let patient = await storage.getPatientByPatientId(appointmentData.patientId, req.tenant!.id);
        
        // If not found, try different formatting patterns
        if (!patient && appointmentData.patientId.startsWith("P")) {
          // Extract the numeric part and try different formats
          const numericPart = appointmentData.patientId.substring(1);
          const numericValue = parseInt(numericPart, 10);
          
          if (!isNaN(numericValue)) {
            // Try with 6-digit padding: P000007
            const paddedId = `P${numericValue.toString().padStart(6, '0')}`;
            console.log("Trying padded patientId:", paddedId);
            patient = await storage.getPatientByPatientId(paddedId, req.tenant!.id);
            
            // If still not found, try with 3-digit padding: P007
            if (!patient) {
              const shortPaddedId = `P${numericValue.toString().padStart(3, '0')}`;
              console.log("Trying short padded patientId:", shortPaddedId);
              patient = await storage.getPatientByPatientId(shortPaddedId, req.tenant!.id);
            }
            
            // If still not found, try without padding: P7
            if (!patient) {
              const noPaddingId = `P${numericValue}`;
              console.log("Trying no padding patientId:", noPaddingId);
              patient = await storage.getPatientByPatientId(noPaddingId, req.tenant!.id);
            }
          }
        }
        
        if (!patient) {
          console.log("Patient not found for patientId:", appointmentData.patientId);
          return res.status(400).json({ 
            error: `Patient not found. Please use a valid patient ID like P000001, P000002, P000004, P000005, P000007, P000008, P000009, P000010, or P000158.` 
          });
        }
        numericPatientId = patient.id;
        console.log("Found patient with numeric ID:", numericPatientId);
      } else {
        numericPatientId = appointmentData.patientId;
        console.log("Using provided numeric patient ID:", numericPatientId);
      }

      // Generate unique appointment ID
      const appointmentId = `APT${Date.now()}P${numericPatientId}AUTO`;

      const appointmentTypeValue = appointmentData.appointmentType || "consultation";
      const appointmentToCreate = {
        patientId: numericPatientId,
        providerId: appointmentData.providerId,
        assignedRole: appointmentData.assignedRole || null,
        organizationId: req.tenant!.id,
        appointmentId: appointmentId, // Add auto-generated appointment ID
        title: appointmentData.title || `${appointmentData.type} appointment`,
        description: appointmentData.description || appointmentData.notes || "",
        scheduledAt: appointmentData.scheduledAt || appointmentData.appointmentDate,
        duration: appointmentData.duration,
        type: appointmentData.type,
        status: appointmentData.status || "scheduled", // Add missing status field
        location: appointmentData.location || "",
        isVirtual: appointmentData.isVirtual,
        createdBy: appointmentData.createdBy || null,
        appointmentType: appointmentTypeValue,
        treatmentId: appointmentTypeValue === "treatment" ? appointmentData.treatmentId || null : null,
        consultationId: appointmentTypeValue === "consultation" ? appointmentData.consultationId || null : null,
      };

      // Note: Removed past time validation since we're using naive timestamps
      
      console.log("Creating appointment with final data:", appointmentToCreate);
      
      const appointment = await storage.createAppointment(appointmentToCreate);
      
      // Get patient and provider details for notifications
      const patient = await storage.getPatient(numericPatientId, req.tenant!.id);
      const provider = await storage.getUser(appointmentData.providerId, req.tenant!.id);
      
      // Create notifications for appointment creation
      if (patient && provider) {
        const appointmentDate = new Date(appointmentToCreate.scheduledAt!);
        const formattedDate = appointmentDate.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
        const formattedTime = appointmentDate.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
        
        const notificationsToCreate = [];
        
        // Notify patient
        if (patient.userId) {
          notificationsToCreate.push({
            organizationId: req.tenant!.id,
            userId: patient.userId,
            title: "Appointment Confirmed",
            message: `Your appointment with Dr. ${provider.firstName} ${provider.lastName} is scheduled for ${formattedDate} at ${formattedTime}.`,
            type: "appointment_reminder" as const,
            priority: "normal" as const,
            actionUrl: `/calendar`,
            metadata: {
              patientId: patient.id,
              patientName: `${patient.firstName} ${patient.lastName}`,
              appointmentId: appointment.id,
              department: appointmentData.department || "General",
            }
          });
        }
        
        // Notify provider
        notificationsToCreate.push({
          organizationId: req.tenant!.id,
          userId: appointmentData.providerId,
          title: "New Appointment Scheduled",
          message: `New appointment with ${patient.firstName} ${patient.lastName} scheduled for ${formattedDate} at ${formattedTime}.`,
          type: "appointment_reminder" as const,
          priority: "normal" as const,
          actionUrl: `/calendar`,
          metadata: {
            patientId: patient.id,
            patientName: `${patient.firstName} ${patient.lastName}`,
            appointmentId: appointment.id,
            department: appointmentData.department || "General",
          }
        });
        
        await createBulkNotifications(notificationsToCreate);
      }
      
      // Broadcast appointment creation to all connected clients in the same organization
      broadcastAppointmentEvent(req.tenant!.id, 'appointment.created', appointment);
      
      console.log("Appointment creation completed, returning:", appointment);
      res.status(201).json(appointment);
    } catch (error) {
      console.error("Appointment creation error:", error);
      
      // Handle scheduling conflicts specifically
      if (error instanceof Error && error.message.includes("already scheduled at this time")) {
        return res.status(400).json({ 
          error: error.message
        });
      }
      
      // Provide specific error message for validation failures
      const errorMessage = error instanceof Error ? error.message : "Failed to create appointment";
      
      // Always provide detailed error message for appointment failures
      res.status(400).json({ 
        error: errorMessage,
        type: "appointment_validation_error",
        timestamp: new Date().toISOString()
      });
    }
  });

  // Create appointment with invoice (for patient booking flow)
  app.post("/api/appointments-with-invoice", requireRole(["doctor", "nurse", "receptionist", "admin", "patient"]), async (req: TenantRequest, res) => {
    try {
      console.log("Appointment with invoice creation request received:", req.body);
      
      const requestData = z.object({
        patientId: z.number(),
        providerId: z.number(),
        scheduledAt: z.string(),
        duration: z.number().default(30),
        type: z.string().default("consultation"),
        status: z.string().default("scheduled"),
        title: z.string().optional(),
        description: z.string().optional(),
        location: z.string().optional(),
        isVirtual: z.boolean().default(false),
        invoice: z.object({
          serviceDate: z.string(),
          invoiceDate: z.string(),
          dueDate: z.string(),
          serviceCode: z.string(),
          serviceDescription: z.string(),
          amount: z.string(),
          insuranceProvider: z.string().optional(),
          notes: z.string().optional(),
          paymentMethod: z.string().optional(),
          status: z.string().default("pending")
        })
      }).parse(req.body);

      // Get patient data for invoice
      const patient = await storage.getPatient(requestData.patientId, req.tenant!.id);
      if (!patient) {
        return res.status(400).json({ error: "Patient not found" });
      }

      // Generate unique appointment ID
      const appointmentId = `APT${Date.now()}P${requestData.patientId}AUTO`;

      // Create appointment - scheduledAt must be an ISO string for storage.ts
      const appointmentToCreate = {
        patientId: requestData.patientId,
        providerId: requestData.providerId,
        assignedRole: requestData.assignedRole || "doctor",
        organizationId: req.tenant!.id,
        appointmentId: appointmentId,
        title: requestData.title || `Appointment`,
        description: requestData.description || "",
        scheduledAt: requestData.scheduledAt, // Keep as ISO string - storage expects string
        duration: requestData.duration,
        type: requestData.type as "consultation" | "follow_up" | "procedure",
        status: requestData.status,
        location: requestData.location || "",
        isVirtual: requestData.isVirtual,
        createdBy: req.user?.id || null
      };

      const appointment = await storage.createAppointment(appointmentToCreate);
      console.log("Appointment created:", appointment);

      // Generate unique invoice number
      const invoiceNumber = `INV-${Date.now().toString().slice(-6)}`;

      // Create invoice with pending status
      const invoiceToCreate = {
        organizationId: req.tenant!.id,
        invoiceNumber: invoiceNumber,
        patientId: patient.patientId || `P${patient.id}`,
        patientName: `${patient.firstName} ${patient.lastName}`,
        nhsNumber: patient.nhsNumber || null,
        dateOfService: new Date(requestData.invoice.serviceDate),
        invoiceDate: new Date(requestData.invoice.invoiceDate),
        dueDate: new Date(requestData.invoice.dueDate),
        status: requestData.invoice.status || "pending",
        invoiceType: "payment",
        paymentMethod: requestData.invoice.paymentMethod || "Online Payment",
        subtotal: requestData.invoice.amount,
        tax: "0",
        discount: "0",
        totalAmount: requestData.invoice.amount,
        paidAmount: "0",
        items: [{
          code: requestData.invoice.serviceCode,
          description: requestData.invoice.serviceDescription,
          quantity: 1,
          unitPrice: parseFloat(requestData.invoice.amount),
          total: parseFloat(requestData.invoice.amount)
        }],
        insuranceProvider: requestData.invoice.insuranceProvider || null,
        notes: requestData.invoice.notes || null,
        serviceId: appointment.id.toString()
      };

      const newInvoice = await db
        .insert(schema.invoices)
        .values(invoiceToCreate)
        .returning();

      console.log("Invoice created:", newInvoice[0]);

      res.status(200).json({
        appointment: appointment,
        invoice: newInvoice[0]
      });
    } catch (error) {
      console.error("Appointment with invoice creation error:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to create appointment with invoice";
      res.status(400).json({ error: errorMessage });
    }
  });

  app.patch("/api/appointments/:id", authMiddleware, requireModulePermission('appointments', 'edit'), async (req: TenantRequest, res) => {
    try {
      const appointmentId = parseInt(req.params.id);
      
      if (isNaN(appointmentId)) {
        return res.status(400).json({ error: "Invalid appointment ID" });
      }

      const updateData = z.object({
        title: z.string().optional(),
        type: z.enum(["consultation", "follow_up", "procedure"]).optional(),
        status: z.enum(["scheduled", "completed", "cancelled", "no_show"]).optional(),
        scheduledAt: z.string().optional(),
        description: z.string().optional(),
        duration: z.number().optional(),
        location: z.string().optional(),
        isVirtual: z.boolean().optional(),
        appointmentType: z.enum(["consultation", "treatment"]).optional(),
        treatmentId: z.number().int().optional().nullable(),
        consultationId: z.number().int().optional().nullable()
      }).parse(req.body);

      console.log(`Updating appointment ${appointmentId} with data:`, updateData);

      // Convert scheduledAt string to Date object for database
      const updatePayload: any = { ...updateData };
      if (updateData.scheduledAt) {
        updatePayload.scheduledAt = new Date(updateData.scheduledAt);
      }

      const updated = await storage.updateAppointment(appointmentId, req.tenant!.id, updatePayload);
      
      if (!updated) {
        return res.status(404).json({ error: "Appointment not found" });
      }

      // Broadcast appointment update to all connected clients in the same organization
      broadcastAppointmentEvent(req.tenant!.id, 'appointment.updated', updated);

      console.log(`Appointment ${appointmentId} updated successfully`);
      res.json(updated);
    } catch (error) {
      console.error("Appointment update error:", error);
      handleRouteError(error, "Update appointment", res);
    }
  });

  app.delete("/api/appointments/:id", authMiddleware, requireModulePermission('appointments', 'delete'), async (req: TenantRequest, res) => {
    try {
      console.log(`üìû DELETE REQUEST - Appointment ID: ${req.params.id}, User: ${req.user?.email}, Tenant: ${req.tenant?.id}`);
      
      const appointmentId = parseInt(req.params.id);
      
      if (isNaN(appointmentId)) {
        console.log(`‚ùå Invalid appointment ID: ${req.params.id}`);
        return res.status(400).json({ error: "Invalid appointment ID" });
      }

      console.log(`üöÄ Calling deleteAppointment with ID: ${appointmentId}, OrgID: ${req.tenant!.id}`);
      const deleted = await storage.deleteAppointment(appointmentId, req.tenant!.id);
      console.log(`‚úÖ Deletion response: ${deleted}`);
      
      if (!deleted) {
        console.log(`‚ùå Appointment not found or not deleted`);
        return res.status(404).json({ error: "Appointment not found" });
      }

      // Broadcast appointment deletion to all connected clients in the same organization
      broadcastAppointmentEvent(req.tenant!.id, 'appointment.deleted', { id: appointmentId });

      console.log(`üéâ Appointment ${appointmentId} deleted successfully`);
      res.json({ success: true, message: "Appointment deleted successfully" });
    } catch (error) {
      console.error("‚ùå Appointment deletion error:", error);
      res.status(500).json({ error: "Failed to delete appointment" });
    }
  });

  // ============================================
  // DOCTORS FEE AND INVOICES ROUTES
  // ============================================

  // Get doctor's fee information
  app.get("/api/doctors-fee/:doctorId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const doctorId = parseInt(req.params.doctorId);
      
      if (isNaN(doctorId)) {
        return res.status(400).json({ error: "Invalid doctor ID" });
      }

      // Query the doctors_fee table for this doctor
      const doctorFees = await db
        .select()
        .from(schema.doctorsFee)
        .where(
          and(
            eq(schema.doctorsFee.organizationId, req.tenant!.id),
            eq(schema.doctorsFee.doctorId, doctorId)
          )
        )
        .limit(1);

      if (doctorFees.length === 0) {
        // Return default fee if no specific fee is configured
        return res.json({
          id: 0,
          doctorId: doctorId,
          serviceName: "General Consultation",
          basePrice: "50.00",
          currency: "GBP"
        });
      }

      res.json(doctorFees[0]);
    } catch (error) {
      console.error("Error fetching doctor's fee:", error);
      res.status(500).json({ error: "Failed to fetch doctor's fee" });
    }
  });

  // Check for duplicate doctor fee
  app.get("/api/pricing/doctors-fees/check-duplicate", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const doctorRole = req.query.doctorRole as string;
      const doctorId = parseInt(req.query.doctorId as string);
      
      if (!doctorRole || isNaN(doctorId)) {
        return res.status(400).json({ error: "Invalid parameters" });
      }

      // Query the doctors_fee table for this combination
      const existingFees = await db
        .select()
        .from(schema.doctorsFee)
        .where(
          and(
            eq(schema.doctorsFee.organizationId, req.tenant!.id),
            eq(schema.doctorsFee.doctorRole, doctorRole),
            eq(schema.doctorsFee.doctorId, doctorId)
          )
        )
        .limit(1);

      res.json({ exists: existingFees.length > 0 });
    } catch (error) {
      console.error("Error checking for duplicate doctor fee:", error);
      res.status(500).json({ error: "Failed to check for duplicate" });
    }
  });

  // Create invoice
  app.post("/api/invoices", authMiddleware, async (req: TenantRequest, res, next) => {
    // Special case: Allow patients to have invoices created for their own appointments
    if (req.user?.role === 'patient') {
      console.log('[INVOICES] Patient booking flow - bypassing billing permission check');
      return next();
    }
    // For all other roles, check module permission
    return requireModulePermission('billing', 'create')(req, res, next);
  }, async (req: TenantRequest, res) => {
    try {
      const invoiceData = z.object({
        patientId: z.string(),
        patientName: z.string(),
        nhsNumber: z.string().optional(),
        dateOfService: z.string(),
        invoiceDate: z.string(),
        dueDate: z.string(),
        status: z.string().default("draft"),
        invoiceType: z.string().default("payment"),
        paymentMethod: z.string().optional(),
        subtotal: z.string(),
        tax: z.string().default("0"),
        discount: z.string().default("0"),
        totalAmount: z.string(),
        paidAmount: z.string().default("0"),
        items: z.array(z.object({
          code: z.string(),
          description: z.string(),
          quantity: z.number(),
          unitPrice: z.number(),
          total: z.number()
        })),
        insuranceProvider: z.string().optional(),
        notes: z.string().optional(),
        serviceId: z.string().optional()
      }).parse(req.body);

      // Generate unique invoice number
      const invoiceNumber = `INV-${Date.now()}-${Math.random().toString(36).substring(2, 9).toUpperCase()}`;

      const newInvoice = await db
        .insert(schema.invoices)
        .values({
          organizationId: req.tenant!.id,
          invoiceNumber: invoiceNumber,
          patientId: invoiceData.patientId,
          patientName: invoiceData.patientName,
          nhsNumber: invoiceData.nhsNumber || null,
          dateOfService: new Date(invoiceData.dateOfService),
          invoiceDate: new Date(invoiceData.invoiceDate),
          dueDate: new Date(invoiceData.dueDate),
          status: invoiceData.status,
          invoiceType: invoiceData.invoiceType,
          paymentMethod: invoiceData.paymentMethod || null,
          subtotal: invoiceData.subtotal,
          tax: invoiceData.tax,
          discount: invoiceData.discount,
          totalAmount: invoiceData.totalAmount,
          paidAmount: invoiceData.paidAmount,
          items: invoiceData.items as any,
          insuranceProvider: invoiceData.insuranceProvider || null,
          notes: invoiceData.notes || null,
          serviceId: invoiceData.serviceId || null
        })
        .returning();

      console.log("Invoice created successfully:", newInvoice[0]);
      
      // Send payment due notification to patient
      const patient = await storage.getPatientByPatientId(invoiceData.patientId, req.tenant!.id);
      
      if (patient && patient.userId) {
        const dueDate = new Date(invoiceData.dueDate);
        const formattedDueDate = dueDate.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
        const isPastDue = dueDate < new Date();
        
        await createNotification({
          organizationId: req.tenant!.id,
          userId: patient.userId,
          title: isPastDue ? "Payment Overdue" : "Payment Due",
          message: `Invoice ${invoiceNumber} for ¬£${invoiceData.totalAmount} is ${isPastDue ? 'overdue' : `due by ${formattedDueDate}`}.`,
          type: "payment_due",
          priority: isPastDue ? "high" : "normal",
          actionUrl: `/billing`,
          metadata: {
            patientId: patient.id,
            patientName: invoiceData.patientName,
            department: "Billing",
          }
        });
      }
      
      res.status(201).json(newInvoice[0]);
    } catch (error) {
      console.error("Invoice creation error:", error);
      res.status(500).json({ error: "Failed to create invoice" });
    }
  });

  // ============================================
  // FINANCIAL INTELLIGENCE ROUTES
  // ============================================

  // Get revenue data
  app.get("/api/financial/revenue", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse", "patient"]), async (req: TenantRequest, res) => {
    try {
      const { dateRange } = req.query;
      
      // Mock revenue data - in production this would come from actual billing data
      const mockRevenueData = [
        { month: "Jan", revenue: 125000, expenses: 85000, profit: 40000, collections: 118000, target: 130000 },
        { month: "Feb", revenue: 135000, expenses: 88000, profit: 47000, collections: 128000, target: 130000 },
        { month: "Mar", revenue: 142000, expenses: 92000, profit: 50000, collections: 135000, target: 135000 },
        { month: "Apr", revenue: 138000, expenses: 90000, profit: 48000, collections: 132000, target: 135000 },
        { month: "May", revenue: 155000, expenses: 95000, profit: 60000, collections: 148000, target: 140000 },
        { month: "Jun", revenue: 162000, expenses: 98000, profit: 64000, collections: 156000, target: 145000 }
      ];
      
      res.json(mockRevenueData);
    } catch (error) {
      handleRouteError(error, "fetch revenue data", res);
    }
  });

  // Get claims data
  app.get("/api/financial/claims", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const claims = await storage.getClaimsByOrganization(organizationId);
      
      // Get all unique patient IDs to fetch patient names in one query
      const patientIds = [...new Set(claims.map(claim => claim.patientId))];
      const patients = await Promise.all(
        patientIds.map(id => storage.getPatient(id, organizationId))
      );
      
      // Create a map of patient ID to patient name
      const patientMap = new Map();
      patients.forEach(patient => {
        if (patient) {
          patientMap.set(patient.id, `${patient.firstName} ${patient.lastName}`);
        }
      });
      
      // Transform the claims data to match the expected frontend format
      const transformedClaims = claims.map(claim => ({
        id: claim.id.toString(),
        patientId: claim.patientId.toString(),
        patientName: patientMap.get(claim.patientId) || `Patient ${claim.patientId}`,
        claimNumber: claim.claimNumber,
        serviceDate: claim.serviceDate.toISOString().split('T')[0],
        submissionDate: claim.submissionDate.toISOString().split('T')[0],
        amount: parseFloat(claim.amount),
        status: claim.status,
        paymentAmount: claim.paymentAmount ? parseFloat(claim.paymentAmount) : undefined,
        paymentDate: claim.paymentDate?.toISOString().split('T')[0],
        denialReason: claim.denialReason,
        insuranceProvider: claim.insuranceProvider,
        procedures: claim.procedures || []
      }));
      
      res.json(transformedClaims);
    } catch (error) {
      handleRouteError(error, "fetch claims data", res);
    }
  });

  // Get revenue breakdown by service type (Custom Reports)
  app.get("/api/reports/revenue-breakdown", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const { dateRange, insuranceType, role, userName } = req.query;
      
      console.log("[REVENUE-BREAKDOWN] Fetching revenue breakdown with filters:", {
        organizationId,
        dateRange,
        insuranceType,
        role,
        userName
      });
      
      // Calculate date range
      const now = new Date();
      let startDate = new Date();
      let endDate = new Date();
      
      switch (dateRange) {
        case 'today':
          startDate.setHours(0, 0, 0, 0);
          endDate.setHours(23, 59, 59, 999);
          break;
        case 'this-week':
          startDate.setDate(now.getDate() - now.getDay());
          startDate.setHours(0, 0, 0, 0);
          break;
        case 'this-month':
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
          break;
        case 'last-month':
          startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
          endDate = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
          break;
        case 'this-quarter':
          const quarter = Math.floor(now.getMonth() / 3);
          startDate = new Date(now.getFullYear(), quarter * 3, 1);
          endDate = new Date(now.getFullYear(), (quarter + 1) * 3, 0, 23, 59, 59, 999);
          break;
        case 'this-year':
          startDate = new Date(now.getFullYear(), 0, 1);
          endDate = new Date(now.getFullYear(), 11, 31, 23, 59, 59, 999);
          break;
        default:
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
      }
      
      console.log("[REVENUE-BREAKDOWN] Date range:", { startDate, endDate });
      
      // Build query conditions
      const { invoices, patients, users } = await import("../shared/schema");
      let conditions: any[] = [
        eq(invoices.organizationId, organizationId),
        gte(invoices.dateOfService, startDate),
        lte(invoices.dateOfService, endDate)
      ];
      
      // Fetch invoices with filters - CRITICAL: Include organizationId in join to prevent tenant data leaks
      let query = db.select({
        invoice: invoices,
        patient: patients
      })
      .from(invoices)
      .leftJoin(patients, and(
        eq(invoices.patientId, patients.patientId),
        eq(patients.organizationId, organizationId)
      ))
      .where(and(...conditions));
      
      const results = await query;
      
      console.log("[REVENUE-BREAKDOWN] Total invoices found:", results.length);
      
      // Filter results based on role and userName
      let filteredResults = results;
      
      // Filter by insurance type
      if (insuranceType && insuranceType !== 'all') {
        filteredResults = filteredResults.filter(r => {
          const insProvider = r.invoice.insurance?.provider || r.patient?.insuranceInfo?.provider || 'Self-Pay';
          return insProvider === insuranceType;
        });
        console.log("[REVENUE-BREAKDOWN] After insurance filter:", filteredResults.length);
      }
      
      // Filter by role and userName
      if (role && role !== 'all') {
        if (role === 'patient' && userName && userName !== 'all') {
          // Filter by specific patient - FIXED: Compare against patient.userId instead of patient.id
          filteredResults = filteredResults.filter(r => {
            return r.patient && String(r.patient.userId) === userName;
          });
          console.log("[REVENUE-BREAKDOWN] After patient filter:", filteredResults.length);
        } else if (role !== 'patient' && userName && userName !== 'all') {
          // Filter by staff member who created the invoice
          filteredResults = filteredResults.filter(r => {
            return String(r.invoice.createdBy) === userName;
          });
          console.log("[REVENUE-BREAKDOWN] After staff filter:", filteredResults.length);
        }
      }
      
      // Aggregate revenue by service type
      const serviceTypeMap = new Map<string, {
        procedures: number;
        revenue: number;
        insurance: number;
        selfPay: number;
      }>();
      
      let totalRevenue = 0;
      let totalInsurance = 0;
      let totalSelfPay = 0;
      let totalProcedures = 0;
      
      filteredResults.forEach(({ invoice }) => {
        // NULL SAFETY: Guard against null or non-array items
        if (invoice.items && Array.isArray(invoice.items) && invoice.items.length > 0) {
          invoice.items.forEach((item: any) => {
            const serviceType = item.description || item.code || 'Uncategorized';
            const itemTotal = parseFloat(String(item.total || item.amount || 0));
            const isInsurance = invoice.insurance?.provider && invoice.insurance.provider !== 'Self-Pay';
            
            if (!serviceTypeMap.has(serviceType)) {
              serviceTypeMap.set(serviceType, {
                procedures: 0,
                revenue: 0,
                insurance: 0,
                selfPay: 0
              });
            }
            
            const entry = serviceTypeMap.get(serviceType)!;
            entry.procedures += 1;
            entry.revenue += itemTotal;
            
            if (isInsurance) {
              entry.insurance += itemTotal;
            } else {
              entry.selfPay += itemTotal;
            }
            
            totalRevenue += itemTotal;
            totalProcedures += 1;
            if (isInsurance) {
              totalInsurance += itemTotal;
            } else {
              totalSelfPay += itemTotal;
            }
          });
        }
      });
      
      // Convert map to array
      const breakdown = Array.from(serviceTypeMap.entries()).map(([serviceName, data]) => ({
        serviceName,
        procedures: data.procedures,
        revenue: data.revenue,
        insurance: data.insurance,
        selfPay: data.selfPay,
        collectionRate: data.revenue > 0 ? Math.round((data.revenue / data.revenue) * 100) : 0
      }));
      
      // Add total row
      breakdown.push({
        serviceName: 'Total',
        procedures: totalProcedures,
        revenue: totalRevenue,
        insurance: totalInsurance,
        selfPay: totalSelfPay,
        collectionRate: totalRevenue > 0 ? Math.round((totalRevenue / totalRevenue) * 100) : 0
      });
      
      // Get patient info if specific patient selected
      let patientInfo = null;
      if (role === 'patient' && userName && userName !== 'all') {
        const patientRecord = filteredResults[0]?.patient;
        if (patientRecord) {
          patientInfo = {
            name: `${patientRecord.firstName} ${patientRecord.lastName}`,
            patientId: patientRecord.patientId,
            insurance: patientRecord.insuranceInfo?.provider || 'Not specified',
            insuranceNumber: patientRecord.insuranceInfo?.policyNumber || 'N/A',
            phone: patientRecord.phone || 'N/A',
            email: patientRecord.email || 'N/A'
          };
        }
      }
      
      console.log("[REVENUE-BREAKDOWN] Breakdown summary:", {
        totalServices: breakdown.length - 1,
        totalRevenue,
        totalProcedures
      });
      
      res.json({
        breakdown,
        dateRange: { start: startDate, end: endDate },
        filters: { insuranceType, role, userName },
        patientInfo
      });
    } catch (error) {
      console.error("[REVENUE-BREAKDOWN] Error:", error);
      handleRouteError(error, "fetch revenue breakdown", res);
    }
  });

  // Submit new claim
  app.post("/api/financial/claims", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const claimData = z.object({
        patientName: z.string(),
        amount: z.number(),
        status: z.string().optional(),
        submittedAt: z.string().optional(),
        providerName: z.string().optional(),
        serviceDate: z.string(),
        procedures: z.array(z.object({
          code: z.string(),
          description: z.string(),
          amount: z.number()
        })).optional(),
        patientId: z.number().optional(),
        claimNumber: z.string().optional(),
        insuranceProvider: z.string().optional(),
        submissionDate: z.string().optional()
      }).parse(req.body);

      const organizationId = requireOrgId(req);
      
      // Create claim record for database
      const newClaimData = {
        organizationId: organizationId,
        patientId: claimData.patientId || 1, // Default to patient 1 if not provided
        claimNumber: claimData.claimNumber || `CLM-${new Date().getFullYear()}-${String(Date.now()).slice(-6)}`,
        serviceDate: new Date(claimData.serviceDate),
        submissionDate: new Date(),
        amount: claimData.amount.toString(),
        status: claimData.status || "pending",
        insuranceProvider: claimData.insuranceProvider || "Unknown Provider",
        procedures: claimData.procedures || []
      };

      // Save to database
      const savedClaim = await storage.createClaim(newClaimData);

      // Transform response to match frontend expectations
      const responseData = {
        id: savedClaim.id.toString(),
        patientId: savedClaim.patientId.toString(),
        patientName: claimData.patientName,
        claimNumber: savedClaim.claimNumber,
        serviceDate: savedClaim.serviceDate.toISOString().split('T')[0],
        submissionDate: savedClaim.submissionDate.toISOString().split('T')[0],
        amount: parseFloat(savedClaim.amount),
        status: savedClaim.status,
        insuranceProvider: savedClaim.insuranceProvider,
        procedures: savedClaim.procedures || []
      };

      res.status(201).json(responseData);
    } catch (error) {
      handleRouteError(error, "submit claim", res);
    }
  });

  // Update claim status
  app.patch("/api/financial/claims/:id", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const claimId = parseInt(req.params.id);
      const organizationId = requireOrgId(req);
      
      if (isNaN(claimId)) {
        return res.status(400).json({ error: "Invalid claim ID" });
      }

      // Validate status field
      const { status } = req.body;
      const validStatuses = ["pending", "submitted", "approved", "denied", "paid"];
      
      if (!status || !validStatuses.includes(status)) {
        return res.status(400).json({ 
          error: "Invalid status. Must be one of: " + validStatuses.join(", ") 
        });
      }

      // Check if claim exists and belongs to this organization
      const existingClaim = await storage.getClaimById(claimId);
      if (!existingClaim || existingClaim.organizationId !== organizationId) {
        return res.status(404).json({ error: "Claim not found" });
      }

      // Update the claim status
      const updatedClaim = await storage.updateClaim(claimId, organizationId, { status });
      
      res.json({ 
        success: true,
        message: "Claim status updated successfully",
        claim: updatedClaim
      });
    } catch (error) {
      handleRouteError(error, "update claim status", res);
    }
  });

  // Delete claim
  app.delete("/api/financial/claims/:id", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const claimId = parseInt(req.params.id);
      const organizationId = requireOrgId(req);
      
      if (isNaN(claimId)) {
        return res.status(400).json({ error: "Invalid claim ID" });
      }

      // Check if claim exists and belongs to this organization
      const existingClaim = await storage.getClaimById(claimId);
      if (!existingClaim || existingClaim.organizationId !== organizationId) {
        return res.status(404).json({ error: "Claim not found" });
      }

      // Delete the claim
      await storage.deleteClaim(claimId);
      
      res.json({ message: "Claim deleted successfully" });
    } catch (error) {
      handleRouteError(error, "delete claim", res);
    }
  });

  // Persistent insurance data for demo purposes (in production this would be in database)
  let mockInsurances: any[] = [
    // Records removed as requested - Sarah Johnson (ins_1) and Michael Chen (ins_2) deleted
  ];

  // Get insurance data
  app.get("/api/financial/insurance", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      console.log(`[FINANCIAL] Fetching insurance data for organization: ${organizationId}`);

      // First, get insurance verifications from the dedicated table
      const dbInsuranceVerifications = await storage.getInsuranceVerificationsByOrganization(organizationId);
      console.log(`[FINANCIAL] Found ${dbInsuranceVerifications.length} insurance verifications from database`);

      // Transform database insurance verifications to match frontend format
      const dbInsuranceData = dbInsuranceVerifications.map(insurance => ({
        id: insurance.id,
        patientName: insurance.patientName,
        provider: insurance.provider,
        policyNumber: insurance.policyNumber,
        groupNumber: insurance.groupNumber || 'N/A',
        memberNumber: insurance.memberNumber || 'N/A',
        planType: insurance.planType || 'Standard',
        effectiveDate: insurance.effectiveDate,
        expirationDate: insurance.expirationDate,
        copay: insurance.benefits?.copay || 0,
        deductible: insurance.benefits?.deductible || 0,
        isActive: insurance.status === 'active',
        eligibilityStatus: insurance.eligibilityStatus,
        lastVerified: insurance.lastVerified,
        coverageType: insurance.coverageType,
        status: insurance.status,
        coinsurance: `${insurance.benefits?.coinsurance || 20}%`,
        outOfPocketMax: `$${insurance.benefits?.outOfPocketMax || 5000}`,
        outOfPocketMet: `$${insurance.benefits?.outOfPocketMet || 0}`,
        deductibleMet: `$${insurance.benefits?.deductibleMet || 0}`,
        createdAt: insurance.createdAt,
      }));

      // Get all patients for this organization to check their insurance info (legacy support)
      const allPatients = await storage.getPatientsByOrganization(organizationId);
      console.log(`[FINANCIAL] Found ${allPatients.length} patients in organization ${organizationId}`);

      // Transform patients with insurance information
      const patientInsuranceVerifications = allPatients
        .filter(patient => {
          const insurance = patient.insuranceInfo as any;
          const hasInsurance = insurance && (insurance.provider || insurance.policyNumber);
          if (hasInsurance) {
            console.log(`[FINANCIAL] Patient ${patient.firstName} ${patient.lastName} has insurance: ${insurance.provider || 'Unknown'}`);
          }
          return hasInsurance;
        })
        .map(patient => {
          const insurance = patient.insuranceInfo as any;
          return {
            id: `ins_${patient.id}`,
            patientName: `${patient.firstName} ${patient.lastName}`,
            provider: insurance.provider || 'Unknown Provider',
            policyNumber: insurance.policyNumber || 'N/A',
            groupNumber: insurance.groupNumber || 'N/A',
            memberNumber: insurance.memberNumber || 'N/A',
            planType: insurance.planType || 'Standard',
            effectiveDate: insurance.effectiveDate || new Date().toISOString().split('T')[0],
            expirationDate: insurance.expirationDate || new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
            copay: insurance.copay || 0,
            deductible: insurance.deductible || 0,
            isActive: insurance.isActive !== false,
            eligibilityStatus: 'verified',
            lastVerified: new Date().toISOString(),
            coverageType: 'primary',
            status: 'active',
            coinsurance: '20%',
            outOfPocketMax: '$5000',
            outOfPocketMet: '$0',
            deductibleMet: '$0',
            createdAt: patient.createdAt,
          };
        });

      // Combine all insurance data sources: DB verifications + patient insurance + mock data
      const allInsuranceData = [...dbInsuranceData, ...patientInsuranceVerifications, ...mockInsurances];

      console.log(`[FINANCIAL] Total insurance verifications: ${allInsuranceData.length} (${dbInsuranceData.length} from DB, ${patientInsuranceVerifications.length} from patients, ${mockInsurances.length} manual)`);
      res.json(allInsuranceData);
    } catch (error) {
      console.error(`[FINANCIAL] Error fetching insurance data:`, error);
      handleRouteError(error, "fetch insurance data", res);
    }
  });

  // Get insurance verifications by patient ID
  app.get("/api/insurance-verifications", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const patientId = req.query.patientId;

      if (!patientId) {
        return res.status(400).json({ error: "Patient ID is required" });
      }

      console.log(`[FINANCIAL] Fetching insurance verifications for patient: ${patientId}`);

      const insuranceVerifications = await storage.getInsuranceVerificationsByPatient(parseInt(patientId as string), organizationId);

      console.log(`[FINANCIAL] Found ${insuranceVerifications.length} insurance verifications for patient ${patientId}`);
      res.json(insuranceVerifications);
    } catch (error) {
      console.error(`[FINANCIAL] Error fetching insurance verifications:`, error);
      handleRouteError(error, "fetch insurance verifications by patient", res);
    }
  });

  // Create new insurance record
  app.post("/api/financial/insurance", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const insuranceData = req.body;
      
      console.log(`[FINANCIAL] New insurance record creation requested:`, insuranceData);
      
      // Use provided patientId or find patient by name as fallback
      let patientId;
      if (insuranceData.patientId) {
        patientId = parseInt(insuranceData.patientId);
      } else {
        // Fallback: Find patient by name
        const patients = await storage.getPatientsByOrganization(organizationId);
        const patient = patients.find(p => `${p.firstName} ${p.lastName}` === insuranceData.patientName);
        
        if (!patient) {
          return res.status(400).json({
            success: false,
            message: "Patient not found"
          });
        }
        patientId = patient.id;
      }
      
      // Create insurance record for database
      const insuranceRecord = {
        organizationId,
        patientId: patientId,
        patientName: insuranceData.patientName,
        provider: insuranceData.provider,
        policyNumber: insuranceData.policyNumber,
        groupNumber: insuranceData.groupNumber,
        memberNumber: insuranceData.memberNumber,
        nhsNumber: insuranceData.nhsNumber,
        planType: insuranceData.planType,
        effectiveDate: insuranceData.effectiveDate,
        status: insuranceData.status || "active",
        coverageType: insuranceData.coverageType || "primary",
        eligibilityStatus: insuranceData.eligibilityStatus || "pending",
        lastVerified: insuranceData.lastVerified ? insuranceData.lastVerified : null,
        benefits: insuranceData.benefits || {
          deductible: 0,
          deductibleMet: 0,
          copay: 0,
          coinsurance: 0,
          outOfPocketMax: 0,
          outOfPocketMet: 0
        }
      };
      
      // Save to database
      const newInsurance = await storage.createInsuranceVerification(insuranceRecord);
      
      // Update patient's is_insured status to true
      await storage.updatePatientInsuranceStatus(patientId, organizationId, true);
      
      console.log(`[FINANCIAL] New insurance record created and patient insurance status updated:`, newInsurance);
      
      res.json({
        success: true,
        message: "Insurance record created successfully",
        insurance: newInsurance
      });
    } catch (error) {
      console.error(`[FINANCIAL] Insurance creation error:`, error);
      handleRouteError(error, "create insurance record", res);
    }
  });

  // Verify insurance eligibility - THE MISSING ENDPOINT
  app.post("/api/financial/insurance/:id/verify", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const insuranceId = req.params.id;
      
      console.log(`[FINANCIAL] Insurance verification requested for: ${insuranceId}`);
      
      // Simulate insurance verification process
      await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate API call delay
      
      // Mock verification response - in production this would call insurance provider APIs
      const verificationResult = {
        insuranceId,
        verified: true,
        eligibilityStatus: "verified",
        lastVerified: new Date().toISOString(),
        verificationDetails: {
          active: true,
          benefitsAvailable: true,
          copay: Math.floor(Math.random() * 50) + 10, // Random copay 10-59
          deductibleRemaining: Math.floor(Math.random() * 1000) + 100, // Random remaining 100-1099
          outOfNetworkCoverage: Math.random() > 0.5 // Random boolean
        },
        message: "Insurance eligibility verification completed successfully"
      };
      
      console.log(`[FINANCIAL] Verification completed for ${insuranceId}:`, verificationResult);
      
      res.json(verificationResult);
    } catch (error) {
      console.error(`[FINANCIAL] Insurance verification error:`, error);
      handleRouteError(error, "verify insurance eligibility", res);
    }
  });

  // Update insurance verification data
  app.put("/api/financial/insurance/:id", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const insuranceId = parseInt(req.params.id);
      const organizationId = requireOrgId(req);
      const updateData = req.body;
      
      console.log(`[FINANCIAL] Insurance update requested for: ${insuranceId}`, updateData);
      
      // Update the insurance record in the database
      const updatedInsurance = await storage.updateInsuranceVerification(insuranceId, organizationId, updateData);
      
      if (!updatedInsurance) {
        return res.status(404).json({
          success: false,
          message: "Insurance record not found"
        });
      }
      
      console.log(`[FINANCIAL] Insurance updated successfully:`, updatedInsurance);
      
      res.json({
        success: true,
        data: updatedInsurance,
        message: "Insurance verification data updated successfully"
      });
    } catch (error) {
      console.error(`[FINANCIAL] Insurance update error:`, error);
      handleRouteError(error, "update insurance verification data", res);
    }
  });

  // Delete insurance record
  app.delete("/api/financial/insurance/:id", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const insuranceId = parseInt(req.params.id);
      const organizationId = requireOrgId(req);
      
      console.log(`[FINANCIAL] Insurance deletion requested for: ${insuranceId}`);
      
      // Delete the insurance record from the database
      const deleted = await storage.deleteInsuranceVerification(insuranceId, organizationId);
      
      if (!deleted) {
        return res.status(404).json({
          success: false,
          message: "Insurance record not found"
        });
      }
      
      console.log(`[FINANCIAL] Insurance deleted successfully:`, insuranceId);
      
      res.json({
        success: true,
        message: "Insurance record deleted successfully",
        deletedId: insuranceId
      });
    } catch (error) {
      console.error(`[FINANCIAL] Insurance deletion error:`, error);
      handleRouteError(error, "delete insurance record", res);
    }
  });

  // PATCH insurance record - Update database records (inline field editing)
  app.patch("/api/financial/insurance/:id", authMiddleware, requireRole(["admin", "finance", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const insuranceId = parseInt(req.params.id);
      const organizationId = requireOrgId(req);
      const updateData = req.body;
      
      console.log(`[FINANCIAL] Insurance PATCH update requested for: ${insuranceId}`, updateData);
      
      // Update the insurance record in the database
      const updatedInsurance = await storage.updateInsuranceVerification(insuranceId, organizationId, updateData);
      
      if (!updatedInsurance) {
        return res.status(404).json({
          success: false,
          message: "Insurance record not found"
        });
      }
      
      console.log(`[FINANCIAL] Insurance PATCH updated successfully:`, updatedInsurance);
      
      res.json({
        success: true,
        data: updatedInsurance,
        message: "Insurance verification data updated successfully"
      });
    } catch (error) {
      console.error(`[FINANCIAL] Insurance PATCH update error:`, error);
      handleRouteError(error, "update insurance verification data", res);
    }
  });

  // Get financial forecasts
  app.get("/api/financial/forecasts", authMiddleware, requireRole(["admin", "finance"]), async (req: TenantRequest, res) => {
    try {
      // Mock forecast data - in production this would be calculated from historical data
      const mockForecasts = [
        {
          category: "Monthly Revenue",
          currentMonth: 162000,
          projectedNext: 168000,
          variance: 6000,
          trend: "up",
          confidence: 85,
          factors: ["Increased patient volume", "New insurance contracts", "Seasonal trend"]
        },
        {
          category: "Collection Rate",
          currentMonth: 94,
          projectedNext: 95,
          variance: 1,
          trend: "up",
          confidence: 78,
          factors: ["Improved prior authorization process", "Better claim submission timing"]
        },
        {
          category: "Operating Expenses",
          currentMonth: 98000,
          projectedNext: 102000,
          variance: 4000,
          trend: "up",
          confidence: 92,
          factors: ["Staff salary increases", "Equipment maintenance", "Inflation"]
        }
      ];
      
      res.json(mockForecasts);
    } catch (error) {
      handleRouteError(error, "fetch financial forecasts", res);
    }
  });

  // User management routes (admin only)
  // Medical staff endpoint for appointment booking - accessible to authenticated users
  app.get("/api/medical-staff", authMiddleware, requireRole(["admin", "doctor", "nurse", "patient"]), async (req: TenantRequest, res) => {
    try {
      console.log('üè• MEDICAL STAFF API: Fetching doctors from users table');
      console.log('üè¢ MEDICAL STAFF API: Organization ID from subdomain/tenant:', req.tenant!.id);
      console.log('üìã MEDICAL STAFF API: Tenant info:', { id: req.tenant!.id, name: req.tenant!.name, subdomain: req.tenant!.subdomain });
      
      // Get query parameters for specialty filtering
      const { specialty, subSpecialty } = req.query as { specialty?: string; subSpecialty?: string };
      
      console.log('üîç MEDICAL STAFF API: Querying users table where organizationId =', req.tenant!.id);
      const users = await storage.getUsersByOrganization(req.tenant!.id);
      console.log('üìä MEDICAL STAFF API: Found', users.length, 'total users in organization from users table');
      
      // Get today's date for shift checking
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const dayOfWeek = today.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase();
      
      // Get all staff shifts for today
      let todayShifts: any[] = [];
      try {
        todayShifts = await storage.getStaffShiftsByOrganization(req.tenant!.id, today.toISOString().split('T')[0]);
      } catch (error) {
        console.log("No staff shifts data available, using fallback logic");
        todayShifts = [];
      }
      
      // Get total doctor count
      const totalDoctors = users.filter(user => isDoctorLike(user.role) && user.isActive).length;
      
      console.log(`=== MEDICAL STAFF DEBUG ===`);
      console.log(`Total users: ${users.length}`);
      console.log(`Total doctors (where role='doctor' and isActive=true): ${totalDoctors}`);
      console.log(`üë®‚Äç‚öïÔ∏è MEDICAL STAFF API: Filtering users table where role = 'doctor'`);
      console.log(`Today shifts count: ${todayShifts.length}`);
      console.log(`Day of week: ${dayOfWeek}`);
      
      // Filter for all staff roles needed for shift management and appointments
      let medicalStaff = users
        .filter(user => ['doctor', 'nurse', 'sample_taker', 'lab_technician', 'admin', 'receptionist'].includes(user.role) && user.isActive);
      
      // Apply specialty filtering if provided
      if (specialty || subSpecialty) {
        console.log(`Filtering doctors - Specialty: "${specialty}", Sub-specialty: "${subSpecialty}"`);
        medicalStaff = medicalStaff.filter(user => {
          // Only filter doctors by specialty
          if (user.role !== 'doctor') return true;
          
          let matchesSpecialty = true;
          let matchesSubSpecialty = true;
          
          if (specialty) {
            matchesSpecialty = Boolean(user.medicalSpecialtyCategory && 
              user.medicalSpecialtyCategory.toLowerCase().trim() === specialty.toLowerCase().trim());
          }
          
          if (subSpecialty) {
            matchesSubSpecialty = Boolean(user.subSpecialty && 
              user.subSpecialty.toLowerCase().trim() === subSpecialty.toLowerCase().trim());
          }
          
          const matches = matchesSpecialty && matchesSubSpecialty;
          if (isDoctorLike(user.role)) {
            console.log(`  Doctor: ${user.firstName} ${user.lastName}`);
            console.log(`    Category: "${user.medicalSpecialtyCategory}" matches "${specialty}": ${matchesSpecialty}`);
            console.log(`    Sub-specialty: "${user.subSpecialty}" matches "${subSpecialty}": ${matchesSubSpecialty}`);
            console.log(`    Overall match: ${matches}`);
          }
          
          return matches;
        });
      }
      
      medicalStaff = medicalStaff.filter(user => {
          // For doctors specifically, apply minimal restrictions for patient access
          if (isDoctorLike(user.role)) {
            console.log(`Checking doctor: ${user.firstName} ${user.lastName} (ID: ${user.id})`);
            
            // If this is a specialty filtering request (for doctor selection/browsing),
            // show ALL active doctors regardless of working days or shifts
            // This allows patients to freely browse and select doctors by specialty
            if (specialty || subSpecialty) {
              console.log(`  - Specialty filtering mode: showing all active doctors for patient access`);
              console.log(`  - Doctor is active: ${user.isActive}`);
              // Return all active doctors for specialty browsing - no working day restrictions
              return user.isActive;
            }
            
            // For non-specialty filtering requests (like dashboard/shift management), 
            // use the original availability logic
            // Check if doctor has a shift today and is marked as available
            const todayShift = todayShifts.find(shift => shift.staffId === user.id);
            
            if (todayShift) {
              console.log(`  - Has shift today: available=${todayShift.isAvailable}, status=${todayShift.status}`);
              // Doctor has a shift today - check if they're available and not absent
              const isAvailable = todayShift.isAvailable && 
                     todayShift.status !== 'absent' && 
                     todayShift.status !== 'cancelled';
              console.log(`  - Final availability: ${isAvailable}`);
              return isAvailable;
            } else {
              // No shift found - check working days to see if they normally work today
              const hasWorkingDays = user.workingDays && user.workingDays.length > 0;
              const worksToday = hasWorkingDays && user.workingDays!.some(day => day.toLowerCase() === dayOfWeek);
              
              console.log(`  - No shift found. Working days: ${user.workingDays || 'none'}`);
              console.log(`  - Works today (${dayOfWeek}): ${worksToday}`);
              
              // If no working days are set, assume doctor is available (fallback)
              const isAvailable = hasWorkingDays ? worksToday : true;
              console.log(`  - Final availability: ${isAvailable}`);
              return isAvailable;
            }
          }
          // For non-doctors, show all active staff
          return true;
        })
        .map(user => {
          const { passwordHash, ...safeUser } = user;
          return safeUser;
        });
      
      // Count available doctors
      const availableDoctors = medicalStaff.filter(user => isDoctorLike(user.role)).length;
      
      console.log(`Available doctors after filtering: ${availableDoctors}`);
      console.log(`=== END DEBUG ===`);
      
      res.json({
        staff: medicalStaff,
        totalDoctors,
        availableDoctors
      });
    } catch (error) {
      console.error("Medical staff fetch error:", error);
      res.status(500).json({ error: "Failed to fetch medical staff" });
    }
  });

  // Simple doctors endpoint - direct database query for appointment booking
  app.get("/api/doctors", authMiddleware, async (req: TenantRequest, res) => {
    try {
      console.log('üîÑ DIRECT DOCTORS: Fetching doctors directly from database for organization:', req.tenant!.id);
      
      const users = await storage.getUsersByOrganization(req.tenant!.id);
      
      // Filter for active doctors only
      const doctors = users
        .filter(user => isDoctorLike(user.role) && user.isActive)
        .map(user => {
          const { passwordHash, ...safeUser } = user;
          return safeUser;
        });
      
      console.log('üîÑ DIRECT DOCTORS: Found doctors:', doctors.length);
      console.log('üîÑ DIRECT DOCTORS: Doctor names:', doctors.map(d => `${d.firstName} ${d.lastName}`).join(', '));
      
      res.json({ 
        doctors,
        count: doctors.length
      });
    } catch (error) {
      console.error("Direct doctors fetch error:", error);
      res.status(500).json({ error: "Failed to fetch doctors" });
    }
  });

  // Filter doctors by specialization
  app.get("/api/doctors/by-specialization", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user || !req.tenant) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      // Validate and normalize query parameters
      const querySchema = z.object({
        mainSpecialty: z.string().trim().min(1).optional(),
        subSpecialty: z.string().trim().min(1).optional()
      });

      const parseResult = querySchema.safeParse(req.query);
      if (!parseResult.success) {
        return res.status(400).json({ error: "Invalid query parameters" });
      }

      const { mainSpecialty, subSpecialty } = parseResult.data;
      
      // Get users filtered by organization (tenant isolation)
      const users = await storage.getUsersByOrganization(req.tenant.id);
      
      // Filter for active doctors only
      let filteredDoctors = users.filter(user => 
        isDoctorLike(user.role) && 
        user.isActive && 
        user.organizationId === req.tenant!.id
      );
      
      // Apply specialization filtering with case-insensitive exact matching
      if (mainSpecialty || subSpecialty) {
        filteredDoctors = filteredDoctors.filter(doctor => {
          const matchesMainSpecialty = !mainSpecialty || 
            (doctor.medicalSpecialtyCategory && 
             doctor.medicalSpecialtyCategory.toLowerCase().trim() === mainSpecialty.toLowerCase().trim());
          
          const matchesSubSpecialty = !subSpecialty || 
            (doctor.subSpecialty && 
             doctor.subSpecialty.toLowerCase().trim() === subSpecialty.toLowerCase().trim());
          
          return matchesMainSpecialty && matchesSubSpecialty;
        });
      }
      
      // Sanitize response - only include necessary fields for UI
      const safeDoctors = filteredDoctors.map(doctor => ({
        id: doctor.id,
        firstName: doctor.firstName,
        lastName: doctor.lastName,
        email: doctor.email,
        role: doctor.role,
        department: doctor.department,
        medicalSpecialtyCategory: doctor.medicalSpecialtyCategory,
        subSpecialty: doctor.subSpecialty,
        isActive: doctor.isActive
      }));
      
      res.json({
        doctors: safeDoctors,
        count: safeDoctors.length
      });
    } catch (error) {
      console.error("Error filtering doctors by specialization:", error);
      res.status(500).json({ error: "Failed to filter doctors" });
    }
  });

  // User Document Preferences endpoints
  app.get("/api/me/preferences", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user!.id;
      const organizationId = req.tenant!.id;
      
      const preferences = await storage.getUserDocumentPreferences(userId, organizationId);
      
      // If no preferences exist, return default values
      if (!preferences) {
        return res.json({
          clinicName: "",
          clinicAddress: "",
          clinicPhone: "",
          clinicEmail: "",
          doctorName: "",
          doctorTitle: "",
          doctorSpecialty: "",
          logoPosition: "left",
          headerPosition: "left"
        });
      }
      
      res.json(preferences);
    } catch (error) {
      console.error("Error fetching user document preferences:", error);
      res.status(500).json({ error: "Failed to fetch document preferences" });
    }
  });

  app.patch("/api/me/preferences", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user!.id;
      const organizationId = req.tenant!.id;
      
      // Import the update schema from shared/schema.ts
      const { updateUserDocumentPreferencesSchema } = await import("@shared/schema");
      const validationResult = updateUserDocumentPreferencesSchema.safeParse(req.body);
      
      if (!validationResult.success) {
        return res.status(400).json({ 
          error: "Invalid request data",
          details: validationResult.error.issues
        });
      }
      
      const updateData = validationResult.data;
      
      // Check if preferences already exist
      const existingPreferences = await storage.getUserDocumentPreferences(userId, organizationId);
      
      let preferences;
      if (existingPreferences) {
        // Update existing preferences
        preferences = await storage.updateUserDocumentPreferences(userId, organizationId, updateData);
      } else {
        // Create new preferences
        const newPreferences = {
          userId,
          organizationId,
          ...updateData
        };
        preferences = await storage.createUserDocumentPreferences(newPreferences);
      }
      
      if (!preferences) {
        return res.status(500).json({ error: "Failed to save document preferences" });
      }
      
      res.json(preferences);
    } catch (error) {
      console.error("Error updating user document preferences:", error);
      res.status(500).json({ error: "Failed to update document preferences" });
    }
  });

  app.get("/api/users", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const users = await storage.getUsersByOrganization(req.tenant!.id);
      
      // Remove passwordHash from response and add patient-specific data if role is patient
      const safeUsersPromises = users.map(async user => {
        const { passwordHash, ...safeUser } = user;
        
        // If user is a patient, fetch and merge patient-specific data
        if (user.role === 'patient') {
          const patient = await storage.getPatientByUserId(user.id, req.tenant!.id);
          if (patient) {
            // Fetch insurance verifications from insurance_verifications table
            const insuranceVerifications = await storage.getInsuranceVerificationsByPatient(patient.id, req.tenant!.id);
            const latestInsurance = insuranceVerifications[0]; // Get most recent verification
            
            return {
              ...safeUser,
              dateOfBirth: patient.dateOfBirth || "",
              phone: patient.phone || "",
              nhsNumber: patient.nhsNumber || "",
              address: patient.address || {},
              emergencyContact: patient.emergencyContact || {},
              insuranceInfo: patient.insuranceInfo || {},
              // Add insurance verification data from insurance_verifications table
              insuranceVerification: latestInsurance ? {
                id: latestInsurance.id,
                provider: latestInsurance.provider,
                policyNumber: latestInsurance.policyNumber,
                groupNumber: latestInsurance.groupNumber,
                memberNumber: latestInsurance.memberNumber,
                planType: latestInsurance.planType,
                coverageType: latestInsurance.coverageType,
                status: latestInsurance.status,
                eligibilityStatus: latestInsurance.eligibilityStatus,
                effectiveDate: latestInsurance.effectiveDate,
                expirationDate: latestInsurance.expirationDate,
                lastVerified: latestInsurance.lastVerified,
                benefits: latestInsurance.benefits,
              } : null,
            };
          }
        }
        
        return safeUser;
      });

      const safeUsers = await Promise.all(safeUsersPromises);
      res.json(safeUsers);
    } catch (error) {
      console.error("Users fetch error:", error);
      res.status(500).json({ error: "Failed to fetch users" });
    }
  });

  app.get("/api/roles", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const roles = await storage.getRolesByOrganization(req.tenant!.id);
      res.json(roles);
    } catch (error) {
      console.error("Roles fetch error:", error);
      res.status(500).json({ error: "Failed to fetch roles" });
    }
  });

  // Function to get default permissions based on role
  function getDefaultPermissionsByRole(role: string) {
    const basePermissions = {
      modules: {},
      fields: {}
    };

    switch (role) {
      case "admin":
        return {
          modules: {
            patients: { view: true, create: true, edit: true, delete: true },
            appointments: { view: true, create: true, edit: true, delete: true },
            medicalRecords: { view: true, create: true, edit: true, delete: true },
            prescriptions: { view: true, create: true, edit: true, delete: true },
            billing: { view: true, create: true, edit: true, delete: true },
            analytics: { view: true, create: true, edit: true, delete: true },
            userManagement: { view: true, create: true, edit: true, delete: true },
            settings: { view: true, create: true, edit: true, delete: true },
            aiInsights: { view: true, create: true, edit: true, delete: true },
            messaging: { view: true, create: true, edit: true, delete: true },
            telemedicine: { view: true, create: true, edit: true, delete: true },
            populationHealth: { view: true, create: true, edit: true, delete: true },
            clinicalDecision: { view: true, create: true, edit: true, delete: true },
            labResults: { view: true, create: true, edit: true, delete: true },
            medicalImaging: { view: true, create: true, edit: true, delete: true },
            voiceDocumentation: { view: true, create: true, edit: true, delete: true },
            forms: { view: true, create: true, edit: true, delete: true },
            integrations: { view: true, create: true, edit: true, delete: true },
            automation: { view: true, create: true, edit: true, delete: true },
            mobileHealth: { view: true, create: true, edit: true, delete: true }
          },
          fields: {
            patientSensitiveInfo: true,
            financialData: true,
            medicalHistory: true,
            prescriptionDetails: true,
            labResults: true,
            imagingResults: true,
            billingInformation: true,
            insuranceDetails: true
          }
        };

      case "doctor":
        return {
          modules: {
            patients: { view: true, create: true, edit: true, delete: false },
            appointments: { view: true, create: true, edit: true, delete: true },
            medicalRecords: { view: true, create: true, edit: true, delete: false },
            prescriptions: { view: true, create: true, edit: true, delete: true },
            billing: { view: true, create: false, edit: false, delete: false },
            analytics: { view: true, create: false, edit: false, delete: false },
            userManagement: { view: false, create: false, edit: false, delete: false },
            settings: { view: false, create: false, edit: false, delete: false },
            aiInsights: { view: true, create: true, edit: true, delete: false },
            messaging: { view: true, create: true, edit: true, delete: false },
            telemedicine: { view: true, create: true, edit: true, delete: false },
            populationHealth: { view: true, create: false, edit: false, delete: false },
            clinicalDecision: { view: true, create: true, edit: true, delete: false },
            labResults: { view: true, create: true, edit: true, delete: false },
            medicalImaging: { view: true, create: true, edit: true, delete: false },
            voiceDocumentation: { view: true, create: true, edit: true, delete: true },
            forms: { view: true, create: true, edit: true, delete: false },
            integrations: { view: false, create: false, edit: false, delete: false },
            automation: { view: true, create: false, edit: false, delete: false },
            mobileHealth: { view: true, create: false, edit: false, delete: false }
          },
          fields: {
            patientSensitiveInfo: true,
            financialData: false,
            medicalHistory: true,
            prescriptionDetails: true,
            labResults: true,
            imagingResults: true,
            billingInformation: false,
            insuranceDetails: false
          }
        };

      case "nurse":
        return {
          modules: {
            patients: { view: true, create: true, edit: true, delete: false },
            appointments: { view: true, create: true, edit: true, delete: false },
            medicalRecords: { view: true, create: true, edit: true, delete: false },
            prescriptions: { view: true, create: false, edit: false, delete: false },
            billing: { view: false, create: false, edit: false, delete: false },
            analytics: { view: false, create: false, edit: false, delete: false },
            userManagement: { view: false, create: false, edit: false, delete: false },
            settings: { view: false, create: false, edit: false, delete: false },
            aiInsights: { view: true, create: false, edit: false, delete: false },
            messaging: { view: true, create: true, edit: true, delete: false },
            telemedicine: { view: true, create: true, edit: true, delete: false },
            populationHealth: { view: false, create: false, edit: false, delete: false },
            clinicalDecision: { view: true, create: false, edit: false, delete: false },
            labResults: { view: true, create: true, edit: true, delete: false },
            medicalImaging: { view: true, create: false, edit: false, delete: false },
            voiceDocumentation: { view: true, create: true, edit: true, delete: true },
            forms: { view: true, create: true, edit: true, delete: false },
            integrations: { view: false, create: false, edit: false, delete: false },
            automation: { view: false, create: false, edit: false, delete: false },
            mobileHealth: { view: true, create: false, edit: false, delete: false }
          },
          fields: {
            patientSensitiveInfo: true,
            financialData: false,
            medicalHistory: true,
            prescriptionDetails: true,
            labResults: true,
            imagingResults: true,
            billingInformation: false,
            insuranceDetails: false
          }
        };

      case "receptionist":
        return {
          modules: {
            patients: { view: true, create: true, edit: true, delete: false },
            appointments: { view: true, create: true, edit: true, delete: false },
            medicalRecords: { view: false, create: false, edit: false, delete: false },
            prescriptions: { view: false, create: false, edit: false, delete: false },
            billing: { view: true, create: true, edit: true, delete: false },
            analytics: { view: false, create: false, edit: false, delete: false },
            userManagement: { view: false, create: false, edit: false, delete: false },
            settings: { view: false, create: false, edit: false, delete: false },
            aiInsights: { view: false, create: false, edit: false, delete: false },
            messaging: { view: true, create: true, edit: false, delete: false },
            telemedicine: { view: false, create: false, edit: false, delete: false },
            populationHealth: { view: false, create: false, edit: false, delete: false },
            clinicalDecision: { view: false, create: false, edit: false, delete: false },
            labResults: { view: false, create: false, edit: false, delete: false },
            medicalImaging: { view: false, create: false, edit: false, delete: false },
            voiceDocumentation: { view: false, create: false, edit: false, delete: false },
            forms: { view: true, create: true, edit: true, delete: false },
            integrations: { view: false, create: false, edit: false, delete: false },
            automation: { view: false, create: false, edit: false, delete: false },
            mobileHealth: { view: false, create: false, edit: false, delete: false }
          },
          fields: {
            patientSensitiveInfo: false,
            financialData: true,
            medicalHistory: false,
            prescriptionDetails: false,
            labResults: false,
            imagingResults: false,
            billingInformation: true,
            insuranceDetails: true
          }
        };

      case "patient":
        return {
          modules: {
            patients: { view: true, create: false, edit: true, delete: false },
            appointments: { view: true, create: true, edit: true, delete: false },
            medicalRecords: { view: true, create: false, edit: false, delete: false },
            prescriptions: { view: true, create: false, edit: false, delete: false },
            billing: { view: true, create: false, edit: false, delete: false },
            analytics: { view: false, create: false, edit: false, delete: false },
            userManagement: { view: false, create: false, edit: false, delete: false },
            settings: { view: false, create: false, edit: false, delete: false },
            aiInsights: { view: false, create: false, edit: false, delete: false },
            messaging: { view: true, create: true, edit: false, delete: false },
            telemedicine: { view: true, create: false, edit: false, delete: false },
            populationHealth: { view: false, create: false, edit: false, delete: false },
            clinicalDecision: { view: false, create: false, edit: false, delete: false },
            labResults: { view: true, create: false, edit: false, delete: false },
            medicalImaging: { view: true, create: false, edit: false, delete: false },
            voiceDocumentation: { view: true, create: true, edit: true, delete: true },
            forms: { view: true, create: true, edit: true, delete: false },
            integrations: { view: false, create: false, edit: false, delete: false },
            automation: { view: false, create: false, edit: false, delete: false },
            mobileHealth: { view: true, create: false, edit: false, delete: false }
          },
          fields: {
            patientSensitiveInfo: true,
            financialData: false,
            medicalHistory: true,
            prescriptionDetails: true,
            labResults: true,
            imagingResults: true,
            billingInformation: true,
            insuranceDetails: true
          }
        };

      case "sample_taker":
        return {
          modules: {
            patients: { view: true, create: false, edit: false, delete: false },
            appointments: { view: true, create: false, edit: false, delete: false },
            medicalRecords: { view: false, create: false, edit: false, delete: false },
            prescriptions: { view: false, create: false, edit: false, delete: false },
            billing: { view: false, create: false, edit: false, delete: false },
            analytics: { view: false, create: false, edit: false, delete: false },
            userManagement: { view: false, create: false, edit: false, delete: false },
            settings: { view: false, create: false, edit: false, delete: false },
            aiInsights: { view: false, create: false, edit: false, delete: false },
            messaging: { view: false, create: false, edit: false, delete: false },
            telemedicine: { view: false, create: false, edit: false, delete: false },
            populationHealth: { view: false, create: false, edit: false, delete: false },
            clinicalDecision: { view: false, create: false, edit: false, delete: false },
            labResults: { view: true, create: true, edit: true, delete: false },
            medicalImaging: { view: false, create: false, edit: false, delete: false },
            voiceDocumentation: { view: false, create: false, edit: false, delete: false },
            forms: { view: false, create: false, edit: false, delete: false },
            integrations: { view: false, create: false, edit: false, delete: false },
            automation: { view: false, create: false, edit: false, delete: false },
            mobileHealth: { view: false, create: false, edit: false, delete: false }
          },
          fields: {
            patientSensitiveInfo: false,
            financialData: false,
            medicalHistory: false,
            prescriptionDetails: false,
            labResults: true,
            imagingResults: false,
            billingInformation: false,
            insuranceDetails: false
          }
        };

      default:
        return basePermissions;
    }
  }

  app.get("/api/users/check-subscription-limit", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      // Get active subscription for the organization
      const [activeSubscription] = await db.select({
        maxUsers: saasSubscriptions.maxUsers,
        maxPatients: saasSubscriptions.maxPatients,
        status: saasSubscriptions.status
      })
      .from(saasSubscriptions)
      .where(eq(saasSubscriptions.organizationId, organizationId))
      .limit(1);

      if (!activeSubscription) {
        return res.status(403).json({ 
          error: "No active subscription found for this organization",
          canCreateUser: false 
        });
      }

      // Count existing non-patient users for the organization
      const [nonPatientUserCount] = await db.select({
        count: sql<number>`count(*)::int`
      })
      .from(users)
      .where(
        and(
          eq(users.organizationId, organizationId),
          ne(users.role, 'patient')
        )
      );

      // Count existing patients (users with role='patient')
      const [patientCount] = await db.select({
        count: sql<number>`count(*)::int`
      })
      .from(users)
      .where(
        and(
          eq(users.organizationId, organizationId),
          eq(users.role, 'patient')
        )
      );

      const currentUserCount = nonPatientUserCount?.count || 0;
      const maxUsers = activeSubscription.maxUsers || 0;
      const remainingUsers = maxUsers - currentUserCount;

      const currentPatientCount = patientCount?.count || 0;
      const maxPatients = activeSubscription.maxPatients || 0;
      const remainingPatients = maxPatients - currentPatientCount;

      res.json({
        canCreateUser: remainingUsers > 0,
        maxUsers,
        currentUserCount,
        remainingUsers,
        maxPatients,
        currentPatientCount,
        remainingPatients,
        subscriptionStatus: activeSubscription.status
      });
    } catch (error) {
      console.error("Error checking subscription limit:", error);
      res.status(500).json({ error: "Failed to check subscription limit" });
    }
  });

  app.post("/api/users", authMiddleware, async (req: TenantRequest, res) => {
    try {
      console.log("Creating user with role-based permissions");
      console.log("Request body:", req.body);
      
      const userData = z.object({
        email: z.string().email(),
        username: z.string().min(3),
        password: z.string().min(6),
        firstName: z.string().min(1),
        lastName: z.string().min(1),
        role: z.string().min(1), // Accept any role from database
        department: z.string().optional(),
        medicalSpecialtyCategory: z.string().optional(),
        subSpecialty: z.string().optional(),
        // Patient-specific fields
        dateOfBirth: z.string().optional(),
        phone: z.string().optional(),
        nhsNumber: z.string().optional(),
        address: z.object({
          street: z.string().optional(),
          city: z.string().optional(),
          state: z.string().optional(),
          postcode: z.string().optional(),
          country: z.string().optional(),
        }).optional(),
        emergencyContact: z.object({
          name: z.string().optional(),
          relationship: z.string().optional(),
          phone: z.string().optional(),
          email: z.string().optional(),
        }).optional(),
        insuranceInfo: z.object({
          provider: z.string().optional(),
          policyNumber: z.string().optional(),
          memberNumber: z.string().optional(),
          planType: z.string().optional(),
          effectiveDate: z.string().optional(),
        }).optional(),
      }).parse(req.body);

      // Check subscription limits based on role
      const organizationId = req.tenant!.id;
      
      // Get active subscription for the organization
      const [activeSubscription] = await db.select({
        maxUsers: saasSubscriptions.maxUsers,
        maxPatients: saasSubscriptions.maxPatients,
        status: saasSubscriptions.status
      })
      .from(saasSubscriptions)
      .where(eq(saasSubscriptions.organizationId, organizationId))
      .limit(1);

      if (!activeSubscription) {
        return res.status(403).json({ 
          error: "No active subscription found for this organization"
        });
      }

      // If creating a patient, check patient limits only
      if (userData.role === 'patient') {
        const [patientCount] = await db.select({
          count: sql<number>`count(*)::int`
        })
        .from(users)
        .where(
          and(
            eq(users.organizationId, organizationId),
            eq(users.role, 'patient')
          )
        );

        const currentPatientCount = patientCount?.count || 0;
        const maxPatients = activeSubscription.maxPatients || 0;

        if (currentPatientCount >= maxPatients) {
          return res.status(403).json({ 
            error: `Patient limit reached. Your subscription allows ${maxPatients} patients, and you currently have ${currentPatientCount} patients. Please upgrade your subscription to add more patients.`
          });
        }
      } else {
        // For non-patient roles, check non-patient user limits
        const [nonPatientUserCount] = await db.select({
          count: sql<number>`count(*)::int`
        })
        .from(users)
        .where(
          and(
            eq(users.organizationId, organizationId),
            ne(users.role, 'patient')
          )
        );

        const currentNonPatientUserCount = nonPatientUserCount?.count || 0;
        const maxUsers = activeSubscription.maxUsers || 0;

        if (currentNonPatientUserCount >= maxUsers) {
          return res.status(403).json({ 
            error: `User limit reached. Your subscription allows ${maxUsers} users, and you currently have ${currentNonPatientUserCount} users. Please upgrade your subscription to add more users.`
          });
        }
      }

      // Hash password
      const hashedPassword = await authService.hashPassword(userData.password);

      // Generate default permissions based on role
      const defaultPermissions = getDefaultPermissionsByRole(userData.role);

      const { password, ...userDataWithoutPassword } = userData;
      const user = await storage.createUser({
        ...userDataWithoutPassword,
        organizationId: req.tenant!.id,
        passwordHash: hashedPassword,
        permissions: defaultPermissions
      });

      console.log(`Created user with role: ${userData.role} and permissions:`, defaultPermissions);

      // If user role is patient, automatically create patient record
      if (userData.role === 'patient') {
        try {
          console.log("Creating patient record for user with role 'patient'");
          
          // Generate patient ID
          const patientCount = await storage.getPatientsByOrganization(req.tenant!.id, 999999);
          const patientId = `P${(patientCount.length + 1).toString().padStart(6, '0')}`;

          const patientData = {
            userId: user.id,
            firstName: userData.firstName,
            lastName: userData.lastName,
            dateOfBirth: userData.dateOfBirth ? new Date(userData.dateOfBirth) : new Date('1990-01-01'),
            email: userData.email, // Use same email as user
            phone: userData.phone || '',
            nhsNumber: userData.nhsNumber || '',
            organizationId: req.tenant!.id,
            patientId,
            address: userData.address || {},
            emergencyContact: userData.emergencyContact || {},
            medicalHistory: {
              allergies: [],
              chronicConditions: [],
              medications: [],
              familyHistory: {
                father: [],
                mother: [],
                siblings: [],
                grandparents: []
              },
              socialHistory: {
                smoking: { status: "never" as const },
                alcohol: { status: "never" as const },
                drugs: { status: "never" as const },
                occupation: "",
                maritalStatus: "single" as const,
                education: "",
                exercise: { frequency: "none" as const }
              },
              immunizations: []
            },
            insuranceInfo: userData.insuranceInfo || null
          };

          console.log("üîç DEBUG patientData BEFORE storage.createPatient:", { userId: patientData.userId, patientId: patientData.patientId });
          const patient = await storage.createPatient(patientData);
          console.log(`Created patient record with ID: ${patient.id}, patientId: ${patient.patientId}, userId: ${patient.userId}`);
          
        } catch (patientError) {
          console.error("Error creating patient record:", patientError);
          // Don't fail user creation if patient creation fails
          // Log the error but continue with user creation response
        }
      }

      // Remove password from response
      const { passwordHash, ...safeUser } = user;
      res.status(201).json(safeUser);
    } catch (error: any) {
      console.error("User creation error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      
      // Handle duplicate username error
      if (error.code === '23505' && error.constraint === 'users_username_key') {
        return res.status(400).json({ 
          error: "Username already exists. Please choose a different username." 
        });
      }
      
      // Handle duplicate email error
      if (error.code === '23505' && error.constraint === 'users_email_key') {
        return res.status(400).json({ 
          error: "Email address already exists. Please use a different email." 
        });
      }
      
      res.status(500).json({ error: "Failed to create user" });
    }
  });

  // Send welcome email to newly created user
  app.post("/api/users/send-welcome-email", authMiddleware, async (req: TenantRequest, res) => {
    try {
      console.log("üìß [EMAIL ENDPOINT] Received welcome email request");
      console.log("üìß [EMAIL ENDPOINT] Request body:", req.body);
      console.log("üìß [EMAIL ENDPOINT] Organization ID:", req.tenant!.id);
      
      const emailData = z.object({
        userEmail: z.string().email(),
        userName: z.string().min(1),
        password: z.string().min(1),
        role: z.string().min(1)
      }).parse(req.body);

      console.log("üìß [EMAIL ENDPOINT] Validated email data:", emailData);

      // Get organization details
      const organization = await storage.getOrganization(req.tenant!.id);
      console.log("üìß [EMAIL ENDPOINT] Organization retrieved:", organization);
      
      if (!organization) {
        console.error("‚ùå [EMAIL ENDPOINT] Organization not found for ID:", req.tenant!.id);
        return res.status(404).json({ error: "Organization not found" });
      }

      // Send the welcome email
      console.log("üìß [EMAIL ENDPOINT] Attempting to send email via emailService...");
      const emailSent = await emailService.sendNewUserAccountEmail(
        emailData.userEmail,
        emailData.userName,
        emailData.password,
        organization.name,
        emailData.role
      );

      console.log("üìß [EMAIL ENDPOINT] Email service result:", emailSent);

      if (emailSent) {
        console.log("‚úÖ [EMAIL ENDPOINT] Welcome email sent successfully to", emailData.userEmail);
        res.status(200).json({ success: true, message: "Welcome email sent successfully" });
      } else {
        console.error("‚ùå [EMAIL ENDPOINT] Email service returned false");
        res.status(500).json({ success: false, error: "Failed to send welcome email" });
      }
    } catch (error: any) {
      console.error("‚ùå [EMAIL ENDPOINT] Error sending welcome email:", error);
      console.error("‚ùå [EMAIL ENDPOINT] Error stack:", error.stack);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to send welcome email" });
    }
  });

  // Update user
  app.patch("/api/users/:id", async (req: TenantRequest, res) => {
    try {
      const userId = parseInt(req.params.id);
      const updates = req.body;
      
      // Check if user has permission to update this user
      const isAdmin = req.user?.role === "admin";
      const isSelfUpdate = req.user?.id === userId;
      
      if (!isAdmin && !isSelfUpdate) {
        return res.status(403).json({ error: "Permission denied" });
      }

      // Only allow schedule and specialty updates for non-admin users updating themselves
      if (!isAdmin && isSelfUpdate) {
        const allowedFields = ['workingDays', 'workingHours', 'medicalSpecialtyCategory', 'subSpecialty'];
        const hasInvalidField = Object.keys(updates).some(key => !allowedFields.includes(key));
        if (hasInvalidField) {
          return res.status(403).json({ error: "Can only update schedule and specialty information" });
        }
      }
      
      // Hash password if provided (admin only)
      if (updates.password && isAdmin) {
        updates.passwordHash = await authService.hashPassword(updates.password);
        delete updates.password; // Remove the plain password field
      } else if (updates.password) {
        // If password provided but not admin, remove it for security
        delete updates.password;
      }

      // Fetch the current user BEFORE updating (to get old email for patient lookup)
      const currentUser = await storage.getUser(userId, req.tenant!.id);
      if (!currentUser) {
        return res.status(404).json({ error: "User not found" });
      }

      // Separate patient-specific fields from user fields
      const patientFields = [
        'dateOfBirth', 'genderAtBirth', 'phone', 'nhsNumber', 
        'address', 'emergencyContact', 'insuranceInfo', 
        'medicalHistory', 'riskLevel', 'flags', 
        'communicationPreferences', 'isActive', 'isInsured'
      ];
      const patientUpdates: any = {};
      const userUpdates: any = {};

      for (const [key, value] of Object.entries(updates)) {
        if (patientFields.includes(key)) {
          patientUpdates[key] = value;
        } else {
          userUpdates[key] = value;
        }
      }

      // If user is a patient and we're changing the email, also update patient email
      const isEmailChanging = userUpdates.email && userUpdates.email !== currentUser.email;
      if (currentUser.role === 'patient' && isEmailChanging) {
        patientUpdates.email = userUpdates.email;
      }

      // Update user record
      const user = await storage.updateUser(userId, req.tenant!.id, userUpdates);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      // If user is a patient and there are patient-specific updates, update/create the patient record
      if (user.role === 'patient' && Object.keys(patientUpdates).length > 0) {
        // Use OLD email to find patient (before email change)
        let patient = await storage.getPatientByEmail(currentUser.email, req.tenant!.id);
        
        // AUTO-CREATE MISSING PATIENT RECORD (Option 2 implementation)
        if (!patient) {
          console.log(`‚ö†Ô∏è Patient record missing for user ${user.id} (${user.email}). Auto-creating...`);
          
          // Generate patient ID
          const patientCount = await storage.getPatientsByOrganization(req.tenant!.id, 999999);
          const generatedPatientId = `P${(patientCount.length + 1).toString().padStart(6, '0')}`;
          
          // Create patient record with basic info from user
          patient = await storage.createPatient({
            organizationId: req.tenant!.id,
            patientId: generatedPatientId,
            firstName: user.firstName,
            lastName: user.lastName,
            email: user.email,
            dateOfBirth: null as any,
            genderAtBirth: null as any,
            phone: "",
            nhsNumber: "",
            address: {},
            emergencyContact: {},
            insuranceInfo: {},
            medicalHistory: {
              allergies: [],
              medications: [],
              chronicConditions: [],
              familyHistory: {
                father: [],
                mother: [],
                siblings: [],
                grandparents: []
              },
              immunizations: [],
              socialHistory: {
                smoking: { status: "never" },
                alcohol: { status: "never" },
                drugs: { status: "never" },
                exercise: { frequency: "none" },
                occupation: "",
                education: "",
                maritalStatus: "single"
              }
            },
            riskLevel: "low",
            flags: [],
            communicationPreferences: {},
            isActive: true,
            isInsured: false
          });
          
          console.log(`‚úÖ Auto-created patient record with ID: ${patient.id}, patientId: ${generatedPatientId}`);
        }
        
        // Now update the patient record (whether it was just created or already existed)
        if (patient) {
          console.log("Updating patient record with data:", patientUpdates);
          await storage.updatePatient(patient.id, req.tenant!.id, patientUpdates);
          
          // Update insurance verification if insurance info is provided
          if (updates.insuranceInfo) {
            const insuranceVerifications = await storage.getInsuranceVerificationsByPatient(patient.id, req.tenant!.id);
            const insuranceData = {
              organizationId: req.tenant!.id,
              patientId: patient.id,
              patientName: `${user.firstName} ${user.lastName}`,
              provider: updates.insuranceInfo.provider || "",
              policyNumber: updates.insuranceInfo.policyNumber || "",
              groupNumber: updates.insuranceInfo.groupNumber || "",
              memberNumber: updates.insuranceInfo.memberNumber || "",
              nhsNumber: patient.nhsNumber || "",
              planType: updates.insuranceInfo.planType || "",
              coverageType: updates.insuranceInfo.coverageType || "primary",
              status: updates.insuranceInfo.status || "active",
              eligibilityStatus: updates.insuranceInfo.eligibilityStatus || "pending",
              effectiveDate: updates.insuranceInfo.effectiveDate || null,
              expirationDate: updates.insuranceInfo.expirationDate || null,
              lastVerified: new Date().toISOString().split('T')[0],
              benefits: updates.insuranceInfo.benefits || {},
            };
            
            if (insuranceVerifications.length > 0) {
              // Update existing insurance verification
              await storage.updateInsuranceVerification(insuranceVerifications[0].id, req.tenant!.id, insuranceData);
            } else {
              // Create new insurance verification
              await storage.createInsuranceVerification(insuranceData as any);
            }
          }
        }
      }

      // Fetch updated user with patient data merged (use NEW email after update)
      let responseData: any = { ...user };
      if (user.role === 'patient') {
        const patient = await storage.getPatientByUserId(userId, req.tenant!.id);
        if (patient) {
          // Fetch insurance verifications from insurance_verifications table
          const insuranceVerifications = await storage.getInsuranceVerificationsByPatient(patient.id, req.tenant!.id);
          const latestInsurance = insuranceVerifications[0];
          
          responseData = {
            ...responseData,
            dateOfBirth: patient.dateOfBirth || "",
            genderAtBirth: patient.genderAtBirth || "",
            phone: patient.phone || "",
            nhsNumber: patient.nhsNumber || "",
            address: patient.address || {},
            emergencyContact: patient.emergencyContact || {},
            insuranceInfo: patient.insuranceInfo || {},
            medicalHistory: patient.medicalHistory || {},
            riskLevel: patient.riskLevel || "low",
            flags: patient.flags || [],
            communicationPreferences: patient.communicationPreferences || {},
            isActive: patient.isActive !== undefined ? patient.isActive : true,
            isInsured: patient.isInsured !== undefined ? patient.isInsured : false,
            // Add insurance verification data from insurance_verifications table
            insuranceVerification: latestInsurance ? {
              id: latestInsurance.id,
              provider: latestInsurance.provider,
              policyNumber: latestInsurance.policyNumber,
              groupNumber: latestInsurance.groupNumber,
              memberNumber: latestInsurance.memberNumber,
              planType: latestInsurance.planType,
              coverageType: latestInsurance.coverageType,
              status: latestInsurance.status,
              eligibilityStatus: latestInsurance.eligibilityStatus,
              effectiveDate: latestInsurance.effectiveDate,
              expirationDate: latestInsurance.expirationDate,
              lastVerified: latestInsurance.lastVerified,
              benefits: latestInsurance.benefits,
            } : null,
          };
        }
      }

      // Remove password from response
      const { passwordHash, ...safeUser } = responseData;
      res.json(safeUser);
    } catch (error) {
      console.error("User update error:", error);
      res.status(500).json({ error: "Failed to update user" });
    }
  });

  // Delete user
  app.delete("/api/users/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = parseInt(req.params.id);
      console.log(`Deleting user ${userId} for organization ${req.tenant!.id}`);
      
      const success = await storage.deleteUser(userId, req.tenant!.id);
      
      if (!success) {
        console.log(`User ${userId} not found or already deleted`);
        return res.status(404).json({ error: "User not found" });
      }

      console.log(`User ${userId} deleted successfully`);
      res.json({ message: "User deleted successfully" });
    } catch (error) {
      console.error("User deletion error:", error);
      res.status(500).json({ error: "Failed to delete user" });
    }
  });

  // Role management routes
  app.get("/api/roles", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const roles = await storage.getRolesByOrganization(req.tenant!.id);
      res.json(roles);
    } catch (error) {
      console.error("Roles fetch error:", error);
      res.status(500).json({ error: "Failed to fetch roles" });
    }
  });

  // Get role permissions by role name
  app.get("/api/roles/by-name/:roleName", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { roleName } = req.params;
      
      // Security check: Only allow users to fetch their own role permissions, or admins to fetch any
      if (req.user?.role !== "admin" && req.user?.role?.toLowerCase() !== roleName.toLowerCase()) {
        return res.status(403).json({ error: "Access denied. You can only fetch permissions for your own role." });
      }

      const role = await storage.getRoleByName(roleName, req.tenant!.id);
      
      if (!role) {
        return res.status(404).json({ error: "Role not found" });
      }
      
      res.json(role);
    } catch (error) {
      console.error("Role fetch by name error:", error);
      res.status(500).json({ error: "Failed to fetch role" });
    }
  });

  app.post("/api/roles", requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const permissionsPayload = preparePermissionsForValidation(req.body?.permissions);
      const validatedPermissions = rolePermissionsUpdate.parse(permissionsPayload);

      const roleData = z.object({
        name: z.string().min(1).max(50),
        displayName: z.string().min(1),
        description: z.string().min(1),
        permissions: rolePermissionsUpdate,
        isSystem: z.boolean().optional().default(false)
      }).parse({
        ...req.body,
        permissions: validatedPermissions,
      });

      const role = await storage.createRole({
        ...roleData,
        organizationId: req.tenant!.id
      });

      res.status(201).json(role);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Permissions validation errors:", error.issues);
        return res.status(400).json({
          error: "Invalid permissions payload",
          details: error.issues,
        });
      }
      console.error("Role creation error:", error);
      res.status(500).json({ error: "Failed to create role" });
    }
  });

  const MODULE_KEYS = [
    "dashboard", "patients", "appointments", "medicalRecords", "prescriptions", "billing",
    "analytics", "userManagement", "shiftManagement", "settings", "aiInsights", "messaging",
    "telemedicine", "labResults", "medicalImaging", "forms", "integrations",
    "automation", "patientPortal", "populationHealth", "voiceDocumentation",
    "inventory", "gdprCompliance", "subscription"
  ] as const;

  const FIELD_KEYS = [
    "patientSensitiveInfo", "financialData", "medicalHistory", "prescriptionDetails",
    "labResults", "imagingResults", "billingInformation", "insuranceDetails"
  ] as const;

  const modulePermissionSchema = z.object({
    view: z.boolean(),
    create: z.boolean(),
    edit: z.boolean(),
    delete: z.boolean(),
  }).passthrough();

  const fieldPermissionSchema = z.object({
    view: z.boolean(),
    edit: z.boolean(),
  }).passthrough();

  const parseEntryValue = (value: any) => {
    if (value === undefined || value === null) {
      return null;
    }
    if (typeof value === "string") {
      try {
        const parsed = JSON.parse(value);
        if (typeof parsed === "object" && parsed !== null) {
          return parsed;
        }
        return null;
      } catch {
        return null;
      }
    }
    if (typeof value === "object") {
      return value;
    }
    return null;
  };

  const normalizePermissionEntry = (entry: any, keys: readonly string[]) => {
    const result: Record<string, any> = {};
    keys.forEach((key) => {
      const value = parseEntryValue(entry?.[key]);
      if (value === null) {
        result[key] = null;
      } else {
        result[key] = {
          view: Boolean(value?.view),
          create: Boolean(value?.create),
          edit: Boolean(value?.edit),
          delete: Boolean(value?.delete),
        };
      }
    });
    return result;
  };

  const normalizePermissionFields = (entry: any, keys: readonly string[]) => {
    const result: Record<string, any> = {};
    keys.forEach((key) => {
      const value = parseEntryValue(entry?.[key]);
      result[key] = {
        view: Boolean(value?.view),
        edit: Boolean(value?.edit),
      };
    });
    return result;
  };

  const normalizePermissionsPayload = (payload: any) => {
    console.log("Normalizing permissions payload:", payload);
    return {
      modules: normalizePermissionEntry(payload?.modules, MODULE_KEYS),
      fields: normalizePermissionFields(payload?.fields, FIELD_KEYS),
    };
  };

  const preparePermissionsForValidation = (payload: any) => normalizePermissionsPayload(payload);

  const rolePermissionsUpdate = z.object({
    modules: z.record(z.string(), z.union([modulePermissionSchema, z.null()])),
    fields: z.record(z.string(), z.union([fieldPermissionSchema, z.null()])),
  });

  const roleUpdateBase = z.object({
    name: z.string().optional(),
    displayName: z.string().optional(),
    description: z.string().optional(),
  });

  app.patch("/api/roles/:id", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const roleId = Number(req.params.id);

      console.log("Incoming permissions payload:", JSON.stringify(req.body?.permissions));
      const permissionsPayload = preparePermissionsForValidation(req.body?.permissions);
      console.log("Incoming permissions payload 2:", JSON.stringify(permissionsPayload));
      
      const validatedPermissions = rolePermissionsUpdate.parse(permissionsPayload);
      console.log("Incoming permissions payload 3:", JSON.stringify(req.body?.permissions));

      const updateData = roleUpdateBase.extend({
        permissions: rolePermissionsUpdate.optional(),
      }).parse({
        name: req.body?.name,
        displayName: req.body?.displayName,
        description: req.body?.description,
        permissions: validatedPermissions,
      });

      console.log("Normalized permissions payload:", validatedPermissions);

      const role = await storage.updateRole(roleId, req.tenant!.id, updateData);

      if (!role) {
        return res.status(404).json({ error: "Role not found" });
      }

      res.json(role);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Permissions validation errors:", error.issues);
        return res.status(400).json({
          error: "Invalid permissions payload",
          details: error.issues,
        });
      }

      console.error("Role update error:", error);
      res.status(500).json({ error: "Failed to update role" });
    }
  });

  app.delete("/api/roles/:id", requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const roleId = parseInt(req.params.id);
      
      // Check if this is a system role
      const role = await storage.getRole(roleId, req.tenant!.id);
      if (!role) {
        return res.status(404).json({ error: "Role not found" });
      }
      
      if (role.isSystem) {
        return res.status(400).json({ error: "Cannot delete system roles" });
      }

      const success = await storage.deleteRole(roleId, req.tenant!.id);
      
      if (!success) {
        return res.status(404).json({ error: "Role not found" });
      }

      res.json({ success: true });
    } catch (error) {
      console.error("Role deletion error:", error);
      res.status(500).json({ error: "Failed to delete role" });
    }
  });

  // Subscription management routes
  app.get("/api/subscription", requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const subscription = await storage.getSubscription(req.tenant!.id);
      if (!subscription) {
        return res.status(404).json({ error: "Subscription not found" });
      }
      res.json(subscription);
    } catch (error) {
      console.error("Subscription fetch error:", error);
      res.status(500).json({ error: "Failed to fetch subscription" });
    }
  });

  // AI insights routes
  app.post("/api/ai/analyze-patient/:id", requireRole(["doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.id);
      
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      const medicalRecords = await storage.getMedicalRecordsByPatient(patientId, req.tenant!.id);
      
      const insights = await aiService.analyzePatientRisk(patient, medicalRecords);
      
      // Save insights to database
      for (const insight of insights) {
        await storage.createAiInsight({
          organizationId: req.tenant!.id,
          patientId,
          type: insight.type,
          title: insight.title,
          description: insight.description,
          severity: insight.severity,
          actionRequired: insight.actionRequired,
          confidence: insight.confidence.toString()
        });
      }

      res.json(insights);
    } catch (error) {
      console.error("AI analysis error:", error);
      res.status(500).json({ error: "Failed to analyze patient" });
    }
  });

  app.patch("/api/ai/insights/:id", requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      const insightId = parseInt(req.params.id);
      
      const updateData = z.object({
        status: z.enum(["active", "dismissed", "resolved"]).optional(),
        aiStatus: z.enum(["pending", "reviewed", "implemented", "dismissed"]).optional()
      }).parse(req.body);

      // Get the current insight to track status changes
      const currentInsight = await storage.getAiInsight(insightId, req.tenant!.id);
      if (!currentInsight) {
        return res.status(404).json({ error: "AI insight not found" });
      }

      const insight = await storage.updateAiInsight(insightId, req.tenant!.id, updateData);
      
      if (!insight) {
        return res.status(404).json({ error: "AI insight not found" });
      }

      // Emit SSE event if aiStatus was updated
      if (updateData.aiStatus && updateData.aiStatus !== currentInsight.aiStatus) {
        const sseEvent: AiInsightSSEEvent = {
          type: 'ai_insight.status_updated',
          id: insight.id.toString(),
          patientId: insight.patientId?.toString() || '',
          status: updateData.aiStatus,
          previousStatus: currentInsight.aiStatus || 'pending',
          updatedAt: new Date().toISOString(),
          organizationId: req.tenant!.id
        };

        aiInsightBroadcaster.broadcast(req.tenant!.id, sseEvent);
        console.log(`[SSE] Emitted status update event for insight ${insight.id}: ${currentInsight.aiStatus} -> ${updateData.aiStatus}`);
      }

      res.json(insight);
    } catch (error) {
      console.error("AI insight update error:", error);
      res.status(500).json({ error: "Failed to update AI insight" });
    }
  });

  // Server-Sent Events endpoint for real-time AI insight updates
  app.get("/api/ai-insights/events", requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      // Set SSE headers
      res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control',
        'X-Accel-Buffering': 'no' // Disable nginx buffering for SSE
      });

      // Add connection to broadcaster
      aiInsightBroadcaster.addConnection(organizationId, res);

      // Send initial connection event
      const connectEventId = uuidv4();
      res.write(`id: ${connectEventId}\nevent: connected\ndata: {"message":"Connected to AI insights updates"}\n\n`);

      // Send heartbeat every 30 seconds to keep connection alive
      const heartbeatInterval = setInterval(() => {
        if (!res.destroyed && !res.headersSent) {
          try {
            res.write(`: heartbeat ${Date.now()}\n\n`);
          } catch (error) {
            console.error('[SSE] Heartbeat error:', error);
            clearInterval(heartbeatInterval);
          }
        } else {
          clearInterval(heartbeatInterval);
        }
      }, 30000);

      // Clean up on client disconnect
      req.on('close', () => {
        clearInterval(heartbeatInterval);
        aiInsightBroadcaster.removeConnection(organizationId, res);
        console.log(`[SSE] Client disconnected from organization ${organizationId}`);
      });

      req.on('aborted', () => {
        clearInterval(heartbeatInterval);
        aiInsightBroadcaster.removeConnection(organizationId, res);
        console.log(`[SSE] Client aborted connection from organization ${organizationId}`);
      });

      console.log(`[SSE] Client connected to AI insights events for organization ${organizationId}`);
      
    } catch (error) {
      console.error('[SSE] Error setting up SSE connection:', error);
      res.status(500).json({ error: 'Failed to establish SSE connection' });
    }
  });

  // AI Insights CRUD Routes
  
  // GET /api/ai-insights - List insights with optional patient filter
  app.get("/api/ai-insights", requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      const patientId = req.query.patientId ? parseInt(req.query.patientId as string) : undefined;
      
      let insights;
      if (patientId) {
        // Validate that patient belongs to the same organization
        const patient = await storage.getPatient(patientId, req.tenant!.id);
        if (!patient) {
          return res.status(404).json({ error: "Patient not found" });
        }
        insights = await storage.getAiInsightsByPatient(patientId, req.tenant!.id);
      } else {
        insights = await storage.getAiInsightsByOrganization(req.tenant!.id, 50);
      }

      // Transform confidence from string to number for frontend
      const transformedInsights = insights.map(insight => ({
        ...insight,
        confidence: insight.confidence ? parseFloat(insight.confidence) : 0
      }));

      res.json(transformedInsights);
    } catch (error) {
      handleRouteError(error, "list AI insights", res);
    }
  });

  // POST /api/ai-insights - Create new insight
  app.post("/api/ai-insights", requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      // Create schema that excludes server-managed fields (organizationId)
      const createInsightSchema = z.object({
        patientId: z.number().optional(),
        type: z.enum(["risk_alert", "drug_interaction", "treatment_suggestion", "preventive_care"]),
        title: z.string().min(1),
        description: z.string().min(1),
        severity: z.enum(["low", "medium", "high", "critical"]),
        actionRequired: z.boolean(),
        confidence: z.string().regex(/^(0(\.\d+)?|1(\.0+)?)$/, "Confidence must be between 0 and 1"),
        symptoms: z.string().optional().nullable(),
        history: z.string().optional().nullable(),
        status: z.string().default("active"),
        aiStatus: z.string().default("pending"),
        metadata: z.record(z.any()).optional().default({}),
      }).passthrough();

      const validatedData = createInsightSchema.parse(req.body);
      
      // Validate that patient belongs to the same organization if patientId is provided
      if (validatedData.patientId) {
        const patient = await storage.getPatient(validatedData.patientId, req.tenant!.id);
        if (!patient) {
          return res.status(404).json({ error: "Patient not found" });
        }
      }

      // Prepare metadata with symptoms and history
      const { symptoms, history, ...insightDataRaw } = validatedData;
      const { id, ...insightData } = insightDataRaw;
      
      // Generate suggested actions based on insight type and severity
      const generateSuggestedActions = (type: string, severity: string, actionRequired: boolean) => {
        const actions = [];
        
        if (actionRequired) {
          switch (type) {
            case 'risk_alert':
              if (severity === 'critical') {
                actions.push('Immediate patient evaluation required', 'Contact primary physician within 2 hours', 'Document findings in medical record');
              } else if (severity === 'high') {
                actions.push('Schedule follow-up appointment within 1 week', 'Monitor patient closely', 'Review medication interactions');
              } else {
                actions.push('Schedule routine follow-up', 'Patient education on risk factors', 'Consider preventive measures');
              }
              break;
            case 'drug_interaction':
              actions.push('Review medication list with pharmacist', 'Monitor for adverse effects', 'Consider alternative medications', 'Educate patient on interaction signs');
              break;
            case 'treatment_suggestion':
              actions.push('Discuss treatment options with patient', 'Obtain informed consent', 'Monitor treatment response', 'Schedule follow-up assessment');
              break;
            case 'diagnostic':
              actions.push('Order appropriate diagnostic tests', 'Review results with specialist', 'Monitor symptoms progression', 'Document clinical findings');
              break;
            case 'preventive':
              actions.push('Implement preventive care plan', 'Patient lifestyle counseling', 'Schedule regular monitoring', 'Educate on risk reduction');
              break;
            default:
              actions.push('Review clinical findings', 'Follow standard care protocols', 'Document assessment', 'Monitor patient status');
          }
        } else {
          actions.push('Review and acknowledge findings', 'Consider for future reference', 'Update patient care plan if needed');
        }
        
        return actions;
      };

      const suggestedActions = generateSuggestedActions(insightData.type || '', insightData.severity || '', insightData.actionRequired || false);
      
      // Generate related conditions based on insight type and content
      const generateRelatedConditions = (type: string, title: string, description: string) => {
        const conditions = [];
        const lowerTitle = title.toLowerCase();
        const lowerDesc = description.toLowerCase();
        
        switch (type) {
          case 'risk_alert':
            if (lowerTitle.includes('cardiac') || lowerDesc.includes('heart')) {
              conditions.push('Cardiovascular Disease', 'Hypertension', 'Coronary Artery Disease');
            } else if (lowerTitle.includes('diabetic') || lowerDesc.includes('diabetes')) {
              conditions.push('Type 2 Diabetes', 'Insulin Resistance', 'Metabolic Syndrome');
            } else if (lowerTitle.includes('respiratory') || lowerDesc.includes('lung')) {
              conditions.push('COPD', 'Asthma', 'Pulmonary Disease');
            } else {
              conditions.push('Chronic Disease Risk', 'Lifestyle Factors', 'Preventive Care Needed');
            }
            break;
          case 'drug_interaction':
            conditions.push('Polypharmacy', 'Drug-Drug Interactions', 'Medication Side Effects', 'Pharmacokinetic Changes');
            break;
          case 'treatment_suggestion':
            if (lowerDesc.includes('pain')) {
              conditions.push('Chronic Pain', 'Pain Management', 'Inflammation');
            } else if (lowerDesc.includes('infection')) {
              conditions.push('Bacterial Infection', 'Antibiotic Therapy', 'Immune Response');
            } else {
              conditions.push('Treatment Response', 'Therapeutic Options', 'Clinical Guidelines');
            }
            break;
          case 'diagnostic':
            conditions.push('Differential Diagnosis', 'Clinical Assessment', 'Diagnostic Testing');
            break;
          case 'preventive':
            conditions.push('Preventive Medicine', 'Health Maintenance', 'Risk Reduction', 'Screening Guidelines');
            break;
          default:
            conditions.push('Clinical Assessment', 'Patient Care', 'Medical Evaluation');
        }
        
        return conditions.slice(0, 4); // Limit to 4 conditions max
      };

      const relatedConditions = generateRelatedConditions(insightData.type || '', insightData.title || '', insightData.description || '');
      
      const metadata = {
        ...(insightData.metadata || {}),
        ...(symptoms && { symptoms }),
        ...(history && { history }),
        suggestedActions,
        relatedConditions
      };

      // Convert confidence from number to string for DB storage
      const insightToCreate = {
        ...insightData,
        organizationId: req.tenant!.id,
        confidence: insightData.confidence ? insightData.confidence.toString() : "0",
        metadata
      };

      const { id: _, ...insertableInsight } = {
        ...insightToCreate,
        userId: req.user?.id,
        createdAt: new Date(),
      };
      const newInsight = await storage.createAiInsight(insertableInsight as any);
      
      // Transform confidence back to number for frontend response
      const transformedInsight = {
        ...newInsight,
        confidence: newInsight.confidence ? parseFloat(newInsight.confidence) : 0
      };

      res.status(201).json(transformedInsight);
    } catch (error) {
      console.error("[AI-INSIGHTS] create request body:", req.body);
      console.error("[AI-INSIGHTS] create error stack:", error);
      handleRouteError(error, "create AI insight", res);
    }
  });

  // DELETE /api/ai-insights/:id - Delete insight with org-scoped security
  app.delete("/api/ai-insights/:id", requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      const insightId = parseInt(req.params.id);
      
      if (isNaN(insightId)) {
        return res.status(400).json({ error: "Invalid insight ID" });
      }

      // Check if insight exists and belongs to organization
      const existingInsight = await storage.getAiInsight(insightId, req.tenant!.id);
      if (!existingInsight) {
        return res.status(404).json({ error: "AI insight not found" });
      }

      const deleted = await storage.deleteAiInsight(insightId, req.tenant!.id);
      
      if (!deleted) {
        return res.status(404).json({ error: "AI insight not found" });
      }

      res.json({ success: true, message: "AI insight deleted successfully" });
    } catch (error) {
      handleRouteError(error, "delete AI insight", res);
    }
  });

  // PATCH /api/ai-insights/:id - Update insight fields (severity, status, etc.)
  app.patch("/api/ai-insights/:id", requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      const insightId = parseInt(req.params.id);
      
      if (isNaN(insightId)) {
        return res.status(400).json({ error: "Invalid insight ID" });
      }

      // Validate update data - allow severity, status, and other fields
      const updateData = z.object({
        severity: z.enum(["critical", "high", "medium", "low"]).optional(),
        status: z.enum(["active", "reviewed", "dismissed", "implemented"]).optional(),
        aiStatus: z.enum(["pending", "reviewed", "implemented", "dismissed"]).optional(),
        notes: z.string().optional()
      }).parse(req.body);

      console.log(`[AI-INSIGHTS] Updating insight ${insightId} with data:`, updateData);

      // Check if insight exists and belongs to organization
      const existingInsight = await storage.getAiInsight(insightId, req.tenant!.id);
      if (!existingInsight) {
        return res.status(404).json({ error: "AI insight not found" });
      }

      // Update the insight in the database
      const updatedInsight = await storage.updateAiInsight(insightId, req.tenant!.id, updateData);
      
      if (!updatedInsight) {
        return res.status(404).json({ error: "AI insight not found or update failed" });
      }

      console.log(`[AI-INSIGHTS] Successfully updated insight ${insightId}:`, updatedInsight);

      // Transform confidence from string to number for frontend response
      const transformedInsight = {
        ...updatedInsight,
        confidence: updatedInsight.confidence ? parseFloat(updatedInsight.confidence) : 0
      };

      res.json({ success: true, insight: transformedInsight, message: "AI insight updated successfully" });
    } catch (error) {
      console.error(`[AI-INSIGHTS] Update error for insight ${req.params.id}:`, error);
      handleRouteError(error, "update AI insight", res);
    }
  });

  // Keep the existing clinical insights route for backward compatibility but use real data
  app.get("/api/clinical/insights", requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      const insights = await storage.getAiInsightsByOrganization(req.tenant!.id, 50);
      
      // Transform to match the expected clinical insights format
      const transformedInsights = insights.map(insight => ({
        ...insight,
        confidence: insight.confidence ? parseFloat(insight.confidence) : 0,
        priority: insight.severity, // Map severity to priority for backward compatibility
        patientName: `Patient ${insight.patientId}` // Will be enriched with real patient data in frontend
      }));

      res.json(transformedInsights);
    } catch (error) {
      handleRouteError(error, "fetch clinical insights", res);
    }
  });

  app.patch("/api/clinical/insights/:id", requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      const insightId = req.params.id;
      
      const updateData = z.object({
        status: z.enum(["active", "reviewed", "dismissed", "implemented"]).optional(),
        notes: z.string().optional()
      }).parse(req.body);

      console.log(`Updating clinical insight ${insightId} with status: ${updateData.status}`);
      
      // For now, return success response
      // In a real implementation, this would update the database
      res.json({ 
        id: insightId, 
        status: updateData.status,
        message: "Clinical insight updated successfully" 
      });
    } catch (error) {
      console.error("Clinical insight update error:", error);
      res.status(500).json({ error: "Failed to update clinical insight" });
    }
  });

  // Drug Interactions API endpoint
  app.get("/api/clinical/drug-interactions", authMiddleware, async (req: TenantRequest, res) => {
    try {
      // Check role authorization - only non-patient roles can access
      if (req.user?.role === "patient") {
        return res.status(403).json({ error: "Insufficient permissions" });
      }

      const patientId = req.query.patientId ? parseInt(req.query.patientId as string) : null;
      
      // Get all patients if no specific patient ID provided
      let patients = [];
      if (patientId) {
        const patient = await storage.getPatient(patientId, req.tenant!.id);
        if (patient) patients = [patient];
      } else {
        patients = await storage.getPatientsByOrganization(req.tenant!.id);
      }

      const interactions = [];
      
      // First, get manually added patient drug interactions from the new table
      let manualInteractions = [];
      if (patientId) {
        manualInteractions = await db
          .select()
          .from(patientDrugInteractions)
          .where(and(
            eq(patientDrugInteractions.organizationId, req.tenant!.id),
            eq(patientDrugInteractions.patientId, patientId),
            eq(patientDrugInteractions.status, 'active'),
            eq(patientDrugInteractions.isActive, true)
          ));
      } else {
        manualInteractions = await db
          .select()
          .from(patientDrugInteractions)
          .where(and(
            eq(patientDrugInteractions.organizationId, req.tenant!.id),
            eq(patientDrugInteractions.status, 'active'),
            eq(patientDrugInteractions.isActive, true)
          ));
      }

      // Add manual interactions to results
      for (const manualInteraction of manualInteractions) {
        const patient = patients.find(p => p.id === manualInteraction.patientId);
        if (patient) {
          interactions.push({
            id: `manual-${manualInteraction.id}`,
            patientId: patient.id,
            patientName: `${patient.firstName} ${patient.lastName}`,
            medication1: {
              name: manualInteraction.medication1Name,
              dosage: manualInteraction.medication1Dosage || 'Not specified'
            },
            medication2: {
              name: manualInteraction.medication2Name,
              dosage: manualInteraction.medication2Dosage || 'Not specified'
            },
            severity: manualInteraction.severity,
            description: manualInteraction.description || `Interaction between ${manualInteraction.medication1Name} and ${manualInteraction.medication2Name}`,
            warnings: manualInteraction.warnings || [],
            recommendations: manualInteraction.recommendations || [],
            detectedAt: manualInteraction.reportedAt?.toISOString() || manualInteraction.createdAt?.toISOString(),
            source: 'manual'
          });
        }
      }
      
      // Then check for automatic interactions from patient medications
      for (const patient of patients) {
        if (patient.medicalHistory?.medications && patient.medicalHistory.medications.length > 0) {
          const patientMeds = patient.medicalHistory.medications;
          
          // Check for interactions between patient's medications
          for (let i = 0; i < patientMeds.length; i++) {
            for (let j = i + 1; j < patientMeds.length; j++) {
              const med1 = patientMeds[i];
              const med2 = patientMeds[j];
              
              // Skip if medication doesn't have a name
              if (!med1?.name || !med2?.name) {
                continue;
              }
              
              // Query medications database for interaction data
              const [medication1] = await db
                .select()
                .from(medicationsDatabase)
                .where(and(
                  eq(medicationsDatabase.organizationId, req.tenant!.id),
                  sql`lower(${medicationsDatabase.name}) = lower(${sql.raw(`'${med1.name.replace(/'/g, "''")}'`)})`
                ));
              
              if (medication1 && medication1.interactions) {
                const interacts = medication1.interactions.some((interaction: string) => 
                  interaction.toLowerCase().includes(med2.name.toLowerCase())
                );
                
                if (interacts) {
                  interactions.push({
                    id: `${patient.id}-${i}-${j}`,
                    patientId: patient.id,
                    patientName: `${patient.firstName} ${patient.lastName}`,
                    medication1: {
                      name: med1.name,
                      dosage: med1.dosage || 'Not specified'
                    },
                    medication2: {
                      name: med2.name,
                      dosage: med2.dosage || 'Not specified'
                    },
                    severity: medication1.severity,
                    description: `Potential interaction between ${med1.name} and ${med2.name}`,
                    warnings: medication1.warnings || [],
                    recommendations: [
                      'Monitor patient closely for adverse effects',
                      'Consider alternative medications if possible',
                      'Adjust dosage if necessary',
                      'Consult with pharmacist for guidance'
                    ],
                    detectedAt: new Date().toISOString()
                  });
                }
              }
            }
          }
        }
      }

      res.json({
        success: true,
        interactions,
        totalInteractions: interactions.length,
        patientsScanned: patients.length,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error("Drug interactions check error:", error);
      res.status(500).json({ error: "Failed to check drug interactions" });
    }
  });

  // Patient Drug Interactions API endpoints
  app.post("/api/clinical/patient-drug-interactions", authMiddleware, async (req: TenantRequest, res) => {
    try {
      // Check role authorization - only non-patient roles can access
      if (req.user?.role === "patient") {
        return res.status(403).json({ error: "Insufficient permissions" });
      }

      const interactionData = z.object({
        patientId: z.number(),
        medication1Name: z.string(),
        medication1Dosage: z.string().optional(),
        medication1Frequency: z.string().optional(),
        medication2Name: z.string(),
        medication2Dosage: z.string().optional(),
        medication2Frequency: z.string().optional(),
        severity: z.enum(["low", "medium", "high"]).default("medium"),
        description: z.string().optional(),
        warnings: z.array(z.string()).default([]),
        recommendations: z.array(z.string()).default([]),
        notes: z.string().optional()
      }).parse(req.body);

      // Verify patient exists and belongs to organization
      const patient = await storage.getPatient(interactionData.patientId, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Insert into patient_drug_interactions table
      const [newInteraction] = await db
        .insert(patientDrugInteractions)
        .values({
          organizationId: req.tenant!.id,
          patientId: interactionData.patientId,
          medication1Name: interactionData.medication1Name,
          medication1Dosage: interactionData.medication1Dosage || "",
          medication1Frequency: interactionData.medication1Frequency,
          medication2Name: interactionData.medication2Name,
          medication2Dosage: interactionData.medication2Dosage || "",
          medication2Frequency: interactionData.medication2Frequency,
          severity: interactionData.severity,
          description: interactionData.description,
          warnings: interactionData.warnings,
          recommendations: interactionData.recommendations,
          reportedBy: req.user?.id,
          notes: interactionData.notes
        })
        .returning();

      res.json({
        success: true,
        interaction: newInteraction,
        message: "Drug interaction added successfully"
      });
    } catch (error) {
      console.error("Add patient drug interaction error:", error);
      res.status(500).json({ error: "Failed to add drug interaction" });
    }
  });

  // GET endpoint to fetch drug interactions count and list
  app.get("/api/clinical/patient-drug-interactions", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      // Fetch all drug interactions for the organization
      const interactions = await db
        .select()
        .from(patientDrugInteractions)
        .where(eq(patientDrugInteractions.organizationId, organizationId));
      
      res.json({
        success: true,
        count: interactions.length,
        interactions
      });
    } catch (error) {
      console.error("Fetch patient drug interactions error:", error);
      res.status(500).json({ error: "Failed to fetch drug interactions" });
    }
  });

  // Risk Assessment endpoint - analyzes lab results and generates patient risk assessments
  app.get("/api/clinical/risk-assessments", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      // Fetch all lab results with patient data
      const labResults = await storage.getLabResultsByOrganization(organizationId);
      const patients = await storage.getPatientsByOrganization(organizationId);
      
      // Group lab results by patient
      const patientResultsMap = new Map<number, any[]>();
      labResults.forEach(result => {
        if (!patientResultsMap.has(result.patientId)) {
          patientResultsMap.set(result.patientId, []);
        }
        patientResultsMap.get(result.patientId)!.push(result);
      });
      
      const allAssessments = [];
      
      // Analyze each patient's lab results
      for (const [patientId, results] of patientResultsMap.entries()) {
        const patient = patients.find(p => p.id === patientId);
        if (!patient) continue;
        
        // Aggregate all test results from all lab orders
        const allTests: any[] = [];
        let hasCritical = false;
        
        results.forEach(labResult => {
          if (labResult.criticalValues) {
            hasCritical = true;
          }
          if (labResult.results && Array.isArray(labResult.results)) {
            labResult.results.forEach((test: any) => {
              allTests.push({
                testId: labResult.testId,
                testName: test.name,
                value: test.value,
                unit: test.unit,
                status: test.status,
                flag: test.flag,
                referenceRange: test.referenceRange
              });
            });
          }
        });
        
        // Cardiovascular Disease Risk Assessment
        const cvdFactors = [];
        const cvdRecommendations = [];
        let cvdScore = 0;
        
        const cholesterolTest = allTests.find(t => t.testName?.toLowerCase().includes('cholesterol'));
        const glucoseTest = allTests.find(t => t.testName?.toLowerCase().includes('glucose'));
        const hemoglobinA1cTest = allTests.find(t => t.testName?.toLowerCase().includes('hemoglobin a1c') || t.testName?.toLowerCase().includes('a1c'));
        
        if (cholesterolTest && (cholesterolTest.status === 'abnormal_high' || cholesterolTest.flag === 'HIGH')) {
          cvdFactors.push('High cholesterol');
          cvdScore += 5;
          cvdRecommendations.push('Statin therapy');
        }
        
        if (glucoseTest && parseFloat(glucoseTest.value) > 100) {
          cvdFactors.push('Elevated glucose');
          cvdScore += 3;
        }
        
        if (hasCritical) {
          cvdFactors.push('Critical lab values detected');
          cvdScore += 7;
        }
        
        // Age factor (if patient > 65)
        const age = patient.dateOfBirth ? Math.floor((Date.now() - new Date(patient.dateOfBirth).getTime()) / (365.25 * 24 * 60 * 60 * 1000)) : 0;
        if (age > 65) {
          cvdFactors.push('Age >65');
          cvdScore += 5;
        }
        
        if (cvdScore > 0) {
          cvdRecommendations.push('Blood pressure control');
          cvdRecommendations.push('Regular cardiovascular screening');
        }
        
        // Diabetes Risk Assessment
        const diabetesFactors = [];
        const diabetesRecommendations = [];
        let diabetesScore = 0;
        
        if (glucoseTest) {
          const glucoseValue = parseFloat(glucoseTest.value);
          if (glucoseValue >= 126 || glucoseTest.status === 'abnormal_high') {
            diabetesFactors.push('High fasting glucose');
            diabetesScore += 8;
            diabetesRecommendations.push('Immediate diabetes workup');
          } else if (glucoseValue >= 100) {
            diabetesFactors.push('Prediabetes');
            diabetesScore += 4;
            diabetesRecommendations.push('Lifestyle modification');
          }
        }
        
        if (hemoglobinA1cTest) {
          const a1cValue = parseFloat(hemoglobinA1cTest.value);
          if (a1cValue >= 6.5 || hemoglobinA1cTest.status === 'abnormal_high') {
            diabetesFactors.push('Elevated HbA1c');
            diabetesScore += 8;
            diabetesRecommendations.push('Diabetes management');
          } else if (a1cValue >= 5.7) {
            diabetesFactors.push('Borderline HbA1c');
            diabetesScore += 4;
          }
        }
        
        if (diabetesScore > 0) {
          diabetesRecommendations.push('Annual glucose screening');
          diabetesRecommendations.push('Weight management');
          diabetesRecommendations.push('Diet counseling');
        }
        
        // Determine risk levels
        const getCvdRiskLevel = (score: number): 'low' | 'moderate' | 'high' | 'critical' => {
          if (score >= 15) return 'critical';
          if (score >= 10) return 'high';
          if (score >= 5) return 'moderate';
          return 'low';
        };
        
        const getDiabetesRiskLevel = (score: number): 'low' | 'moderate' | 'high' | 'critical' => {
          if (score >= 12) return 'critical';
          if (score >= 8) return 'high';
          if (score >= 4) return 'moderate';
          return 'low';
        };
        
        // Save and return assessments if there are risk factors
        if (cvdFactors.length > 0) {
          const cvdAssessment = await storage.createRiskAssessment({
            organizationId,
            patientId,
            category: 'Cardiovascular Disease',
            riskScore: cvdScore.toString(),
            riskLevel: getCvdRiskLevel(cvdScore),
            riskFactors: cvdFactors,
            recommendations: cvdRecommendations,
            basedOnLabResults: allTests.slice(0, 5),
            hasCriticalValues: hasCritical,
            assessmentDate: new Date()
          });
          allAssessments.push({
            ...cvdAssessment,
            patientName: `${patient.firstName} ${patient.lastName}`
          });
        }
        
        if (diabetesFactors.length > 0) {
          const diabetesAssessment = await storage.createRiskAssessment({
            organizationId,
            patientId,
            category: 'Diabetes',
            riskScore: diabetesScore.toString(),
            riskLevel: getDiabetesRiskLevel(diabetesScore),
            riskFactors: diabetesFactors,
            recommendations: diabetesRecommendations,
            basedOnLabResults: allTests.slice(0, 5),
            hasCriticalValues: hasCritical,
            assessmentDate: new Date()
          });
          allAssessments.push({
            ...diabetesAssessment,
            patientName: `${patient.firstName} ${patient.lastName}`
          });
        }
      }
      
      // Fetch all existing assessments from database (including the ones just created)
      const allSavedAssessments = await storage.getRiskAssessmentsByOrganization(organizationId);
      
      // Add patient details to saved assessments
      const assessmentsWithDetails = allSavedAssessments.map(assessment => {
        const patient = patients.find(p => p.id === assessment.patientId);
        
        // Calculate age if patient has date of birth
        let age = null;
        if (patient?.dateOfBirth) {
          const birthDate = new Date(patient.dateOfBirth);
          const today = new Date();
          age = today.getFullYear() - birthDate.getFullYear();
          const monthDiff = today.getMonth() - birthDate.getMonth();
          if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
            age--;
          }
        }
        
        return {
          ...assessment,
          patientName: patient ? `${patient.firstName} ${patient.lastName}` : `Patient ${assessment.patientId}`,
          patientAge: age,
          patientGender: patient?.genderAtBirth || null,
          patientDateOfBirth: patient?.dateOfBirth || null,
          assessmentDate: assessment.assessmentDate || assessment.createdAt
        };
      });
      
      // Transform for frontend
      const transformedAssessments = assessmentsWithDetails.map((assessment: any) => ({
        category: assessment.category,
        score: parseFloat(assessment.riskScore),
        risk: assessment.riskLevel,
        factors: assessment.riskFactors || [],
        recommendations: assessment.recommendations || [],
        patientId: assessment.patientId,
        patientName: assessment.patientName,
        patientAge: assessment.patientAge,
        patientGender: assessment.patientGender,
        patientDateOfBirth: assessment.patientDateOfBirth,
        assessmentDate: assessment.assessmentDate
      }));
      
      res.json(transformedAssessments);
    } catch (error) {
      console.error("Risk assessments error:", error);
      res.status(500).json({ error: "Failed to generate risk assessments" });
    }
  });

  // AI-powered Lab Result Assessment
  app.post("/api/lab-results/:labResultId/assess", authMiddleware, requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const labResultId = parseInt(req.params.labResultId);
      
      // Fetch the lab result
      const labResult = await storage.getLabResult(labResultId, organizationId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }
      
      // Get patient details
      const patient = await storage.getPatient(labResult.patientId, organizationId);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      
      // Prepare lab results for OpenAI analysis
      const labResultsText = labResult.results.map((result: any) => 
        `${result.name}: ${result.value} ${result.unit} (Reference: ${result.referenceRange}, Status: ${result.status})`
      ).join('\n');
      
      // Try to use OpenAI for analysis, fallback to rule-based analysis if it fails
      let analysis;
      
      try {
        // Call OpenAI API for analysis using SDK (same as aiService)
        if (!process.env.OPENAI_API_KEY) {
          throw new Error("OpenAI API key not configured");
        }
        
        const completion = await openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [
            {
              role: 'system',
              content: 'You are a medical AI assistant specializing in analyzing lab results and identifying health risks. Provide concise, evidence-based risk factors and recommendations.'
            },
            {
              role: 'user',
              content: `Analyze the following lab results for a ${patient.genderAtBirth || 'patient'} patient and identify potential health risks and recommendations:\n\nLab Results:\n${labResultsText}\n\nProvide your analysis in the following JSON format:\n{\n  "riskFactors": ["factor1", "factor2", ...],\n  "recommendations": ["recommendation1", "recommendation2", ...],\n  "riskCategory": "Cardiovascular Disease|Diabetes|Kidney Disease|Liver Disease|Thyroid Disorder|Other",\n  "riskLevel": "low|moderate|high|critical",\n  "riskScore": number (0-100)\n}`
            }
          ],
          temperature: 0.3,
          max_tokens: 1000
        });
        
        const aiContent = completion.choices[0].message.content;
        analysis = JSON.parse(aiContent);
        console.log("[LAB-ASSESSMENT] OpenAI analysis succeeded");
      } catch (aiError) {
        console.log("[LAB-ASSESSMENT] OpenAI failed, using rule-based analysis");
        console.error("[LAB-ASSESSMENT] OpenAI Error:", (aiError as Error)?.message || aiError);
        
        // Fallback: Rule-based analysis of lab results
        const abnormalResults = labResult.results.filter((r: any) => r.status !== 'normal');
        const criticalResults = labResult.results.filter((r: any) => r.flag === 'critical' || r.flag === 'high' || r.flag === 'low');
        
        // Determine risk category based on test type
        let category = 'Other';
        let riskFactors: string[] = [];
        let recommendations: string[] = [];
        
        if (labResult.testType.toLowerCase().includes('glucose') || labResult.testType.toLowerCase().includes('hba1c') || labResult.testType.toLowerCase().includes('diabetes')) {
          category = 'Diabetes';
          riskFactors = abnormalResults.length > 0 ? ['Abnormal glucose metabolism indicators detected'] : ['Lab results within acceptable range'];
          recommendations = abnormalResults.length > 0 ? ['Diabetes screening', 'Dietary consultation', 'Regular glucose monitoring'] : ['Continue regular monitoring'];
        } else if (labResult.testType.toLowerCase().includes('lipid') || labResult.testType.toLowerCase().includes('cholesterol') || labResult.testType.toLowerCase().includes('cardiovascular')) {
          category = 'Cardiovascular Disease';
          riskFactors = abnormalResults.length > 0 ? ['Abnormal lipid profile detected'] : ['Cardiovascular markers within range'];
          recommendations = abnormalResults.length > 0 ? ['Cardiology consultation', 'Lifestyle modifications', 'Regular monitoring'] : ['Maintain healthy lifestyle'];
        } else if (labResult.testType.toLowerCase().includes('kidney') || labResult.testType.toLowerCase().includes('renal') || labResult.testType.toLowerCase().includes('creatinine')) {
          category = 'Kidney Disease';
          riskFactors = abnormalResults.length > 0 ? ['Abnormal kidney function markers'] : ['Kidney function within normal range'];
          recommendations = abnormalResults.length > 0 ? ['Nephrology consultation', 'Hydration monitoring', 'Regular kidney function tests'] : ['Continue routine monitoring'];
        } else if (labResult.testType.toLowerCase().includes('liver') || labResult.testType.toLowerCase().includes('hepatic')) {
          category = 'Liver Disease';
          riskFactors = abnormalResults.length > 0 ? ['Abnormal liver function tests'] : ['Liver function within normal limits'];
          recommendations = abnormalResults.length > 0 ? ['Hepatology consultation', 'Avoid hepatotoxic substances', 'Follow-up testing'] : ['Maintain liver health'];
        } else {
          riskFactors = abnormalResults.length > 0 ? [`${abnormalResults.length} abnormal result(s) detected`] : ['All results within normal range'];
          recommendations = abnormalResults.length > 0 ? ['Consult with healthcare provider', 'Follow-up testing as needed'] : ['Continue routine health monitoring'];
        }
        
        // Determine risk level and score
        let riskLevel = 'low';
        let riskScore = 20;
        
        if (criticalResults.length > 0) {
          riskLevel = 'critical';
          riskScore = 85;
        } else if (abnormalResults.length >= 3) {
          riskLevel = 'high';
          riskScore = 70;
        } else if (abnormalResults.length > 0) {
          riskLevel = 'moderate';
          riskScore = 45;
        }
        
        analysis = {
          riskCategory: category,
          riskFactors,
          recommendations,
          riskLevel,
          riskScore
        };
      }
      
      // Save risk assessment to database
      const riskAssessment = await storage.createRiskAssessment({
        organizationId,
        patientId: labResult.patientId,
        category: analysis.riskCategory || 'Other',
        riskScore: analysis.riskScore.toString(),
        riskLevel: analysis.riskLevel,
        riskFactors: analysis.riskFactors || [],
        recommendations: analysis.recommendations || [],
        basedOnLabResults: labResult.results.map((r: any) => ({
          testId: labResult.testId,
          testName: r.name,
          value: r.value,
          status: r.status,
          flag: r.flag
        })),
        hasCriticalValues: labResult.criticalValues,
        assessmentDate: new Date()
      });
      
      res.json({
        success: true,
        assessment: {
          id: riskAssessment.id,
          category: riskAssessment.category,
          riskLevel: riskAssessment.riskLevel,
          riskScore: parseFloat(riskAssessment.riskScore),
          riskFactors: riskAssessment.riskFactors,
          recommendations: riskAssessment.recommendations,
          assessmentDate: riskAssessment.assessmentDate
        }
      });
    } catch (error) {
      console.error("Lab result assessment error:", error);
      res.status(500).json({ error: "Failed to assess lab results" });
    }
  });

  // Get all lab results for an organization
  app.get("/api/lab-results", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      // Get all patients for this organization
      const patients = await storage.getPatientsByOrganization(organizationId);
      const patientIds = patients.map(p => p.id);
      
      // Get lab results for all patients
      const allLabResults = [];
      for (const patientId of patientIds) {
        const labResults = await storage.getLabResultsByPatient(patientId, organizationId);
        allLabResults.push(...labResults);
      }
      
      // Get users (doctors) to map testOrderedBy
      const users = await storage.getUsersByOrganization(organizationId);
      
      // Enrich with patient and doctor names
      const enrichedResults = allLabResults.map(lr => {
        const patient = patients.find(p => p.id === lr.patientId);
        const doctor = users.find(u => u.id === lr.orderedBy);
        
        return {
          id: lr.id,
          testId: lr.testId,
          testType: lr.testType,
          patientId: lr.patientId,
          patientName: patient ? `${patient.firstName} ${patient.lastName}` : `Patient ${lr.patientId}`,
          doctorName: doctor ? (doctor.firstName && doctor.lastName ? `${doctor.firstName} ${doctor.lastName}` : doctor.email) : (lr.doctorName || `Doctor ${lr.orderedBy}`),
          testDate: lr.orderedAt,
          results: lr.results,
          criticalValues: lr.criticalValues,
          // Tab filtering fields
          labRequestGenerated: lr.labRequestGenerated || false,
          labReportGenerated: lr.labReportGenerated || false,
          sampleCollected: lr.sampleCollected || false,
          reviewed: lr.reviewed || false,
          // Additional fields for the lab results page
          reportStatus: lr.reportStatus,
          status: lr.status,
          notes: lr.notes,
          priority: lr.priority,
          orderedAt: lr.orderedAt,
          collectedAt: lr.collectedAt,
          completedAt: lr.completedAt,
          signatureData: lr.signatureData,
          orderedBy: lr.orderedBy,
          mainSpecialty: lr.mainSpecialty,
          subSpecialty: lr.subSpecialty
        };
      });
      
      res.json(enrichedResults);
    } catch (error) {
      console.error("Get all lab results error:", error);
      res.status(500).json({ error: "Failed to fetch lab results" });
    }
  });

  // Get lab results for a specific patient
  app.get("/api/patients/:patientId/lab-results", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const patientId = parseInt(req.params.patientId);
      
      const labResults = await storage.getLabResultsByPatient(patientId);
      
      // Filter by organization
      const filteredResults = labResults.filter(lr => lr.organizationId === organizationId);
      
      res.json(filteredResults);
    } catch (error) {
      console.error("Get lab results error:", error);
      res.status(500).json({ error: "Failed to fetch lab results" });
    }
  });

  // Organization settings routes
  app.get("/api/organization/settings", requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const organization = await storage.getOrganization(req.tenant!.id);
      if (!organization) {
        return res.status(404).json({ error: "Organization not found" });
      }
      
      res.json({
        name: organization.name,
        region: organization.region,
        brandName: organization.brandName,
        settings: organization.settings
      });
    } catch (error) {
      console.error("Settings fetch error:", error);
      res.status(500).json({ error: "Failed to fetch settings" });
    }
  });

  // Prescription Management Routes
  app.get("/api/prescriptions", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      // Check for role-based filtering via query parameters
      const { patientId, providerId } = req.query;

      let prescriptions;

      if (patientId) {
        // Filter by patient ID (for Patient role)
        const patientIdNum = parseInt(patientId as string);
        if (isNaN(patientIdNum)) {
          return res.status(400).json({ error: "Invalid patient ID" });
        }
        console.log(`[PRESCRIPTIONS API] Filtering by patientId: ${patientIdNum}`);
        prescriptions = await storage.getPrescriptionsByPatient(patientIdNum, req.tenant!.id);
      } else if (providerId) {
        // Filter by provider ID (for Doctor role)
        const providerIdNum = parseInt(providerId as string);
        if (isNaN(providerIdNum)) {
          return res.status(400).json({ error: "Invalid provider ID" });
        }
        console.log(`[PRESCRIPTIONS API] Filtering by providerId: ${providerIdNum}`);
        prescriptions = await storage.getPrescriptionsByProvider(providerIdNum, req.tenant!.id);
      } else {
        // Return all prescriptions (for Admin, Nurse, etc.)
        console.log(`[PRESCRIPTIONS API] Returning all prescriptions for organization`);
        prescriptions = await storage.getPrescriptionsByOrganization(req.tenant!.id);
      }

      res.json(prescriptions);
    } catch (error) {
      console.error("Error fetching prescriptions:", error);
      res.status(500).json({ error: "Failed to fetch prescriptions" });
    }
  });

  // Get prescriptions by patient ID
  app.get("/api/prescriptions/patient/:patientId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const patientId = parseInt(req.params.patientId);
      if (isNaN(patientId)) {
        return res.status(400).json({ error: "Invalid patient ID" });
      }

      const prescriptions = await storage.getPrescriptionsByPatient(patientId, req.tenant!.id);
      res.json(prescriptions);
    } catch (error) {
      console.error("Error fetching prescriptions for patient:", error);
      res.status(500).json({ error: "Failed to fetch prescriptions for patient" });
    }
  });

  app.post("/api/prescriptions", authMiddleware, async (req: TenantRequest, res) => {
    console.log("POST /api/prescriptions endpoint reached!");
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const prescriptionData = req.body;
      console.log("=== PRESCRIPTION CREATION DEBUG ===");
      console.log("Full request body:", JSON.stringify(prescriptionData, null, 2));
      console.log("Authenticated user:", {
        id: req.user.id,
        email: req.user.email,
        role: req.user.role
      });
      console.log("Original providerId from form:", prescriptionData.providerId);
      
      // Validate required fields
      if (!prescriptionData.patientId || isNaN(parseInt(prescriptionData.patientId))) {
        return res.status(400).json({ error: "Valid patient ID is required" });
      }
      
      if (!prescriptionData.providerId || isNaN(parseInt(prescriptionData.providerId))) {
        return res.status(400).json({ error: "Valid provider ID is required" });
      }
      
      // Use the selected provider ID from the form
      const providerId = parseInt(prescriptionData.providerId);
      console.log("Using selected provider ID:", providerId);
      
      // Check for duplicate prescriptions only if created_at timestamp is exactly the same
      // This prevents accidental double-clicks but allows duplicates at different times
      const existingPrescriptions = await storage.getPrescriptionsByOrganization(req.tenant!.id);
      
      const isDuplicate = existingPrescriptions.some(existing => {
        const existingCreatedAt = existing.createdAt ? new Date(existing.createdAt).getTime() : 0;
        const newCreatedAt = new Date().getTime();
        
        // Only reject if created_at timestamps are exactly the same (same millisecond)
        // This handles double-click scenarios while allowing legitimate duplicates at different times
        return existing.patientId === parseInt(prescriptionData.patientId) &&
          existing.status === 'active' &&
          existingCreatedAt === newCreatedAt &&
          existing.medications?.some(med => 
            prescriptionData.medications?.some((newMed: any) => 
              newMed.name === med.name && 
              newMed.dosage === med.dosage
            )
          );
      });
      
      if (isDuplicate) {
        return res.status(400).json({ error: "A duplicate prescription was just created at the exact same time. Please try again." });
      }
      
      // Extract first medication for legacy columns (required for backward compatibility)
      const firstMedication = prescriptionData.medications?.[0] || {};
      
      // Create prescription data for database (with enforced created_by)
      const prescriptionToInsert = enforceCreatedBy(req, {
        organizationId: req.tenant!.id,
        patientId: parseInt(prescriptionData.patientId),
        doctorId: providerId,
        prescriptionNumber: `RX-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`,
        status: prescriptionData.status || "active",
        diagnosis: prescriptionData.diagnosis,
        // Legacy columns (for backward compatibility with database constraints)
        medicationName: firstMedication.name || 'Not specified',
        dosage: firstMedication.dosage || '',
        frequency: firstMedication.frequency || '',
        duration: firstMedication.duration || '',
        instructions: firstMedication.instructions || '',
        // Modern JSONB columns
        medications: prescriptionData.medications || [],
        pharmacy: prescriptionData.pharmacy || {},
        notes: prescriptionData.notes,
        validUntil: prescriptionData.validUntil ? new Date(prescriptionData.validUntil) : null,
        interactions: prescriptionData.interactions || []
      }, 'prescriptionCreatedBy');

      console.log("About to create prescription with data:", prescriptionToInsert);
      const newPrescription = await storage.createPrescription(prescriptionToInsert);
      console.log("Prescription created successfully:", newPrescription.id);
      
      // Send notification to patient about new prescription
      const patient = await storage.getPatient(parseInt(prescriptionData.patientId), req.tenant!.id);
      const provider = await storage.getUser(providerId, req.tenant!.id);
      
      if (patient && patient.userId && provider) {
        const medications = prescriptionData.medications || [];
        const medicationNames = medications.map((med: any) => med.name).join(', ') || firstMedication.name;
        
        await createNotification({
          organizationId: req.tenant!.id,
          userId: patient.userId,
          title: "New Prescription Available",
          message: `Dr. ${provider.firstName} ${provider.lastName} has prescribed ${medicationNames}. Please collect from your pharmacy.`,
          type: "prescription_alert",
          priority: "normal",
          actionUrl: `/prescriptions`,
          metadata: {
            patientId: patient.id,
            patientName: `${patient.firstName} ${patient.lastName}`,
            prescriptionId: newPrescription.id,
            department: "Pharmacy",
          }
        });
      }
      
      res.status(201).json(newPrescription);
    } catch (error: any) {
      console.error("DETAILED ERROR creating prescription:", error);
      console.error("Error message:", error?.message);
      console.error("Error stack:", error?.stack);
      if (error?.code) {
        console.error("Error code:", error.code);
      }
      res.status(500).json({ error: "Failed to create prescription", details: error?.message });
    }
  });

  app.patch("/api/prescriptions/:id", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const prescriptionId = parseInt(req.params.id);
      const prescriptionData = req.body;
      
      // Build update object with only provided fields to avoid overwriting existing data
      const prescriptionUpdates: any = {};
      
      if (prescriptionData.status !== undefined) {
        prescriptionUpdates.status = prescriptionData.status;
      }
      if (prescriptionData.diagnosis !== undefined) {
        prescriptionUpdates.diagnosis = prescriptionData.diagnosis;
      }
      if (prescriptionData.medications !== undefined) {
        prescriptionUpdates.medications = prescriptionData.medications;
      }
      if (prescriptionData.pharmacy !== undefined) {
        prescriptionUpdates.pharmacy = prescriptionData.pharmacy;
      }
      if (prescriptionData.notes !== undefined) {
        prescriptionUpdates.notes = prescriptionData.notes;
      }
      if (prescriptionData.validUntil !== undefined) {
        prescriptionUpdates.validUntil = prescriptionData.validUntil ? new Date(prescriptionData.validUntil) : null;
      }
      if (prescriptionData.interactions !== undefined) {
        prescriptionUpdates.interactions = prescriptionData.interactions;
      }

      const updatedPrescription = await storage.updatePrescription(prescriptionId, req.tenant!.id, prescriptionUpdates);
      
      if (!updatedPrescription) {
        return res.status(404).json({ error: "Prescription not found" });
      }

      res.json(updatedPrescription);
    } catch (error) {
      console.error("Error updating prescription:", error);
      res.status(500).json({ error: "Failed to update prescription" });
    }
  });

  // Send prescription to pharmacy as PDF
  app.post("/api/prescriptions/:id/send-to-pharmacy", authMiddleware, requireRole(["doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const prescriptionId = parseInt(req.params.id);
      const { pharmacyData } = req.body;
      
      // Get prescription details
      const prescription = await storage.getPrescription(prescriptionId, req.tenant!.id);
      if (!prescription) {
        return res.status(404).json({ error: "Prescription not found" });
      }

      // Get patient details
      const patient = await storage.getPatient(prescription.patientId, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Get prescribing doctor details
      const doctor = await storage.getUser(prescription.doctorId, req.tenant!.id);
      if (!doctor) {
        return res.status(404).json({ error: "Doctor not found" });
      }

      // Update prescription with pharmacy information
      await storage.updatePrescription(prescriptionId, req.tenant!.id, {
        pharmacy: pharmacyData
      });

      // Get clinic header and footer for email
      const clinicHeader = await storage.getActiveClinicHeader(req.tenant!.id);
      const clinicFooter = await storage.getActiveClinicFooter(req.tenant!.id);

      // Generate email HTML with clinic branding
      const patientName = `${patient.firstName} ${patient.lastName}`;
      const emailHTML = generatePrescriptionEmailHTML(patientName, clinicHeader, clinicFooter);

      // Send email to pharmacy
      const emailSent = await sendEmail({
        to: pharmacyData.email || 'pharmacy@halohealth.com',
        from: process.env.SENDGRID_FROM_EMAIL || 'noreply@curaemr.ai',
        subject: `Prescription for ${patientName}`,
        html: emailHTML,
        text: `Please find attached the electronic prescription for ${patientName}.`
      });

      if (!emailSent) {
        return res.status(500).json({ error: "Failed to send email to pharmacy" });
      }

      res.json({ 
        success: true,
        message: "Prescription successfully sent to Halo Health pharmacy",
        pharmacy: pharmacyData,
        sentAt: new Date().toISOString()
      });
    } catch (error) {
      console.error("Error sending prescription to pharmacy:", error);
      res.status(500).json({ error: "Failed to send prescription to pharmacy" });
    }
  });

  app.delete("/api/prescriptions/:id", authMiddleware, requireRole(["admin", "doctor", "nurse", "paramedic", "optician", "lab_technician", "pharmacist", "dentist", "dental_nurse", "phlebotomist", "aesthetician", "podiatrist", "physiotherapist", "physician"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const prescriptionId = parseInt(req.params.id);
      
      const deletedPrescription = await storage.deletePrescription(prescriptionId, req.tenant!.id);
      
      if (!deletedPrescription) {
        return res.status(404).json({ error: "Prescription not found" });
      }

      res.json({ message: "Prescription deleted successfully", id: prescriptionId });
    } catch (error) {
      console.error("Error deleting prescription:", error);
      res.status(500).json({ error: "Failed to delete prescription" });
    }
  });

  // E-signature endpoint for prescriptions - allow all doctor-like roles, nurses, and admins to sign
  app.post("/api/prescriptions/:id/e-sign", authMiddleware, requireRole(["admin", "doctor", "nurse", "paramedic", "optician", "lab_technician", "pharmacist", "dentist", "dental_nurse", "phlebotomist", "aesthetician", "podiatrist", "physiotherapist", "physician"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const prescriptionId = parseInt(req.params.id);
      const { signature } = req.body;
      
      if (!signature) {
        return res.status(400).json({ error: "Signature data is required" });
      }

      // Get prescription to verify it exists
      const prescription = await storage.getPrescription(prescriptionId, req.tenant!.id);
      if (!prescription) {
        return res.status(404).json({ error: "Prescription not found" });
      }

      // Create signature data
      const signatureData = {
        doctorSignature: signature,
        signedBy: `${(req.user as any).firstName || ''} ${(req.user as any).lastName || ''}`,
        signedAt: new Date().toISOString(),
        signerId: req.user.id
      };

      // Update prescription with signature
      const updatedPrescription = await storage.updatePrescription(prescriptionId, req.tenant!.id, {
        signature: signatureData,
        status: 'signed'
      });
      
      if (!updatedPrescription) {
        return res.status(404).json({ error: "Failed to update prescription with signature" });
      }

      res.json({ 
        success: true,
        message: "Prescription e-signed successfully",
        signature: signatureData,
        prescription: updatedPrescription
      });
    } catch (error) {
      console.error("Error e-signing prescription:", error);
      res.status(500).json({ error: "Failed to e-sign prescription" });
    }
  });

  // Lab Results Routes
  app.get("/api/lab-results", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      // Check for role-based filtering via query parameters
      const { patientId } = req.query;

      let labResults;

      if (patientId) {
        // Filter by patient ID (for Patient role)
        const patientIdNum = parseInt(patientId as string);
        if (isNaN(patientIdNum)) {
          return res.status(400).json({ error: "Invalid patient ID" });
        }
        console.log(`[LAB RESULTS API] Filtering by patientId: ${patientIdNum}`);
        labResults = await storage.getLabResultsByPatient(patientIdNum, req.tenant!.id);
      } else {
        // Return all lab results (for Admin, Doctor, Nurse, etc.)
        console.log(`[LAB RESULTS API] Returning all lab results for organization`);
        labResults = await storage.getLabResultsByOrganization(req.tenant!.id);
      }

      // Enrich with invoice information (paymentMethod, insuranceProvider)
      const enrichedLabResults = await Promise.all(labResults.map(async (labResult: any) => {
        // Find related invoice using serviceId matching testId
        const invoices = await db
          .select()
          .from(schema.invoices)
          .where(eq(schema.invoices.serviceId, labResult.testId));
        
        const invoice = invoices[0]; // Get the first matching invoice
        
        return {
          ...labResult,
          paymentMethod: invoice?.paymentMethod || null,
          insuranceProvider: invoice?.insuranceProvider || null
        };
      }));

      res.json(enrichedLabResults);
    } catch (error) {
      console.error("Error fetching lab results:", error);
      res.status(500).json({ error: "Failed to fetch lab results" });
    }
  });

  app.post("/api/lab-results", authMiddleware, requireRole(["admin", "doctor", "nurse", "paramedic", "optician", "lab_technician", "pharmacist", "dentist", "dental_nurse", "phlebotomist", "aesthetician", "podiatrist", "physiotherapist", "physician"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const labData = req.body;
      
      // Generate unique test ID
      const testId = `LAB${Date.now()}${Math.random().toString(36).substr(2, 5).toUpperCase()}`;
      
      // Convert patientId from string to number if needed
      const patientId = typeof labData.patientId === 'string' ? 
        parseInt(labData.patientId) || null : 
        labData.patientId;
      
      if (!patientId) {
        return res.status(400).json({ error: "Valid patient ID is required" });
      }
      
      const newLabResult = await storage.createLabResult(enforceCreatedBy(req, {
        organizationId: req.tenant!.id,
        patientId: patientId,
        testId: testId,
        testType: labData.testType,
        doctorName: labData.selectedUserName || null,
        mainSpecialty: null,
        subSpecialty: null,
        priority: labData.priority || "routine",
        orderedAt: new Date(),
        status: "pending",
        reportStatus: "Lab Request Generated",
        Lab_Request_Generated: true,
        notes: labData.notes || null
      }, 'orderedBy'));

      res.status(201).json(newLabResult);
    } catch (error) {
      console.error("Error creating lab order:", error);
      res.status(500).json({ error: "Failed to create lab order" });
    }
  });

  // Update lab result
  app.put("/api/lab-results/:id", authMiddleware, requireNonPatientRole(), async (req: TenantRequest, res) => {
    try {
      console.log('[LAB-RESULTS-UPDATE] Request user:', {
        userId: req.user?.id,
        userEmail: req.user?.email,
        userRole: req.user?.role,
        hasUser: !!req.user
      });

      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { id } = req.params;
      const updateData = req.body;
      
      // Convert patientId from string to number if needed
      if (updateData.patientId) {
        updateData.patientId = typeof updateData.patientId === 'string' ? 
          parseInt(updateData.patientId) || null : 
          updateData.patientId;
      }

      const updatedLabResult = await storage.updateLabResult(parseInt(id), req.tenant!.id, updateData);

      if (!updatedLabResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      // Send notification when lab result is completed (check persisted status, case-insensitive)
      if (updatedLabResult.status && updatedLabResult.status.toLowerCase() === "completed" && updatedLabResult.patientId) {
        const patient = await storage.getPatient(updatedLabResult.patientId, req.tenant!.id);
        
        if (patient) {
          const notificationsToCreate = [];
          
          // Notify patient
          if (patient.userId) {
            notificationsToCreate.push({
              organizationId: req.tenant!.id,
              userId: patient.userId,
              title: "Lab Results Ready",
              message: `Your ${updatedLabResult.testType} test results are now available.`,
              type: "lab_result" as const,
              priority: updatedLabResult.priority === "urgent" ? "high" as const : "normal" as const,
              actionUrl: `/lab-results`,
              metadata: {
                patientId: patient.id,
                patientName: `${patient.firstName} ${patient.lastName}`,
                department: "Laboratory",
              }
            });
          }
          
          // Notify ordering doctor if specified
          if (updatedLabResult.orderedBy) {
            notificationsToCreate.push({
              organizationId: req.tenant!.id,
              userId: updatedLabResult.orderedBy,
              title: "Lab Results Completed",
              message: `${updatedLabResult.testType} results for ${patient.firstName} ${patient.lastName} are ready.`,
              type: "lab_result" as const,
              priority: updatedLabResult.priority === "urgent" ? "high" as const : "normal" as const,
              actionUrl: `/lab-results`,
              metadata: {
                patientId: patient.id,
                patientName: `${patient.firstName} ${patient.lastName}`,
                department: "Laboratory",
              }
            });
          }
          
          if (notificationsToCreate.length > 0) {
            await createBulkNotifications(notificationsToCreate);
          }
        }
      }

      res.json(updatedLabResult);
    } catch (error) {
      console.error("Error updating lab result:", error);
      res.status(500).json({ error: "Failed to update lab result" });
    }
  });

  app.delete("/api/lab-results/:id", authMiddleware, requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      const labResultId = parseInt(req.params.id);
      
      if (isNaN(labResultId)) {
        return res.status(400).json({ error: "Invalid lab result ID" });
      }
      
      // Verify lab result exists and belongs to organization
      const labResults = await storage.getLabResults(req.tenant!.id);
      const labResult = labResults.find(result => result.id === labResultId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      const deleted = await storage.deleteLabResult(labResultId, req.tenant!.id);
      
      if (!deleted) {
        return res.status(404).json({ error: "Failed to delete lab result" });
      }

      res.json({ success: true, message: "Lab result deleted successfully" });
    } catch (error) {
      console.error("Lab result deletion error:", error);
      res.status(500).json({ error: "Failed to delete lab result" });
    }
  });

  // Lab Technician Dashboard - Get tests ready for result generation
  app.get("/api/lab-technician/tests", authMiddleware, requireRole(["lab_technician", "admin"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const organizationId = req.tenant!.id;

      // Query lab_results joined with patients and invoices (LEFT JOIN to get all results)
      const query = `
        SELECT DISTINCT ON (lr.id)
          lr.id,
          lr.test_id as "testId",
          lr.test_type as "testType",
          lr.ordered_by as "orderedBy",
          lr.doctor_name as "doctorName",
          lr.priority,
          lr.ordered_at as "orderedAt",
          lr.status,
          lr.patient_id as "patientId",
          lr."Sample_Collected" as "sampleCollected",
          lr."Lab_Report_Generated" as "labReportGenerated",
          CONCAT(p.first_name, ' ', p.last_name) as "patientName",
          p.nhs_number as "nhsNumber",
          p.email as "patientEmail",
          i.status as "invoiceStatus",
          i.invoice_number as "invoiceNumber"
        FROM lab_results lr
        INNER JOIN patients p ON lr.patient_id = p.id AND p.organization_id = $1
        LEFT JOIN invoices i ON i.service_id = lr.test_id 
          AND i.service_type = 'lab_result'
          AND i.organization_id = $1
        WHERE lr.organization_id = $1
        ORDER BY lr.id, lr.ordered_at DESC
      `;

      const result = await pool.query(query, [organizationId]);

      res.json(result.rows);
    } catch (error) {
      console.error("Error fetching lab technician tests:", error);
      res.status(500).json({ error: "Failed to fetch lab technician tests" });
    }
  });

  // Collect sample - Mark sample as collected
  app.post("/api/lab-results/:id/collect-sample", authMiddleware, requireRole(["admin", "sample_taker", "nurse", "lab_technician"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const labResultId = parseInt(req.params.id);
      if (isNaN(labResultId)) {
        return res.status(400).json({ error: "Invalid lab result ID" });
      }

      const { notes } = req.body;

      // Fetch the lab result
      const labResults = await storage.getLabResults(req.tenant!.id);
      const labResult = labResults.find(result => result.id === labResultId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      // Check if sample is already collected
      if (labResult.Sample_Collected === true) {
        return res.status(400).json({ error: "Sample already collected" });
      }

      // Update the lab result to mark sample as collected
      const updateData: any = {
        Sample_Collected: true,
        status: "Sample Collected",
        reportStatus: "Sample Ready for Testing"
      };

      // Add collection notes if provided
      if (notes) {
        updateData.notes = labResult.notes 
          ? `${labResult.notes}\n\nCollection Notes (${new Date().toLocaleString()}): ${notes}`
          : `Collection Notes (${new Date().toLocaleString()}): ${notes}`;
      }

      const updatedLabResult = await storage.updateLabResult(labResultId, req.tenant!.id, updateData);

      if (!updatedLabResult) {
        return res.status(404).json({ error: "Failed to update lab result" });
      }

      res.json({ 
        success: true, 
        message: "Sample collected successfully",
        labResult: updatedLabResult 
      });
    } catch (error) {
      console.error("Error collecting sample:", error);
      res.status(500).json({ error: "Failed to collect sample" });
    }
  });

  // Toggle Sample_Collected status
  app.patch("/api/lab-results/:id/toggle-sample-collected", authMiddleware, requireRole(["admin", "sample_taker", "nurse", "lab_technician"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const labResultId = parseInt(req.params.id);
      if (isNaN(labResultId)) {
        return res.status(400).json({ error: "Invalid lab result ID" });
      }

      const { sampleCollected } = req.body;

      if (typeof sampleCollected !== 'boolean') {
        return res.status(400).json({ error: "sampleCollected must be a boolean" });
      }

      // Fetch the lab result
      const labResults = await storage.getLabResults(req.tenant!.id);
      const labResult = labResults.find(result => result.id === labResultId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      // Update the lab result using direct pool query
      const result = await pool.query(
        'UPDATE lab_results SET "Sample_Collected" = $1 WHERE id = $2 AND organization_id = $3 RETURNING *',
        [sampleCollected, labResultId, req.tenant!.id]
      );

      const updatedLabResult = result.rows[0];

      if (!updatedLabResult) {
        return res.status(404).json({ error: "Failed to update lab result" });
      }

      res.json({ 
        success: true, 
        message: `Sample marked as ${sampleCollected ? 'collected' : 'not collected'}`,
        labResult: updatedLabResult 
      });
    } catch (error) {
      console.error("Error toggling sample collected status:", error);
      res.status(500).json({ error: "Failed to update sample collection status" });
    }
  });

  // Get lab results joined with invoices for sample taker dashboard
  app.get("/api/lab-results/with-invoices", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const organizationId = req.tenant!.id;

      // Fetch lab results and invoices
      const labResults = await storage.getLabResults(organizationId);
      const allInvoices = await storage.getInvoicesByOrganization(organizationId);

      // Filter invoices to only include paid invoices with serviceType = "lab_result"
      const paidLabInvoices = allInvoices.filter(invoice => 
        invoice.status === 'paid' && invoice.serviceType === 'lab_result'
      );

      // Join lab results with paid invoices using polymorphic association
      const joinedData = labResults.map(labResult => {
        // Find matching paid invoice using polymorphic association (service_type + service_id matching testId)
        const matchingInvoice = paidLabInvoices.find(invoice => 
          invoice.serviceId === labResult.testId
        );

        return {
          ...labResult,
          invoice: matchingInvoice || null,
          invoiceNumber: matchingInvoice?.invoiceNumber || null,
          invoiceStatus: matchingInvoice?.status || null,
          totalAmount: matchingInvoice?.totalAmount || null,
          invoiceDate: matchingInvoice?.invoiceDate || null,
          serviceType: matchingInvoice?.serviceType || null
        };
      });

      res.json(joinedData);
    } catch (error) {
      console.error("Error fetching lab results with invoices:", error);
      res.status(500).json({ error: "Failed to fetch lab results with invoices" });
    }
  });

  // Update Sample_Collected field (toggle)
  app.patch("/api/lab-results/:id/toggle-sample-collected", authMiddleware, requireRole(["admin", "sample_taker", "nurse", "lab_technician"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const labResultId = parseInt(req.params.id);
      if (isNaN(labResultId)) {
        return res.status(400).json({ error: "Invalid lab result ID" });
      }

      const { sampleCollected } = req.body;

      if (typeof sampleCollected !== 'boolean') {
        return res.status(400).json({ error: "Sample_Collected must be a boolean value" });
      }

      // Update the lab result Sample_Collected field
      const updateData: any = {
        Sample_Collected: sampleCollected,
        status: sampleCollected ? "Sample Collected" : "pending",
        reportStatus: sampleCollected ? "Sample Ready for Testing" : "Awaiting Collection"
      };

      const updatedLabResult = await storage.updateLabResult(labResultId, req.tenant!.id, updateData);

      if (!updatedLabResult) {
        return res.status(404).json({ error: "Failed to update lab result" });
      }

      res.json({ 
        success: true, 
        message: sampleCollected ? "Sample marked as collected" : "Sample marked as not collected",
        labResult: updatedLabResult 
      });
    } catch (error) {
      console.error("Error toggling sample collected status:", error);
      res.status(500).json({ error: "Failed to toggle sample collected status" });
    }
  });

  // General PATCH endpoint for lab results (by testId)
  app.patch("/api/lab-results/:testId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const testId = req.params.testId;
      const updateData = req.body;

      // Fetch all lab results for the organization
      const labResults = await storage.getLabResults(req.tenant!.id);
      
      // Find the lab result by testId
      const labResult = labResults.find(lr => lr.testId === testId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      // Update the lab result
      const updatedLabResult = await storage.updateLabResult(labResult.id, req.tenant!.id, updateData);

      if (!updatedLabResult) {
        return res.status(404).json({ error: "Failed to update lab result" });
      }

      res.json({ 
        success: true, 
        labResult: updatedLabResult 
      });
    } catch (error) {
      console.error("Error updating lab result:", error);
      res.status(500).json({ error: "Failed to update lab result" });
    }
  });

  // Apply e-signature to lab result
  app.post("/api/lab-results/:id/e-sign", authMiddleware, requireNonPatientRole(), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const labResultId = parseInt(req.params.id);
      if (isNaN(labResultId)) {
        return res.status(400).json({ error: "Invalid lab result ID" });
      }

      const { signature } = req.body;
      if (!signature) {
        return res.status(400).json({ error: "Signature data is required" });
      }

      // Update the lab result with signature
      const updatedLabResult = await storage.updateLabResult(labResultId, req.tenant!.id, {
        signatureData: signature
      });

      if (!updatedLabResult) {
        return res.status(404).json({ error: "Lab result not found or failed to update" });
      }

      res.json({
        success: true,
        message: "E-signature applied successfully",
        labResult: updatedLabResult
      });
    } catch (error) {
      console.error("Error applying e-signature:", error);
      res.status(500).json({ error: "Failed to apply e-signature" });
    }
  });

  // Get invoices with polymorphic joins (lab_results OR medical_images)
  app.get("/api/invoices/with-services", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const organizationId = req.tenant!.id;

      // Fetch all invoices, lab results, and medical images
      const invoices = await storage.getInvoicesByOrganization(organizationId);
      const labResults = await storage.getLabResults(organizationId);
      const medicalImages = await storage.getMedicalImagesByOrganization(organizationId);

      // Join invoices with either lab_results or medical_images based on service_type
      const joinedData = invoices.map(invoice => {
        let labResult = null;
        let medicalImage = null;

        // Check service_type and join accordingly
        if (invoice.serviceType === 'lab_result' && invoice.serviceId) {
          labResult = labResults.find(lr => lr.id === invoice.serviceId);
        } else if (invoice.serviceType === 'medical_image' && invoice.serviceId) {
          medicalImage = medicalImages.find(img => img.id === invoice.serviceId);
        }

        return {
          invoiceId: invoice.id,
          patientId: invoice.patientId,
          invoiceNumber: invoice.invoiceNumber,
          amount: invoice.totalAmount,
          status: invoice.status,
          serviceType: invoice.serviceType,
          // Lab result data (if applicable)
          labResultId: labResult?.id || null,
          testType: labResult?.testType || null,
          testName: labResult?.testId || null,
          labReportStatus: labResult?.reportStatus || null,
          // Medical image data (if applicable)
          imageId: medicalImage?.id || null,
          imageType: medicalImage?.studyType || null,
          modality: medicalImage?.modality || null,
          imageStatus: medicalImage?.status || null,
          // Common fields
          invoiceDate: invoice.invoiceDate,
          createdAt: invoice.createdAt
        };
      });

      res.json(joinedData);
    } catch (error) {
      console.error("Error fetching invoices with services:", error);
      res.status(500).json({ error: "Failed to fetch invoices with services" });
    }
  });

  // Get invoice by service type and service ID
  app.get("/api/invoices/by-service", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { serviceType, serviceId } = req.query;
      if (!serviceType || !serviceId) {
        return res.status(400).json({ error: "serviceType and serviceId are required" });
      }

      const organizationId = req.tenant!.id;
      const invoices = await storage.getInvoicesByOrganization(organizationId);
      
      const invoice = invoices.find(inv => 
        inv.serviceType === serviceType && inv.serviceId === serviceId
      );

      if (!invoice) {
        return res.status(404).json({ error: "Invoice not found" });
      }

      res.json(invoice);
    } catch (error) {
      console.error("Error fetching invoice by service:", error);
      res.status(500).json({ error: "Failed to fetch invoice" });
    }
  });

  // Get paid lab result invoices with joined lab_results details
  app.get("/api/invoices/paid-lab-results", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const organizationId = req.tenant!.id;
      const sampleCollected = req.query.sampleCollected === 'true';
      console.log(`[PAID LAB INVOICES] Fetching for organization ${organizationId}, sampleCollected filter: ${sampleCollected}`);

      // Fetch all invoices, lab results, and patients
      const invoices = await storage.getInvoicesByOrganization(organizationId);
      const labResults = await storage.getLabResults(organizationId);
      const patients = await storage.getPatientsByOrganization(organizationId);

      console.log(`[PAID LAB INVOICES] Total invoices: ${invoices.length}`);
      console.log(`[PAID LAB INVOICES] Total lab results: ${labResults.length}`);
      console.log(`[PAID LAB INVOICES] Total patients: ${patients.length}`);

      // Filter paid invoices with serviceType = "lab_result"
      const paidInvoices = invoices.filter(invoice => invoice.status === 'paid' && invoice.serviceType === 'lab_result');
      console.log(`[PAID LAB INVOICES] Paid lab invoices found: ${paidInvoices.length}`);

      // Join with lab_results and patients
      let paidLabInvoices = paidInvoices
        .map(invoice => {
          // Match invoice.serviceId with lab_results.testId
          const labResult = labResults.find(lr => lr.testId === invoice.serviceId);
          console.log(`[PAID LAB INVOICES] Invoice ${invoice.invoiceNumber} serviceId: ${invoice.serviceId}, matched lab result: ${labResult?.testId || 'NOT FOUND'}`);

          // Match patient by patientId from invoice
          const patient = patients.find(p => p.patientId === invoice.patientId);

          return {
            // Invoice fields
            invoiceId: invoice.id,
            invoiceNumber: invoice.invoiceNumber,
            totalAmount: invoice.totalAmount,
            invoiceStatus: invoice.status,
            invoiceDate: invoice.invoiceDate,
            serviceDate: invoice.serviceDate,
            patientId: invoice.patientId,
            serviceType: invoice.serviceType,
            serviceId: invoice.serviceId,
            // Patient fields (if matched)
            patientFirstName: patient?.firstName || null,
            patientLastName: patient?.lastName || null,
            // Lab result fields (if matched)
            testId: labResult?.testId || null,
            testType: labResult?.testType || null,
            priority: labResult?.priority || null,
            status: labResult?.status || null,
            reportStatus: labResult?.reportStatus || null,
            orderedAt: labResult?.orderedAt || null,
            Sample_Collected: labResult?.sampleCollected || false,
            Lab_Request_Generated: labResult?.labRequestGenerated || false,
            doctorName: labResult?.doctorName || null,
            notes: labResult?.notes || null,
          };
        })
        // Only include invoices that have matching lab results
        .filter(item => item.testId !== null);

      // Apply sampleCollected filter if requested
      if (sampleCollected) {
        paidLabInvoices = paidLabInvoices.filter(item => item.Sample_Collected === true);
        console.log(`[PAID LAB INVOICES] After Sample_Collected filter: ${paidLabInvoices.length}`);
      }

      console.log(`[PAID LAB INVOICES] Final results with matched lab data: ${paidLabInvoices.length}`);
      res.json(paidLabInvoices);
    } catch (error) {
      console.error("[PAID LAB INVOICES] Error:", error);
      res.status(500).json({ error: "Failed to fetch paid lab invoices" });
    }
  });

  // Submit/Update insurance claim for an invoice
  app.post("/api/insurance/submit-claim", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const claimData = z.object({
        invoiceId: z.number().int().positive(),
        provider: z.string().min(1),
        claimNumber: z.string().min(1),
        status: z.enum(['pending', 'approved', 'denied', 'partially_paid']).default('pending'),
      }).parse(req.body);

      const organizationId = req.tenant!.id;

      // Update invoice with insurance information
      await db
        .update(schema.invoices)
        .set({
          invoiceType: 'insurance_claim',
          insurance: {
            provider: claimData.provider,
            claimNumber: claimData.claimNumber,
            status: claimData.status,
            paidAmount: 0,
          },
          updatedAt: new Date(),
        })
        .where(eq(schema.invoices.id, claimData.invoiceId))
        .execute();

      res.json({ success: true, message: "Insurance claim submitted successfully" });
    } catch (error) {
      console.error("Error submitting insurance claim:", error);
      res.status(500).json({ error: "Failed to submit insurance claim" });
    }
  });

  // Record an insurance payment
  app.post("/api/insurance/record-payment", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const paymentData = z.object({
        invoiceId: z.number().int().positive(),
        claimNumber: z.string().optional(),
        amountPaid: z.coerce.number().positive(),
        paymentDate: z.string(),
        insuranceProvider: z.string().min(1),
        paymentReference: z.string().optional(),
        notes: z.string().optional(),
      }).parse(req.body);

      const organizationId = req.tenant!.id;

      // Insert payment record
      const [payment] = await db
        .insert(schema.insurancePayments)
        .values({
          organizationId,
          invoiceId: paymentData.invoiceId,
          claimNumber: paymentData.claimNumber || null,
          amountPaid: paymentData.amountPaid.toString(),
          paymentDate: new Date(paymentData.paymentDate),
          insuranceProvider: paymentData.insuranceProvider,
          paymentReference: paymentData.paymentReference || null,
          notes: paymentData.notes || null,
          createdBy: req.user.id,
        })
        .returning();

      // Get all payments for this invoice to calculate total
      const allPayments = await db
        .select()
        .from(schema.insurancePayments)
        .where(eq(schema.insurancePayments.invoiceId, paymentData.invoiceId))
        .execute();

      const totalPaid = allPayments.reduce((sum, p) => sum + parseFloat(p.amountPaid as string), 0);

      // Get invoice to check total amount
      const [invoice] = await db
        .select()
        .from(schema.invoices)
        .where(eq(schema.invoices.id, paymentData.invoiceId))
        .execute();

      if (!invoice) {
        return res.status(404).json({ error: "Invoice not found" });
      }

      const totalAmount = parseFloat(invoice.totalAmount as string);
      const remaining = totalAmount - totalPaid;

      // Update invoice with new paid amount and status
      let newStatus = invoice.insurance?.status || 'pending';
      if (remaining <= 0) {
        newStatus = 'approved';
      } else if (totalPaid > 0) {
        newStatus = 'partially_paid';
      }

      await db
        .update(schema.invoices)
        .set({
          paidAmount: totalPaid.toString(),
          status: remaining <= 0 ? 'paid' : 'pending',
          insurance: {
            ...(invoice.insurance || {}),
            provider: invoice.insurance?.provider || paymentData.insuranceProvider,
            claimNumber: invoice.insurance?.claimNumber || paymentData.claimNumber || '',
            status: newStatus,
            paidAmount: totalPaid,
          },
          updatedAt: new Date(),
        })
        .where(eq(schema.invoices.id, paymentData.invoiceId))
        .execute();

      res.json({ 
        success: true, 
        payment,
        totalPaid,
        remaining,
        message: "Insurance payment recorded successfully" 
      });
    } catch (error) {
      console.error("Error recording insurance payment:", error);
      res.status(500).json({ error: "Failed to record insurance payment" });
    }
  });

  // Get all insurance payments for an invoice
  app.get("/api/insurance/payments/:invoiceId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const invoiceId = parseInt(req.params.invoiceId);
      if (isNaN(invoiceId)) {
        return res.status(400).json({ error: "Invalid invoice ID" });
      }

      const payments = await db
        .select()
        .from(schema.insurancePayments)
        .where(eq(schema.insurancePayments.invoiceId, invoiceId))
        .orderBy(schema.insurancePayments.paymentDate)
        .execute();

      res.json(payments);
    } catch (error) {
      console.error("Error fetching insurance payments:", error);
      res.status(500).json({ error: "Failed to fetch insurance payments" });
    }
  });

  // Generate PDF for lab result
  app.post("/api/lab-results/:id/generate-pdf", authMiddleware, requireNonPatientRole(), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const labResultId = parseInt(req.params.id);
      if (isNaN(labResultId)) {
        return res.status(400).json({ error: "Invalid lab result ID" });
      }

      const organizationId = req.tenant!.id;

      // Fetch lab result
      const labResults = await storage.getLabResults(organizationId);
      const labResult = labResults.find(result => result.id === labResultId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      // Fetch patient details
      const patient = await storage.getPatient(labResult.patientId, organizationId);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Fetch clinic header and footer
      const clinicHeader = await storage.getActiveClinicHeader(organizationId);
      const clinicFooter = await storage.getActiveClinicFooter(organizationId);

      // Construct directory path: uploads/Lab_TestResults/{organization_id}/{patient_id}/
      const dirPath = path.join(process.cwd(), 'uploads', 'Lab_TestResults', organizationId.toString(), labResult.patientId.toString());
      
      // Ensure directory exists
      await fse.ensureDir(dirPath);

      // Construct file path with Test ID as filename
      const fileName = `${labResult.testId}.pdf`;
      const filePath = path.join(dirPath, fileName);

      // Generate PDF using jsPDF
      const { jsPDF } = await import('jspdf');
      const doc = new jsPDF();

      const pageWidth = doc.internal.pageSize.getWidth();
      let yPos = 20;

      // Logo dimensions
      const logoWidth = 35;
      const logoHeight = 35;
      const logoMargin = 10;
      
      // Determine layout based on logo position
      let hasLogo = false;
      let logoEndX = 20;
      
      if (clinicHeader?.logoBase64) {
        hasLogo = true;
        try {
          if (clinicHeader.logoPosition === 'left' || clinicHeader.logoPosition === 'center') {
            // Logo on left side
            doc.addImage(clinicHeader.logoBase64, 'PNG', 20, yPos, logoWidth, logoHeight);
            logoEndX = 20 + logoWidth + logoMargin;
          } else if (clinicHeader.logoPosition === 'right') {
            // Logo on right side
            doc.addImage(clinicHeader.logoBase64, 'PNG', pageWidth - 20 - logoWidth, yPos, logoWidth, logoHeight);
            logoEndX = 20; // Text starts from left
          }
        } catch (error) {
          console.error('Error adding logo to PDF:', error);
          hasLogo = false;
        }
      }

      // Header text positioning - avoid overlapping with logo
      let textStartX = hasLogo && (clinicHeader?.logoPosition === 'left' || clinicHeader?.logoPosition === 'center') ? logoEndX : 20;
      let textMaxWidth = hasLogo && clinicHeader?.logoPosition === 'right' ? pageWidth - 20 - logoWidth - logoMargin - 20 : pageWidth - textStartX - 20;
      
      let headerTextY = yPos;

      // Header - Clinic Name
      if (clinicHeader?.clinicName) {
        doc.setFontSize(parseInt(clinicHeader.clinicNameFontSize || '20'));
        doc.setFont(clinicHeader.fontFamily || 'helvetica', clinicHeader.fontWeight || 'bold');
        const splitName = doc.splitTextToSize(clinicHeader.clinicName, textMaxWidth);
        doc.text(splitName, textStartX, headerTextY);
        headerTextY += splitName.length * 8;
      }

      // Clinic Details
      if (clinicHeader) {
        doc.setFontSize(parseInt(clinicHeader.fontSize || '10'));
        doc.setFont(clinicHeader.fontFamily || 'helvetica', 'normal');
        if (clinicHeader.address) {
          const splitAddr = doc.splitTextToSize(clinicHeader.address, textMaxWidth);
          doc.text(splitAddr, textStartX, headerTextY);
          headerTextY += splitAddr.length * 5;
        }
        if (clinicHeader.phone) {
          doc.text(clinicHeader.phone, textStartX, headerTextY);
          headerTextY += 5;
        }
        if (clinicHeader.email) {
          doc.text(clinicHeader.email, textStartX, headerTextY);
          headerTextY += 5;
        }
      }
      
      // Set yPos to whichever is lower: end of logo or end of header text
      const logoEndY = hasLogo ? yPos + logoHeight : yPos;
      yPos = Math.max(logoEndY, headerTextY) + 10;

      // Add a separator line after header
      doc.setDrawColor(200, 200, 200);
      doc.line(20, yPos, pageWidth - 20, yPos);
      yPos += 10;

      // Title - "Lab Test Result Report"
      doc.setFontSize(20);
      doc.setFont('helvetica', 'bold');
      doc.text('Lab Test Result Report', pageWidth / 2, yPos, { align: 'center' });
      yPos += 20;

      // Lab Order Information Section
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Lab Order Information', 20, yPos);
      yPos += 10;

      // Simple list format (no table)
      doc.setFontSize(11);
      doc.setFont('helvetica', 'normal');
      
      // Patient Name
      doc.setFont('helvetica', 'bold');
      doc.text('Patient Name:', 20, yPos);
      doc.setFont('helvetica', 'normal');
      doc.text(`${patient.firstName} ${patient.lastName}`, 80, yPos);
      yPos += 7;

      // Test ID
      doc.setFont('helvetica', 'bold');
      doc.text('Test ID:', 20, yPos);
      doc.setFont('helvetica', 'normal');
      doc.text(labResult.testId, 80, yPos);
      yPos += 7;

      // Ordered Date
      doc.setFont('helvetica', 'bold');
      doc.text('Ordered Date:', 20, yPos);
      doc.setFont('helvetica', 'normal');
      doc.text(
        labResult.orderedAt ? new Date(labResult.orderedAt).toLocaleDateString() : 'N/A',
        80,
        yPos
      );
      yPos += 7;

      // Ordered By
      doc.setFont('helvetica', 'bold');
      doc.text('Ordered By:', 20, yPos);
      doc.setFont('helvetica', 'normal');
      doc.text(req.user?.firstName ? `${req.user.firstName} ${req.user.lastName}` : 'N/A', 80, yPos);
      yPos += 7;

      // Priority
      doc.setFont('helvetica', 'bold');
      doc.text('Priority:', 20, yPos);
      doc.setFont('helvetica', 'normal');
      doc.text(labResult.priority || 'routine', 80, yPos);
      yPos += 15;

      // Results Table - Group by test type
      if (labResult.results) {
        try {
          const results = typeof labResult.results === 'string' 
            ? JSON.parse(labResult.results) 
            : labResult.results;

          if (Array.isArray(results) && results.length > 0) {
            // Group results by test type
            const resultsByTestType: Record<string, any[]> = {};
            results.forEach((result: any) => {
              // Extract test type and parameter name
              let testType = result.testType;
              let paramName = result.name || result.testName || '';
              
              // Always try to extract from name if it has the separator
              const nameParts = paramName.split(' - ');
              if (nameParts.length > 1) {
                // If no testType field, use the extracted one
                if (!testType) {
                  testType = nameParts[0];
                }
                // Always use the parameter name after the separator
                paramName = nameParts[1];
              }
              
              // Skip results without a valid test type
              if (testType) {
                if (!resultsByTestType[testType]) {
                  resultsByTestType[testType] = [];
                }
                resultsByTestType[testType].push({
                  ...result,
                  displayName: paramName
                });
              }
            });

            // Test Results - Each test type gets its own section
            Object.entries(resultsByTestType).forEach(([testType, groupResults]) => {
              if (yPos > 240) {
                doc.addPage();
                yPos = 20;
              }

              // Test Type Header (Blue text, no background)
              doc.setFontSize(14);
              doc.setFont('helvetica', 'bold');
              doc.setTextColor(66, 133, 244);
              doc.text(testType, 20, yPos);
              doc.setTextColor(0, 0, 0);
              yPos += 10;

              // Table Header
              const tableStartY = yPos;
              const rowHeight = 8;
              const colWidths = [60, 30, 30, 50]; // Parameter, Value, Unit, Reference Range
              const tableX = 20;
              const tableWidth = colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3];
              
              // Header background (light gray)
              doc.setFillColor(240, 240, 240);
              doc.rect(tableX, tableStartY, tableWidth, rowHeight, 'F');
              
              // Header border
              doc.setDrawColor(200, 200, 200);
              doc.rect(tableX, tableStartY, tableWidth, rowHeight);
              
              // Header text
              doc.setFont('helvetica', 'bold');
              doc.setFontSize(10);
              doc.text('Parameter', tableX + 2, tableStartY + 5);
              doc.text('Value', tableX + colWidths[0] + 2, tableStartY + 5);
              doc.text('Unit', tableX + colWidths[0] + colWidths[1] + 2, tableStartY + 5);
              doc.text('Reference Range', tableX + colWidths[0] + colWidths[1] + colWidths[2] + 2, tableStartY + 5);
              
              yPos = tableStartY + rowHeight;

              // Sort parameters by displayName
              const sortedResults = [...groupResults].sort((a: any, b: any) => {
                const nameA = (a.displayName || a.testName || a.name || '').toLowerCase();
                const nameB = (b.displayName || b.testName || b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
              });

              // Table rows
              doc.setFont('helvetica', 'normal');
              sortedResults.forEach((result: any, index: number) => {
                if (yPos > 270) {
                  doc.addPage();
                  yPos = 20;
                }
                
                // Draw row borders
                doc.setDrawColor(200, 200, 200);
                doc.rect(tableX, yPos, tableWidth, rowHeight);
                
                // Draw vertical lines between columns
                doc.line(tableX + colWidths[0], yPos, tableX + colWidths[0], yPos + rowHeight);
                doc.line(tableX + colWidths[0] + colWidths[1], yPos, tableX + colWidths[0] + colWidths[1], yPos + rowHeight);
                doc.line(tableX + colWidths[0] + colWidths[1] + colWidths[2], yPos, tableX + colWidths[0] + colWidths[1] + colWidths[2], yPos + rowHeight);
                
                // Row data - use the displayName (parameter name without test type prefix)
                const paramName = result.displayName || result.testName || result.name || '';
                
                doc.text(paramName, tableX + 2, yPos + 5);
                doc.text(String(result.value || ''), tableX + colWidths[0] + 2, yPos + 5);
                doc.text(result.unit || '', tableX + colWidths[0] + colWidths[1] + 2, yPos + 5);
                doc.text(result.referenceRange || '', tableX + colWidths[0] + colWidths[1] + colWidths[2] + 2, yPos + 5);
                
                yPos += rowHeight;
              });

              yPos += 10;
            });
          }
        } catch (e) {
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10);
          doc.text(labResult.results.toString(), 25, yPos);
          yPos += 6;
        }
      }

      // Clinical Notes
      if (labResult.notes) {
        yPos += 5;
        if (yPos > 270) {
          doc.addPage();
          yPos = 20;
        }
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text('Clinical Notes', 20, yPos);
        yPos += 10;

        doc.setFontSize(11);
        doc.setFont('helvetica', 'normal');
        const splitNotes = doc.splitTextToSize(labResult.notes, 170);
        doc.text(splitNotes, 20, yPos);
      }

      // Add footer at bottom of all pages
      if (clinicFooter) {
        const pageCount = doc.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
          doc.setPage(i);
          doc.setFontSize(10);
          doc.setFont('helvetica', 'normal');
          // Footer text centered at bottom
          doc.text(clinicFooter.footerText, 105, 285, { align: 'center' });
        }
      }

      // Save PDF to file
      const pdfBuffer = Buffer.from(doc.output('arraybuffer'));
      await fse.outputFile(filePath, pdfBuffer);

      console.log(`PDF generated successfully at: ${filePath}`);

      // Update labReportGenerated to true
      await storage.updateLabResult(labResultId, organizationId, {
        labReportGenerated: true
      });
      console.log(`Updated labReportGenerated to true for lab result ID: ${labResultId}`);

      // Return relative path for download
      const relativePath = `uploads/Lab_TestResults/${organizationId}/${labResult.patientId}/${fileName}`;

      res.json({
        success: true,
        message: "PDF generated successfully",
        filePath: relativePath,
        fileName: fileName,
        testId: labResult.testId
      });

    } catch (error) {
      console.error("Error generating PDF:", error);
      res.status(500).json({ error: "Failed to generate PDF" });
    }
  });

  // Direct download lab result PDF from file path
  app.get("/api/lab-results/:id/download-pdf", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const labResultId = parseInt(req.params.id);
      if (isNaN(labResultId)) {
        return res.status(400).json({ error: "Invalid lab result ID" });
      }

      const organizationId = req.tenant!.id;

      // Fetch lab result
      const labResults = await storage.getLabResults(organizationId);
      const labResult = labResults.find(result => result.id === labResultId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      // Construct file path: uploads/Lab_TestResults/{organization_id}/{patient_id}/{TestID}.pdf
      const fileName = `${labResult.testId}.pdf`;
      const filePath = path.join(process.cwd(), 'uploads', 'Lab_TestResults', organizationId.toString(), labResult.patientId.toString(), fileName);

      console.log(`[LAB-DOWNLOAD] Lab result ID: ${labResultId}`);
      console.log(`[LAB-DOWNLOAD] Organization ID: ${organizationId}`);
      console.log(`[LAB-DOWNLOAD] Patient ID: ${labResult.patientId}`);
      console.log(`[LAB-DOWNLOAD] Test ID: ${labResult.testId}`);
      console.log(`[LAB-DOWNLOAD] File path: ${filePath}`);

      // Check if file exists
      const fileExists = await fse.pathExists(filePath);
      console.log(`[LAB-DOWNLOAD] File exists: ${fileExists}`);
      
      if (!fileExists) {
        return res.status(404).json({ error: "PDF file not found. Please generate the report first." });
      }

      // Set headers for file download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);

      // Read file and send as response
      const fs = await import('fs');
      const fileBuffer = fs.readFileSync(filePath);
      res.send(fileBuffer);

    } catch (error) {
      console.error("Error downloading lab result PDF:", error);
      res.status(500).json({ error: "Failed to download PDF" });
    }
  });

  // Migrate lab results to add testType field to each result object
  app.post("/api/lab-results/migrate-test-types", authMiddleware, requireNonPatientRole(), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const organizationId = req.tenant!.id;
      const labResultsList = await storage.getLabResults(organizationId);

      let updatedCount = 0;
      let alreadyMigratedCount = 0;

      for (const labResult of labResultsList) {
        if (!labResult.results || !labResult.testType) continue;

        const results = typeof labResult.results === 'string' 
          ? JSON.parse(labResult.results) 
          : labResult.results;

        if (!Array.isArray(results) || results.length === 0) continue;

        // Check if already migrated (first result has testType field)
        if (results[0]?.testType) {
          alreadyMigratedCount++;
          continue;
        }

        // Parse test types from testType field
        const testTypesStr = labResult.testType;
        let testTypes: string[] = [];
        try {
          const parsed = JSON.parse(testTypesStr);
          testTypes = Array.isArray(parsed) ? parsed : [testTypesStr];
        } catch {
          testTypes = testTypesStr.split('|').map(t => t.trim()).filter(t => t.length > 0);
        }

        // Build a map of parameter names to test types
        const TEST_FIELD_DEFINITIONS: Record<string, Array<{name: string}>> = {
          "Complete Blood Count (CBC)": [
            { name: "White Blood Cell Count (WBC)" },
            { name: "Red Blood Cell Count (RBC)" },
            { name: "Hemoglobin (Hb)" },
            { name: "Hematocrit (Hct)" },
            { name: "Mean Corpuscular Volume (MCV)" },
            { name: "Mean Corpuscular Hemoglobin (MCH)" },
            { name: "Mean Corpuscular Hemoglobin Concentration (MCHC)" },
            { name: "Platelet Count" },
            { name: "Red Cell Distribution Width (RDW)" },
          ],
          "Hormonal tests (Cortisol, ACTH)": [
            { name: "Cortisol (AM)" },
            { name: "Cortisol (PM)" },
            { name: "ACTH (Adrenocorticotropic Hormone)" },
            { name: "24-hour Urinary Free Cortisol" },
          ],
          "Viral Panels / PCR Tests (e.g. COVID-19, Influenza)": [
            { name: "COVID-19 PCR" },
            { name: "Influenza A PCR" },
            { name: "Influenza B PCR" },
            { name: "RSV PCR" },
          ],
          "Bacterial Culture/Sensitivity Testing": [
            { name: "Culture Result" },
            { name: "Gram Stain" },
            { name: "AFB (Acid-Fast Bacilli)" },
            { name: "Fungal Culture" },
          ],
        };

        // Create parameter name to testType mapping
        const paramToTestType: Record<string, string> = {};
        testTypes.forEach(testType => {
          const fields = TEST_FIELD_DEFINITIONS[testType];
          if (fields) {
            fields.forEach(field => {
              paramToTestType[field.name] = testType;
            });
          }
        });

        // Update results array with testType field
        const updatedResults = results.map((result: any) => {
          const paramName = result.testName || result.name || '';
          const testType = paramToTestType[paramName] || testTypes[0];
          return {
            ...result,
            testType
          };
        });

        // Update lab result in database
        await storage.updateLabResult(labResult.id!, organizationId, {
          results: JSON.stringify(updatedResults)
        });

        updatedCount++;
      }

      res.json({
        success: true,
        message: `Migration completed: ${updatedCount} lab results updated, ${alreadyMigratedCount} already migrated`,
        updatedCount,
        alreadyMigratedCount
      });

    } catch (error) {
      console.error("Error migrating lab results:", error);
      res.status(500).json({ error: "Failed to migrate lab results" });
    }
  });

  // Get Lab Result PDF Path
  app.get("/api/lab-results/:id/pdf-path", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const labResultId = parseInt(req.params.id);
      if (isNaN(labResultId)) {
        return res.status(400).json({ error: "Invalid lab result ID" });
      }

      const organizationId = req.tenant!.id;

      // Fetch lab result
      const labResults = await storage.getLabResults(organizationId);
      const labResult = labResults.find(result => result.id === labResultId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      // Construct file path: uploads/Lab_TestResults/{organization_id}/{patient_id}/{TestID}.pdf
      const fileName = `${labResult.testId}.pdf`;
      const relativePath = `uploads/Lab_TestResults/${organizationId}/${labResult.patientId}/${fileName}`;
      const fullPath = path.join(process.cwd(), relativePath);

      // Check if file exists
      const fileExists = await fse.pathExists(fullPath);
      console.log(`[PDF-PATH] Checking file: ${fullPath}, exists: ${fileExists}`);
      if (!fileExists) {
        console.log(`[PDF-PATH] File not found, returning null`);
        return res.json({ pdfPath: null, error: "PDF file not found" });
      }

      console.log(`[PDF-PATH] File found, returning path: ${relativePath}`);
      res.json({ pdfPath: relativePath });

    } catch (error) {
      console.error("Error getting PDF path:", error);
      res.status(500).json({ error: "Failed to get PDF path" });
    }
  });

  // Generate and save lab test results as PDF
  app.post("/api/lab-results/generate", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      console.log("üì• RAW REQUEST BODY:", JSON.stringify(req.body, null, 2));
      
      const { labResultId, testId, patientId, testData, testTypes, testFieldDefinitions } = req.body;
      const organizationId = req.tenant!.id;

      console.log("üì• PDF generation request parsed:", JSON.stringify({
        labResultId,
        testId,
        patientId,
        testDataKeys: Object.keys(testData || {}),
        testTypes,
        hasTestFieldDefinitions: !!testFieldDefinitions
      }, null, 2));

      // Validate required fields (testData can be empty object - all fields are optional)
      if (!labResultId || !testId || !patientId || testData === undefined || testData === null) {
        console.error("‚ùå Missing required fields:", { labResultId, testId, patientId, hasTestData: testData !== undefined && testData !== null });
        return res.status(400).json({ error: "Missing required fields" });
      }

      // Fetch lab result details
      const labResults = await storage.getLabResults(organizationId);
      const labResult = labResults.find(result => result.id === labResultId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      // Fetch patient details
      const patients = await storage.getPatientsByOrganization(organizationId);
      const patient = patients.find((p: any) => p.id === patientId);

      // Fetch doctor details
      const users = await storage.getUsersByOrganization(organizationId);
      const doctor = users.find((u: any) => u.id === labResult.orderedBy);

      // Fetch clinic header and footer
      const clinicHeaders = await db
        .select()
        .from(schema.clinicHeaders)
        .where(eq(schema.clinicHeaders.organizationId, organizationId))
        .limit(1);
      
      const clinicFooters = await db
        .select()
        .from(schema.clinicFooters)
        .where(eq(schema.clinicFooters.organizationId, organizationId))
        .limit(1);

      const clinicHeader = clinicHeaders[0];
      const clinicFooter = clinicFooters[0];

      // Create directory structure
      const dirPath = path.join(process.cwd(), `uploads/Lab_TestResults/${organizationId}/${patientId}`);
      await fse.ensureDir(dirPath);

      // Generate filename
      const fileName = `${testId}.pdf`;
      const filePath = path.join(dirPath, fileName);

      // Import PDF library
      const { default: PDFDocument } = await import('pdfkit');
      const doc = new PDFDocument({ margin: 50, size: 'A4' });
      
      // Create write stream
      const stream = fse.createWriteStream(filePath);
      doc.pipe(stream);

      let yPosition = 50;

      // Add Header
      if (clinicHeader) {
        // Add logo if present
        if (clinicHeader.logoBase64) {
          try {
            const base64Data = clinicHeader.logoBase64.replace(/^data:image\/\w+;base64,/, '');
            const logoBuffer = Buffer.from(base64Data, 'base64');
            doc.image(logoBuffer, 50, yPosition, { width: 80, height: 80 });
          } catch (err) {
            console.error('Error adding logo:', err);
          }
        }

        // Add clinic info next to logo
        doc.fontSize(16).font('Helvetica-Bold').text(clinicHeader.clinicName, 150, yPosition);
        yPosition += 20;
        
        if (clinicHeader.address) {
          doc.fontSize(10).font('Helvetica').text(clinicHeader.address, 150, yPosition);
          yPosition += 15;
        }
        if (clinicHeader.phone) {
          doc.text(clinicHeader.phone, 150, yPosition);
          yPosition += 15;
        }
        if (clinicHeader.email) {
          doc.text(clinicHeader.email, 150, yPosition);
          yPosition += 15;
        }
      }

      yPosition += 30;

      // Lab Order Information Section
      doc.fontSize(14).font('Helvetica-Bold').text('Lab Order Information', 50, yPosition);
      yPosition += 25;

      // Two column layout for lab order info
      const leftCol = 50;
      const rightCol = 320;

      doc.fontSize(10).font('Helvetica-Bold').text('Patient Name:', leftCol, yPosition);
      doc.font('Helvetica').text(patient ? `${patient.firstName} ${patient.lastName}` : 'N/A', leftCol + 100, yPosition);
      
      doc.font('Helvetica-Bold').text('Ordered By:', rightCol, yPosition);
      doc.font('Helvetica').text(doctor ? `${doctor.firstName} ${doctor.lastName}` : 'N/A', rightCol + 80, yPosition);
      yPosition += 20;

      doc.font('Helvetica-Bold').text('Test ID:', leftCol, yPosition);
      doc.font('Helvetica').text(testId, leftCol + 100, yPosition);
      
      doc.font('Helvetica-Bold').text('Priority:', rightCol, yPosition);
      doc.font('Helvetica').text(labResult.priority || 'routine', rightCol + 80, yPosition);
      yPosition += 20;

      doc.font('Helvetica-Bold').text('Ordered Date:', leftCol, yPosition);
      doc.font('Helvetica').text(labResult.orderedAt ? new Date(labResult.orderedAt).toLocaleDateString('en-GB') : 'N/A', leftCol + 100, yPosition);
      yPosition += 35;

      // Test Results
      if (testTypes && Array.isArray(testTypes)) {
        for (let idx = 0; idx < testTypes.length; idx++) {
          const testType = testTypes[idx];
          
          // Check if we need a new page
          if (yPosition > 700) {
            doc.addPage();
            yPosition = 50;
          }

          // Test type header with blue background
          doc.rect(50, yPosition, 495, 25).fill('#4A7DFF');
          doc.fontSize(12).font('Helvetica-Bold').fillColor('#FFFFFF').text(`${idx + 1}. ${testType}`, 55, yPosition + 7);
          yPosition += 30;

          // Table headers
          doc.fillColor('#000000').fontSize(9).font('Helvetica-Bold');
          doc.text('Parameter', 55, yPosition);
          doc.text('Value', 230, yPosition);
          doc.text('Unit', 330, yPosition);
          doc.text('Reference Range', 410, yPosition);
          yPosition += 20;

          // Find all fields for this test type that have values (not empty strings)
          const fields = Object.keys(testData).filter(key => 
            key.startsWith(`${testType}_`) && 
            testData[key] && 
            testData[key].toString().trim() !== ''
          );
          
          if (fields.length > 0) {
            doc.fontSize(9).font('Helvetica');
            
            fields.forEach(fieldKey => {
              const fieldName = fieldKey.replace(`${testType}_`, '');
              const fieldValue = testData[fieldKey];
              
              // Find matching field definition for unit and reference range
              const fieldDef = testFieldDefinitions && testFieldDefinitions[testType] 
                ? testFieldDefinitions[testType].find((f: any) => f.name === fieldName)
                : null;
              
              const unit = fieldDef?.unit || '';
              const referenceRange = fieldDef?.referenceRange || '';
              
              // Check if we need a new page
              if (yPosition > 720) {
                doc.addPage();
                yPosition = 50;
              }

              // Draw table row with actual values only
              doc.text(fieldName, 55, yPosition, { width: 170 });
              doc.text(fieldValue.toString(), 230, yPosition, { width: 95 });
              doc.text(unit, 330, yPosition, { width: 75 });
              doc.text(referenceRange, 410, yPosition, { width: 135 });
              yPosition += 18;
            });
          } else {
            // Only show "no data" message if this test type was supposed to have data but doesn't
            doc.fontSize(9).font('Helvetica-Oblique').text('No data entered for this test type.', 55, yPosition);
            yPosition += 20;
          }

          yPosition += 15;
        }
      }

      // Clinical Notes
      if (testData.clinicalNotes) {
        if (yPosition > 650) {
          doc.addPage();
          yPosition = 50;
        }

        doc.fontSize(12).font('Helvetica-Bold').text('Clinical Notes (Optional)', 50, yPosition);
        yPosition += 20;
        doc.fontSize(10).font('Helvetica').text(testData.clinicalNotes, 50, yPosition, { width: 495 });
      }

      // Add Footer
      if (clinicFooter) {
        doc.rect(0, 750, 595, 92).fill(clinicFooter.backgroundColor || '#4A7DFF');
        doc.fontSize(10).font('Helvetica')
          .fillColor(clinicFooter.textColor || '#FFFFFF')
          .text(clinicFooter.footerText, 50, 770, { align: 'center', width: 495 });
      }

      // Finalize PDF
      doc.end();

      // Wait for file to be written
      await new Promise((resolve, reject) => {
        stream.on('finish', resolve);
        stream.on('error', reject);
      });

      console.log(`Lab result PDF generated successfully at: ${filePath}`);

      // Return relative path
      const relativePath = `uploads/Lab_TestResults/${organizationId}/${patientId}/${fileName}`;

      res.json({
        success: true,
        message: "Lab result generated successfully",
        filePath: relativePath,
        fileName: fileName,
        testId: testId
      });

    } catch (error) {
      console.error("Error generating lab result:", error);
      res.status(500).json({ error: "Failed to generate lab result" });
    }
  });

  // Check if lab result PDF file exists
  app.get("/api/files/:id/exists", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const labResultId = parseInt(req.params.id);
      if (isNaN(labResultId)) {
        return res.status(400).json({ error: "Invalid file ID" });
      }

      const organizationId = req.tenant!.id;

      // Fetch lab result
      const labResults = await storage.getLabResults(organizationId);
      const labResult = labResults.find(result => result.id === labResultId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      // Construct file path
      const fileName = `${labResult.testId}.pdf`;
      const fullPath = path.join(process.cwd(), `uploads/Lab_TestResults/${organizationId}/${labResult.patientId}/${fileName}`);

      // Check if file exists
      const fileExists = await fse.pathExists(fullPath);

      res.json({ exists: fileExists });

    } catch (error) {
      console.error("Error checking file existence:", error);
      res.status(500).json({ error: "Failed to check file existence" });
    }
  });

  // Generate temporary signed URL for lab result PDF (HIPAA/GDPR compliant)
  app.get("/api/files/:id/signed-url", authMiddleware, async (req: TenantRequest, res) => {
    try {
      console.log(`[SIGNED-URL-REQUEST] Headers:`, {
        protocol: req.protocol,
        xForwardedProto: req.get('x-forwarded-proto'),
        host: req.get('host'),
        xForwardedHost: req.get('x-forwarded-host'),
        referer: req.get('referer'),
        origin: req.get('origin')
      });

      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const labResultId = parseInt(req.params.id);
      if (isNaN(labResultId)) {
        return res.status(400).json({ error: "Invalid file ID" });
      }

      const organizationId = req.tenant!.id;

      // Fetch lab result to verify access
      const labResults = await storage.getLabResults(organizationId);
      const labResult = labResults.find(result => result.id === labResultId);
      
      if (!labResult) {
        return res.status(404).json({ error: "Lab result not found" });
      }

      // Verify user has access to this patient's data
      if (req.user.role === 'patient') {
        const patients = await storage.getPatients(organizationId);
        const userPatient = patients.find(p => p.userId === req.user!.id);
        if (!userPatient || userPatient.id !== labResult.patientId) {
          return res.status(403).json({ error: "Access denied to this lab result" });
        }
      }

      // Generate temporary signed token (valid for 5 minutes)
      const fileSecret = process.env.FILE_SECRET;
      if (!fileSecret) {
        console.error("FILE_SECRET not configured");
        return res.status(500).json({ error: "Server configuration error" });
      }

      const token = jwt.sign(
        { 
          fileId: labResultId,
          organizationId: organizationId,
          patientId: labResult.patientId,
          testId: labResult.testId,
          userId: req.user.id
        }, 
        fileSecret, 
        { expiresIn: "5m" }
      );

      // Get the correct protocol and host for production environments
      // Try to extract baseURL from origin or referer header to avoid port issues
      let baseUrl;
      const origin = req.get('origin');
      const referer = req.get('referer');
      
      if (origin) {
        // Use origin if available (most reliable)
        baseUrl = origin;
      } else if (referer) {
        // Extract base URL from referer
        const url = new URL(referer);
        baseUrl = `${url.protocol}//${url.host}`;
      } else {
        // Fallback to constructing from headers
        const protocol = req.get('x-forwarded-proto') || req.protocol || 'https';
        let host = req.get('x-forwarded-host') || req.get('host') || req.headers.host;
        
        // Remove port if it's 5000 (development port shouldn't be in production URLs)
        if (typeof host === 'string' && host.includes(':5000')) {
          host = host.replace(':5000', '');
        }
        
        baseUrl = `${protocol}://${host}`;
      }
      
      const signedUrl = `${baseUrl}/api/files/view/${labResultId}?token=${token}`;
      
      console.log(`[SIGNED-URL] Generated for lab result ${labResultId}, valid for 5 minutes`);
      console.log(`[SIGNED-URL] Base URL: ${baseUrl}`);
      console.log(`[SIGNED-URL] Full signed URL: ${signedUrl}`);
      res.json({ signedUrl });

    } catch (error) {
      console.error("Error generating signed URL:", error);
      res.status(500).json({ error: "Failed to generate signed URL" });
    }
  });

  // View lab result PDF using temporary signed URL (no authentication required - token validated)
  app.get("/api/files/view/:id", async (req, res) => {
    try {
      const { token } = req.query;
      if (!token || typeof token !== 'string') {
        return res.status(403).json({ error: "Missing or invalid token" });
      }

      const fileSecret = process.env.FILE_SECRET;
      if (!fileSecret) {
        console.error("FILE_SECRET not configured");
        return res.status(500).json({ error: "Server configuration error" });
      }

      // Verify and decode token
      let payload: any;
      try {
        payload = jwt.verify(token, fileSecret);
      } catch (err) {
        console.log("[FILE-VIEW] Token verification failed:", err);
        return res.status(403).json({ error: "Invalid or expired link" });
      }

      const { fileId, organizationId, patientId, testId } = payload;
      
      // Construct file path
      const fileName = `${testId}.pdf`;
      const relativePath = `uploads/Lab_TestResults/${organizationId}/${patientId}/${fileName}`;
      const fullPath = path.join(process.cwd(), relativePath);

      // Check if file exists
      const fileExists = await fse.pathExists(fullPath);
      if (!fileExists) {
        console.log(`[FILE-VIEW] File not found: ${fullPath}`);
        return res.status(404).json({ error: "File not found" });
      }

      console.log(`[FILE-VIEW] Serving file: ${fullPath}`);
      
      // Set headers for PDF viewing
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', 'inline; filename="' + fileName + '"');
      
      // Stream the file
      res.sendFile(fullPath);

    } catch (error) {
      console.error("Error viewing file:", error);
      res.status(500).json({ error: "Failed to view file" });
    }
  });

  // Generate temporary signed URL for imaging report PDF (HIPAA/GDPR compliant)
  app.get("/api/imaging-files/:id/signed-url", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const imageId = req.params.id;
      if (!imageId) {
        return res.status(400).json({ error: "Invalid image ID" });
      }

      const organizationId = req.tenant!.id;

      // Fetch medical image to verify access
      const medicalImages = await storage.getMedicalImagesByOrganization(organizationId);
      const medicalImage = medicalImages.find(img => img.imageId === imageId);

      if (!medicalImage) {
        return res.status(404).json({ error: "Medical image not found" });
      }

      const fileSecret = process.env.FILE_SECRET;
      if (!fileSecret) {
        console.error("FILE_SECRET not configured");
        return res.status(500).json({ error: "Server configuration error" });
      }

      const token = jwt.sign(
        { 
          fileId: medicalImage.id,
          imageId: imageId,
          organizationId: organizationId,
          patientId: medicalImage.patientId,
          userId: req.user.id
        }, 
        fileSecret, 
        { expiresIn: "5m" }
      );

      // Get the correct protocol and host for production environments
      // Try to extract baseURL from origin or referer header to avoid port issues
      let baseUrl;
      const origin = req.get('origin');
      const referer = req.get('referer');
      
      if (origin) {
        // Use origin if available (most reliable)
        baseUrl = origin;
      } else if (referer) {
        // Extract base URL from referer
        const url = new URL(referer);
        baseUrl = `${url.protocol}//${url.host}`;
      } else {
        // Fallback to constructing from headers
        const protocol = req.get('x-forwarded-proto') || req.protocol || 'https';
        let host = req.get('x-forwarded-host') || req.get('host') || req.headers.host;
        
        // Remove port if it's 5000 (development port shouldn't be in production URLs)
        if (typeof host === 'string' && host.includes(':5000')) {
          host = host.replace(':5000', '');
        }
        
        baseUrl = `${protocol}://${host}`;
      }
      
      const signedUrl = `${baseUrl}/api/imaging-files/view/${imageId}?token=${token}`;
      
      console.log(`[SIGNED-URL] Generated for imaging report ${imageId}, valid for 5 minutes`);
      console.log(`[SIGNED-URL] Base URL: ${baseUrl}`);
      console.log(`[SIGNED-URL] Full signed URL: ${signedUrl}`);
      res.json({ signedUrl });

    } catch (error) {
      console.error("Error generating signed URL for imaging:", error);
      res.status(500).json({ error: "Failed to generate signed URL" });
    }
  });

  // View imaging report PDF using temporary signed URL (no authentication required - token validated)
  app.get("/api/imaging-files/view/:id", async (req, res) => {
    try {
      const { token } = req.query;
      if (!token || typeof token !== 'string') {
        return res.status(403).json({ error: "Missing or invalid token" });
      }

      const fileSecret = process.env.FILE_SECRET;
      if (!fileSecret) {
        console.error("FILE_SECRET not configured");
        return res.status(500).json({ error: "Server configuration error" });
      }

      // Verify and decode token
      let payload: any;
      try {
        payload = jwt.verify(token, fileSecret);
      } catch (err) {
        console.log("[IMAGING-VIEW] Token verification failed:", err);
        return res.status(403).json({ error: "Invalid or expired link" });
      }

      const { imageId, organizationId, patientId } = payload;
      
      // Construct file path
      const fileName = `${imageId}.pdf`;
      const relativePath = `uploads/Imaging_Reports/${organizationId}/patients/${patientId}/${fileName}`;
      const fullPath = path.join(process.cwd(), relativePath);

      // Check if file exists
      const fileExists = await fse.pathExists(fullPath);
      if (!fileExists) {
        console.log(`[IMAGING-VIEW] File not found: ${fullPath}`);
        return res.status(404).json({ error: "File not found" });
      }

      console.log(`[IMAGING-VIEW] Serving file: ${fullPath}`);
      
      // Set headers for PDF viewing
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', 'inline; filename="' + fileName + '"');
      
      // Stream the file
      res.sendFile(fullPath);

    } catch (error) {
      console.error("Error viewing imaging file:", error);
      res.status(500).json({ error: "Failed to view file" });
    }
  });

  // Upload report images endpoint
  app.post("/api/imaging/upload-report-images", authMiddleware, requireRole(["doctor", "nurse", "admin", "receptionist"]), uploadMedicalImages.array('images', 10), async (req: TenantRequest, res) => {
    try {
      if (!req.user || !req.tenant) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const files = req.files as Express.Multer.File[];
      if (!files || files.length === 0) {
        return res.status(400).json({ error: "No images uploaded" });
      }

      const { studyId, patientId } = req.body;
      if (!studyId) {
        return res.status(400).json({ error: "Study ID required" });
      }

      // Validate MIME types
      const allowedMimeTypes = [
        'image/jpeg',
        'image/jpg',
        'image/png',
        'image/gif',
        'image/bmp',
        'image/tiff',
        'image/webp',
        'image/svg+xml',
        'application/dicom',
        'image/x-icon',
      ];

      const invalidFiles = files.filter(file => !allowedMimeTypes.includes(file.mimetype));
      if (invalidFiles.length > 0) {
        // Clean up uploaded files
        await Promise.all(files.map(file => fse.remove(file.path)));
        return res.status(400).json({ 
          error: "Invalid file type",
          details: `Files must be images. Invalid files: ${invalidFiles.map(f => f.originalname).join(', ')}`
        });
      }

      console.log(`üì∑ UPLOAD: Uploading ${files.length} images for study ${studyId} in organization ${req.tenant.id}`);

      const uploadedImages = files.map(file => ({
        fileName: file.filename,
        originalName: file.originalname,
        fileSize: file.size,
        mimeType: file.mimetype,
        path: file.path,
      }));

      console.log(`‚úÖ UPLOAD: Successfully uploaded ${uploadedImages.length} images`);

      res.json({
        success: true,
        uploadedImages,
        message: `${uploadedImages.length} image(s) uploaded successfully`,
      });
    } catch (error) {
      console.error("Error uploading report images:", error);
      
      // Clean up any uploaded files on error
      if (req.files) {
        const files = req.files as Express.Multer.File[];
        await Promise.all(files.map(file => fse.remove(file.path).catch(err => 
          console.error(`Failed to clean up file ${file.path}:`, err)
        )));
      }
      
      res.status(500).json({ 
        error: "Failed to upload images",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });

  // Imaging Routes
  app.get("/api/imaging", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const imagingStudies = [
        {
          id: "img_001",
          patientId: "p_001",
          patientName: "Sarah Johnson",
          studyType: "Chest X-Ray",
          modality: "XR",
          orderedBy: "Dr. Sarah Smith",
          orderedAt: "2024-01-15T09:00:00Z",
          scheduledAt: "2024-01-16T14:00:00Z",
          completedAt: "2024-01-16T14:30:00Z",
          status: "completed",
          findings: "No acute cardiopulmonary abnormalities identified.",
          impression: "Normal chest radiograph",
          radiologist: "Dr. Michael Johnson",
          priority: "routine"
        }
      ];

      res.json(imagingStudies);
    } catch (error) {
      console.error("Error fetching imaging studies:", error);
      res.status(500).json({ error: "Failed to fetch imaging studies" });
    }
  });

  // Billing Routes
  app.get("/api/billing", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      console.log("üìã Fetching invoices from database for organization:", req.tenant!.id, "User role:", req.user.role);
      
      // Fetch all invoices from the database
      let invoices = await storage.getInvoicesByOrganization(req.tenant!.id);
      
      // Filter invoices for patient users - only show their own invoices
      if (req.user.role === "patient") {
        console.log("üë§ User is a patient - filtering invoices by patient email:", req.user.email);
        
        // Find the patient record for this user to get their patientId
        const patients = await storage.getPatientsByOrganization(req.tenant!.id);
        const userPatient = patients.find(p => p.email?.toLowerCase() === req.user!.email.toLowerCase());
        
        if (userPatient) {
          console.log("‚úÖ Found patient record:", userPatient.id, "Filtering invoices...");
          // Filter to only show invoices for this patient
          invoices = invoices.filter(inv => inv.patientId === userPatient.id);
          console.log(`üìã Filtered to ${invoices.length} invoices for patient ID ${userPatient.id}`);
        } else {
          console.log("‚ö†Ô∏è No patient record found for user email:", req.user.email);
          // If no patient record found, return empty array
          invoices = [];
        }
      }
      
      console.log(`‚úÖ Returning ${invoices.length} invoices`);
      
      res.json(invoices);
    } catch (error) {
      console.error("Error fetching billing data:", error);
      res.status(500).json({ error: "Failed to fetch billing data" });
    }
  });

  // Forms Routes
  app.get("/api/forms", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const data = await formService.getForms(organizationId);
      res.json(data);
    } catch (error) {
      console.error("Error fetching forms:", error);
      res.status(500).json({ error: "Failed to fetch forms" });
    }
  });

  app.post("/api/forms", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const organizationId = requireOrgId(req);
      const payload = {
        organizationId,
        createdBy: req.user.id,
        title: req.body.title,
        description: req.body.description,
        metadata: req.body.metadata,
        status: req.body.status,
        sections: req.body.sections,
      };

      const created = await formService.createForm(payload);
      res.status(201).json(created);
    } catch (error) {
      console.error("Error creating form:", error);
      let message = "Failed to create form";
      if (error instanceof Error && error.message) {
        message = error.message;
      }
      res.status(500).json({ error: message });
    }
  });

  app.post(
    "/api/forms/:formId/share",
    authMiddleware,
    requireRole(["admin", "doctor", "nurse"]),
    async (req: TenantRequest, res) => {
      try {
        if (!req.user) {
          return res.status(401).json({ error: "User not authenticated" });
        }

        const organizationId = requireOrgId(req);
        const formId = Number(req.params.formId);
        const patientId = Number(req.body.patientId);
        if (!patientId) {
          return res.status(400).json({ error: "patientId is required" });
        }

        const result = await formService.shareForm({
          formId,
          organizationId,
          patientId,
          sentById: req.user.id,
        });
        res.status(201).json(result);
      } catch (error) {
        console.error("Error sharing form:", error);
        res.status(500).json({ error: (error as Error).message || "Failed to share form" });
      }
    },
  );

  app.get(
    "/api/forms/:formId/shares",
    authMiddleware,
    requireRole(["admin", "doctor", "nurse"]),
    async (req: TenantRequest, res) => {
      try {
        const organizationId = requireOrgId(req);
        const formId = Number(req.params.formId);
        if (!formId) {
          return res.status(400).json({ error: "formId is required" });
        }
        const logs = await formService.getFormShareLogs(formId, organizationId);
        res.json(logs);
      } catch (error) {
        console.error("Error fetching share logs:", error);
        res.status(500).json({ error: (error as Error).message || "Failed to fetch share logs" });
      }
    },
  );

  app.get(
    "/api/forms/:formId/responses",
    authMiddleware,
    requireRole(["admin", "doctor", "nurse"]),
    async (req: TenantRequest, res) => {
      try {
        if (!req.user) {
          return res.status(401).json({ error: "User not authenticated" });
        }

        const organizationId = requireOrgId(req);
        const formId = Number(req.params.formId);
        if (!formId) {
          return res.status(400).json({ error: "formId is required" });
        }

        const payload = await formService.getFormResponses(formId, organizationId);
        res.json(payload);
      } catch (error) {
        console.error("Error fetching form responses:", error);
        res.status(500).json({ error: (error as Error).message || "Failed to fetch responses" });
      }
    },
  );

  app.post(
    "/api/forms/share-logs/:logId/resend",
    authMiddleware,
    requireRole(["admin", "doctor", "nurse"]),
    async (req: TenantRequest, res) => {
      try {
        if (!req.user) {
          return res.status(401).json({ error: "User not authenticated" });
        }

        const organizationId = requireOrgId(req);
        const logId = Number(req.params.logId);
        if (!logId) {
          return res.status(400).json({ error: "logId is required" });
        }

        const result = await formService.resendShareEmail(logId, organizationId, req.user.id);
        res.json(result);
      } catch (error) {
        console.error("Error resending share email:", error);
        res.status(500).json({ error: (error as Error).message || "Failed to resend share email" });
      }
    },
  );

  app.post(
    "/api/forms/:formId/share/preview",
    authMiddleware,
    requireRole(["admin", "doctor", "nurse"]),
    async (req: TenantRequest, res) => {
      try {
        if (!req.user) {
          return res.status(401).json({ error: "User not authenticated" });
        }

        const organizationId = requireOrgId(req);
        const formId = Number(req.params.formId);
        const patientId = Number(req.body.patientId);
        if (!patientId) {
          return res.status(400).json({ error: "patientId is required" });
        }

        const preview = await formService.previewShareEmail({
          formId,
          organizationId,
          patientId,
          sentById: req.user.id,
        });
        res.json(preview);
      } catch (error) {
        console.error("Error generating share preview:", error);
        res.status(500).json({ error: (error as Error).message || "Failed to preview share email" });
      }
    },
  );

  app.delete(
    "/api/forms/:formId",
    authMiddleware,
    requireRole(["admin", "doctor", "nurse"]),
    async (req: TenantRequest, res) => {
      try {
        const organizationId = requireOrgId(req);
        const formId = Number(req.params.formId);
        if (!formId) {
          return res.status(400).json({ error: "formId is required" });
        }
        await formService.deleteForm(formId, organizationId);
        res.status(204).send();
      } catch (error) {
        console.error("Error deleting form:", error);
        res.status(500).json({ error: (error as Error).message || "Failed to delete form" });
      }
    },
  );

  // Analytics endpoints
  app.get("/api/analytics", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const analytics = await storage.getAnalytics(req.tenant!.id);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).json({ error: "Failed to fetch analytics" });
    }
  });

  // Automation endpoints
  app.get("/api/automation/rules", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const rules = await storage.getAutomationRules(req.tenant!.id);
      res.json(rules);
    } catch (error) {
      console.error("Error fetching automation rules:", error);
      res.status(500).json({ error: "Failed to fetch automation rules" });
    }
  });

  app.get("/api/automation/stats", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const stats = await storage.getAutomationStats(req.tenant!.id);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching automation stats:", error);
      res.status(500).json({ error: "Failed to fetch automation stats" });
    }
  });

  app.post("/api/automation/rules/:id/toggle", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const rule = await storage.toggleAutomationRule(req.params.id, req.tenant!.id);
      res.json(rule);
    } catch (error) {
      console.error("Error toggling automation rule:", error);
      res.status(500).json({ error: "Failed to toggle automation rule" });
    }
  });

  // Reset Twilio client endpoint
  app.post("/api/messaging/reset-twilio", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const { resetTwilioClient } = await import('./messaging-service');
      const success = resetTwilioClient();
      res.json({ 
        success, 
        message: success ? 'Twilio client reset successfully' : 'Failed to reset Twilio client - check credentials' 
      });
    } catch (error) {
      console.error("Error resetting Twilio client:", error);
      res.status(500).json({ error: "Failed to reset Twilio client" });
    }
  });

  // Messaging endpoints
  app.get("/api/messaging/conversations", authMiddleware, async (req: TenantRequest, res) => {
    try {
      console.log('üîç CONVERSATIONS REQUEST - Headers:', JSON.stringify({
        'x-tenant-subdomain': req.headers['x-tenant-subdomain'],
        'authorization': req.headers['authorization'] ? 'present' : 'missing'
      }));
      console.log('üîç TENANT INFO:', JSON.stringify(req.tenant));
      console.log('üîç USER INFO:', JSON.stringify(req.user));
      
      const orgId = req.user?.organizationId || req.tenant?.id || 1; // Fallback to org 1
      console.log(`üîç USING ORG ID: ${orgId}`);
      
      const conversations = await storage.getConversations(orgId, req.user?.id);
      console.log(`üîç RETURNED CONVERSATIONS: ${conversations.length}`);
      res.json(conversations);
    } catch (error) {
      console.error("Error fetching conversations:", error);
      res.status(500).json({ error: "Failed to fetch conversations" });
    }
  });

  app.get("/api/messaging/messages/:conversationId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      // Add cache-busting headers to prevent stale reads
      res.set({
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      });
      
      const messages = await storage.getMessages(req.params.conversationId, req.tenant!.id);
      console.log(`üîç API GET MESSAGES - Returning ${messages.length} messages for conversation ${req.params.conversationId}`);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching messages:", error);
      res.status(500).json({ error: "Failed to fetch messages" });
    }
  });

  // Endpoint to debug conversations
  app.get("/api/messaging/debug", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const conversations = await storage.getConversations(req.tenant!.id, req.user?.id);
      console.log("üîç DEBUG - Raw conversations:", JSON.stringify(conversations, null, 2));
      res.json({ conversations, count: conversations.length });
    } catch (error) {
      console.error("Error debugging conversations:", error);
      res.status(500).json({ error: "Failed to debug conversations" });
    }
  });

  // Endpoint to fix existing duplicate conversations
  app.post("/api/messaging/consolidate", authMiddleware, async (req: TenantRequest, res) => {
    try {
      console.log("üîÑ Manual consolidation triggered");
      await storage.consolidateAllDuplicateConversations(req.tenant!.id);
      res.json({ success: true, message: "Duplicate conversations consolidated" });
    } catch (error) {
      console.error("Error consolidating conversations:", error);
      res.status(500).json({ error: "Failed to consolidate conversations" });
    }
  });

  // Twilio configuration diagnostic endpoint
  app.get("/api/messaging/twilio-config", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const config = {
        phoneNumber: process.env.TWILIO_PHONE_NUMBER || null,
        accountSid: process.env.TWILIO_ACCOUNT_SID ? process.env.TWILIO_ACCOUNT_SID.substring(0, 10) + '...' : null,
        authToken: process.env.TWILIO_AUTH_TOKEN ? 'Configured' : null,
        isConfigured: !!(process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN && process.env.TWILIO_PHONE_NUMBER)
      };
      res.json(config);
    } catch (error) {
      console.error("Error checking Twilio config:", error);
      res.status(500).json({ error: "Failed to check configuration" });
    }
  });

  // Twilio account information endpoint
  app.get("/api/messaging/account-info", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const accountInfo = await messagingService.getAccountInfo();
      res.json(accountInfo);
    } catch (error) {
      console.error("Error getting account info:", error);
      res.status(500).json({ error: "Failed to get account information" });
    }
  });

  app.post("/api/messaging/send", authMiddleware, async (req: TenantRequest, res) => {
    try {
      console.log("üì® POST /api/messaging/send - Received message data:", JSON.stringify(req.body, null, 2));
      const { conversationId, recipientId, content, message: messageText, type, priority, phoneNumber, messageType } = req.body;
      console.log(`üì® MESSAGE ROUTING - messageType: "${messageType}", type: "${type}", recipientId: "${recipientId}"`);
      console.log(`üì® EMAIL CHECK - isEmail: ${messageType === 'email'}, notInternal: ${type !== 'internal'}, willSendEmail: ${messageType === 'email' && type !== 'internal'}`);
      
      // Add authenticated user information to message data
      const messageDataWithUser = {
        conversationId, // Include conversationId from request
        recipientId,
        content: content || messageText, // Handle both content and message fields
        type,
        priority,
        phoneNumber,
        messageType,
        senderId: req.user!.id,
        senderName: req.user!.email, // Using email as fallback since firstName/lastName might not be available
        senderRole: req.user!.role
      };
      
      // Consolidate any duplicate conversations before sending the message
      await storage.consolidateDuplicateConversations(messageDataWithUser.senderId, messageDataWithUser.recipientId, req.tenant!.id);
      
      // Store the message in the database
      const message = await storage.sendMessage(messageDataWithUser, req.tenant!.id);
      
      // If phone number is provided AND messageType is sms/whatsapp, attempt external delivery
      const recipientPhone = phoneNumber || req.body.recipient;
      console.log(`üì± EXTERNAL DELIVERY CHECK - phoneNumber: "${phoneNumber}", recipientPhone: "${recipientPhone}", messageType: "${messageType}", type: "${type}"`);
      console.log(`üì± CONDITION CHECK - hasPhone: ${!!recipientPhone}, isSmsOrWhatsApp: ${messageType === 'sms' || messageType === 'whatsapp'}, notInternal: ${type !== 'internal'}`);
      
      if (recipientPhone && (messageType === 'sms' || messageType === 'whatsapp') && type !== 'internal') {
        try {
          const result = await messagingService.sendMessage({
            to: recipientPhone,
            message: messageDataWithUser.content,
            type: messageType,
            priority: priority || 'normal'
          });
          
          console.log(`${messageType.toUpperCase()} delivery result:`, result);
          
          if (result.success) {
            console.log(`${messageType.toUpperCase()} sent successfully:`, result.messageId);
            // Update message with delivery status and external ID
            message.deliveryStatus = 'sent';
            message.externalMessageId = result.messageId;
            
            // Start polling for delivery status after a short delay
            setTimeout(async () => {
              try {
                const status = await messagingService.getMessageStatus(result.messageId!);
                if (status) {
                  await storage.updateMessageDeliveryStatus(result.messageId!, status.status, status.errorCode, status.errorMessage);
                  console.log(`üì± Updated message ${result.messageId} status to: ${status.status}`);
                }
              } catch (error) {
                console.error('üì± Error polling message status:', error);
              }
            }, 5000); // Poll after 5 seconds
            
            return res.json(message);
          } else {
            console.error(`${messageType.toUpperCase()} sending failed:`, result.error);
            
            // Only treat as internal if credentials are completely missing (not authentication failures)
            if (result.error?.includes('not properly configured') && !process.env.TWILIO_ACCOUNT_SID) {
              console.log(`üì± Twilio not configured (missing credentials), treating SMS as internal message`);
              await storage.updateMessageDeliveryStatus(message.id, 'delivered', undefined, undefined);
              return res.json(message);
            }
            
            message.deliveryStatus = 'failed';
            message.error = result.error;
            // Return error response for failed delivery
            return res.status(400).json({ 
              error: `Failed to send ${messageType.toUpperCase()}: ${result.error}`,
              message: message
            });
          }
        } catch (twilioError: any) {
          console.error('Twilio API error:', twilioError);
          // Only treat as internal if credentials are completely missing (not authentication failures)
          if (twilioError.message?.includes('not properly configured') && !process.env.TWILIO_ACCOUNT_SID) {
            console.log(`üì± Twilio not configured (missing credentials), treating SMS as internal message`);
            await storage.updateMessageDeliveryStatus(message.id, 'delivered', undefined, undefined);
            return res.json(message);
          }
          
          message.deliveryStatus = 'failed';
          message.error = 'Failed to send via Twilio';
          // Return error response for Twilio failures
          return res.status(400).json({ 
            error: `SMS/WhatsApp delivery failed: ${twilioError.message || 'Twilio authentication error'}`,
            message: message
          });
        }
      } else if (messageType === 'voice' && type !== 'internal') {
        // Handle voice call (text-to-speech)
        console.log(`üìû VOICE CALL TRIGGERED - recipientId: "${recipientId}", phoneNumber: "${phoneNumber}"`);
        try {
          // Get phone number from recipient if not provided
          let voicePhoneNumber = phoneNumber;
          
          if (!voicePhoneNumber && typeof recipientId === 'string') {
            // Try to find phone number from patients
            const allPatients = await storage.getPatientsByOrganization(req.tenant!.id);
            const matchedPatient = allPatients.find(patient => {
              const fullName = `${patient.firstName} ${patient.lastName}`.trim();
              return fullName === recipientId || patient.firstName === recipientId;
            });
            
            if (matchedPatient) {
              voicePhoneNumber = matchedPatient.phone || matchedPatient.phoneNumber || matchedPatient.mobile;
            }
          }
          
          if (!voicePhoneNumber) {
            console.error('üìû No phone number found for voice call to:', recipientId);
            await storage.updateMessageDeliveryStatus(message.id, 'failed', undefined, 'No phone number found for voice call');
            return res.status(400).json({
              error: 'Voice call failed: No phone number found for recipient',
              message: message
            });
          }
          
          console.log(`üìû Making voice call to: ${voicePhoneNumber}`);
          const voiceResult = await messagingService.makeVoiceCall(voicePhoneNumber, messageDataWithUser.content);
          
          if (voiceResult.success) {
            console.log(`üìû Voice call initiated successfully:`, voiceResult.messageId);
            message.deliveryStatus = 'sent';
            message.externalMessageId = voiceResult.messageId;
            await storage.updateMessageDeliveryStatus(message.id, 'sent', undefined, undefined);
            return res.json(message);
          } else {
            console.error(`üìû Voice call failed:`, voiceResult.error);
            await storage.updateMessageDeliveryStatus(message.id, 'failed', undefined, voiceResult.error);
            message.deliveryStatus = 'failed';
            message.error = voiceResult.error;
            return res.status(400).json({
              error: `Voice call failed: ${voiceResult.error}`,
              message: message
            });
          }
        } catch (voiceError: any) {
          console.error('üìû Voice call error:', voiceError);
          await storage.updateMessageDeliveryStatus(message.id, 'failed', undefined, voiceError.message);
          message.deliveryStatus = 'failed';
          message.error = 'Voice call error';
          return res.status(400).json({
            error: `Voice call failed: ${voiceError.message || 'Unknown error'}`,
            message: message
          });
        }
      } else if (messageType === 'email' && type !== 'internal') {
        // Handle email sending
        console.log(`üìß EMAIL SEND TRIGGERED - recipientId: "${recipientId}", type: "${type}"`);
        try {
          // Get recipient's email address
          let recipientEmail = null;
          let recipientName = 'Recipient';
          
          // Check if recipientId is a number (ID) or string (name)
          if (typeof recipientId === 'number') {
            // Try to get recipient from users table first
            const recipientUser = await storage.getUser(recipientId, req.tenant!.id);
            if (recipientUser && recipientUser.email) {
              recipientEmail = recipientUser.email;
              recipientName = recipientUser.firstName && recipientUser.lastName 
                ? `${recipientUser.firstName} ${recipientUser.lastName}`
                : recipientUser.firstName || recipientUser.email;
            } else {
              // Try to get from patients table
              const recipientPatient = await storage.getPatient(recipientId, req.tenant!.id);
              if (recipientPatient && recipientPatient.email) {
                recipientEmail = recipientPatient.email;
                recipientName = `${recipientPatient.firstName} ${recipientPatient.lastName}`;
              }
            }
          } else if (typeof recipientId === 'string') {
            // RecipientId is a name, need to look up by name
            // Try users first
            const allUsers = await storage.getUsersByOrganization(req.tenant!.id);
            const matchedUser = allUsers.find(user => {
              const fullName = `${user.firstName} ${user.lastName}`.trim();
              return fullName === recipientId || 
                     user.firstName === recipientId ||
                     user.email === recipientId;
            });
            
            if (matchedUser && matchedUser.email) {
              recipientEmail = matchedUser.email;
              recipientName = `${matchedUser.firstName} ${matchedUser.lastName}`;
            } else {
              // Try patients table
              const allPatients = await storage.getPatientsByOrganization(req.tenant!.id);
              const matchedPatient = allPatients.find(patient => {
                const fullName = `${patient.firstName} ${patient.lastName}`.trim();
                return fullName === recipientId || 
                       patient.firstName === recipientId ||
                       patient.email === recipientId;
              });
              
              if (matchedPatient && matchedPatient.email) {
                recipientEmail = matchedPatient.email;
                recipientName = `${matchedPatient.firstName} ${matchedPatient.lastName}`;
              }
            }
          }
          
          console.log(`üìß EMAIL LOOKUP RESULT - recipientEmail: "${recipientEmail}", recipientName: "${recipientName}"`);
          
          if (!recipientEmail) {
            console.error('No email address found for recipient:', recipientId);
            await storage.updateMessageDeliveryStatus(message.id, 'failed', undefined, 'No email address found for recipient');
            return res.status(400).json({ 
              error: 'Email sending failed: No email address found for recipient',
              message: message
            });
          }
          
          // Get sender's name for email
          const senderUser = await storage.getUser(req.user!.id, req.tenant!.id);
          const senderName = senderUser && senderUser.firstName && senderUser.lastName
            ? `${senderUser.firstName} ${senderUser.lastName}`
            : req.user!.email;
          
          // Send email using the email service
          const subject = req.body.subject || 'Message from your healthcare provider';
          const emailSuccess = await emailService.sendEmail({
            to: recipientEmail,
            subject: subject,
            html: `
              <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <h2 style="color: #2563eb; border-bottom: 2px solid #2563eb; padding-bottom: 10px;">
                  ${subject}
                </h2>
                <div style="margin: 20px 0; padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px;">
                  <p style="white-space: pre-wrap;">${messageDataWithUser.content}</p>
                </div>
                <p style="color: #666; font-size: 12px; margin-top: 30px; border-top: 1px solid #e5e7eb; padding-top: 15px;">
                  This message was sent from your healthcare provider.<br>
                  Sent by: ${senderName}
                </p>
              </div>
            `,
            text: messageDataWithUser.content
          });
          
          if (emailSuccess) {
            console.log(`üìß Email sent successfully to ${recipientEmail}`);
            await storage.updateMessageDeliveryStatus(message.id, 'delivered', undefined, undefined);
            message.deliveryStatus = 'delivered';
            return res.json(message);
          } else {
            console.error(`üìß Email sending failed to ${recipientEmail}`);
            await storage.updateMessageDeliveryStatus(message.id, 'failed', undefined, 'Email service failed');
            message.deliveryStatus = 'failed';
            message.error = 'Email service failed';
            return res.status(400).json({ 
              error: 'Failed to send email',
              message: message
            });
          }
        } catch (emailError: any) {
          console.error('Email sending error:', emailError);
          await storage.updateMessageDeliveryStatus(message.id, 'failed', undefined, emailError.message);
          message.deliveryStatus = 'failed';
          message.error = 'Email sending error';
          return res.status(400).json({ 
            error: `Email delivery failed: ${emailError.message || 'Unknown error'}`,
            message: message
          });
        }
      } else {
        // For internal messages, mark as delivered immediately since they don't go through SMS/WhatsApp/Email
        await storage.updateMessageDeliveryStatus(message.id, 'delivered', undefined, undefined);
        console.log(`‚úÖ Internal message ${message.id} marked as delivered`);
        
        // For internal messages, broadcast to other users via WebSocket
        // Add delay to ensure database transaction is fully committed across all connections
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Use the message's conversationId from the storage response, not messageDataWithUser
        const actualConversationId = message.conversationId;
        console.log(`üîç DEBUG - Using actual conversationId from message: ${actualConversationId}`);
        
        // Verify the message exists in database before broadcasting
        const verifyMessage = await storage.getMessages(actualConversationId, req.tenant!.id);
        console.log(`üîç VERIFICATION - Database contains ${verifyMessage.length} messages before broadcast`);
        
        const broadcastMessage = req.app.get('broadcastMessage');
        console.log(`üîç DEBUG - broadcastMessage function exists:`, !!broadcastMessage);
        console.log(`üîç DEBUG - messageDataWithUser.recipientId:`, messageDataWithUser.recipientId);
        console.log(`üîç DEBUG - actual conversationId:`, actualConversationId);
        if (broadcastMessage && messageDataWithUser.recipientId) {
          // Try to find recipient user ID if recipientId is a name
          if (typeof messageDataWithUser.recipientId === 'string') {
            try {
              // Look up user by name for WebSocket broadcasting
              const allUsers = await storage.getUsersByOrganization(req.tenant!.id);
              const recipientUser = allUsers.find(user => 
                user.firstName + ' ' + user.lastName === messageDataWithUser.recipientId ||
                user.email === messageDataWithUser.recipientId
              );
              if (recipientUser) {
                broadcastMessage(recipientUser.id, {
                  type: 'new_message',
                  message: message,
                  conversationId: actualConversationId
                });
                console.log(`üì® Broadcasted message to recipient user ID: ${recipientUser.id}`);
              }
            } catch (error) {
              console.error('Error finding recipient for WebSocket broadcast:', error);
            }
          } else if (typeof messageDataWithUser.recipientId === 'number') {
            // Direct user ID broadcast
            broadcastMessage(messageDataWithUser.recipientId, {
              type: 'new_message', 
              message: message,
              conversationId: actualConversationId
            });
            console.log(`üì® Broadcasted message to recipient user ID: ${messageDataWithUser.recipientId}`);
          }
        }
        
        // Also broadcast to any other users who might be viewing the same conversation
        console.log(`üîç DEBUG CONVERSATION - broadcastMessage exists:`, !!broadcastMessage);
        console.log(`üîç DEBUG CONVERSATION - conversationId:`, actualConversationId);
        if (broadcastMessage && actualConversationId) {
          try {
            // Get conversation data to find all participants
            console.log(`üîç DEBUG - Getting conversations for org: ${req.organizationId}`);
            const conversations = await storage.getConversations(req.tenant!.id);
            console.log(`üîç DEBUG - Found ${conversations.length} conversations`);
            const currentConversation = conversations.find(c => c.id === actualConversationId);
            console.log(`üîç DEBUG - Current conversation found:`, currentConversation ? 'YES' : 'NO');
            console.log(`üîç DEBUG - Current conversation participants:`, currentConversation?.participants);
            
            if (currentConversation && currentConversation.participants) {
              // Get unique participant IDs from conversation participants
              const participantIds = new Set();
              console.log(`üîç DEBUG - Processing ${currentConversation.participants.length} participants`);
              console.log(`üîç DEBUG - Current sender user ID:`, req.user!.id);
              for (const participant of currentConversation.participants) {
                console.log(`üîç DEBUG - Processing participant:`, participant);
                console.log(`üîç DEBUG - Participant ID type:`, typeof participant.id, 'Value:', participant.id);
                let participantId: number | null = null;
                
                if (typeof participant.id === 'number') {
                  participantId = participant.id;
                } else if (typeof participant.id === 'string') {
                  // Try to map string participant names to actual user IDs
                  const allUsers = await storage.getUsersByOrganization(req.tenant!.id);
                  console.log(`üîç DEBUG - Looking for participant "${participant.id}" among ${allUsers.length} users`);
                  console.log(`üîç DEBUG - Available users:`, allUsers.map(u => ({ id: u.id, firstName: u.firstName, lastName: u.lastName, email: u.email })));
                  
                  const matchedUser = allUsers.find(user => {
                    const fullName = `${user.firstName} ${user.lastName}`.trim();
                    console.log(`üîç DEBUG - Comparing "${participant.id}" with "${fullName}", "${user.firstName}", "${user.email}"`);
                    return fullName === participant.id || 
                           user.firstName === participant.id ||
                           user.email === participant.id;
                  });
                  
                  if (matchedUser) {
                    participantId = matchedUser.id;
                    console.log(`üîß Mapped participant "${participant.id}" to user ID ${matchedUser.id}`);
                  } else {
                    console.log(`‚ùå No user found for participant "${participant.id}"`);
                    // Try to parse as number
                    const parsed = parseInt(participant.id);
                    if (!isNaN(parsed)) {
                      participantId = parsed;
                    }
                  }
                }
                
                // Add all valid numeric IDs including the current sender for real-time UI updates
                console.log(`üîç DEBUG - Participant processing result: participantId=${participantId}, sender=${req.user!.id}, shouldAdd=${!!participantId}`);
                if (participantId) {
                  participantIds.add(participantId);
                  console.log(`üîç DEBUG - Added participant ${participantId} to broadcast list`);
                }
              }
              
              console.log(`üì® Broadcasting to ${participantIds.size} conversation participants:`, Array.from(participantIds));
              
              // Broadcast to all conversation participants
              participantIds.forEach(userId => {
                broadcastMessage(userId, {
                  type: 'new_message',
                  message: message,
                  conversationId: actualConversationId
                });
                console.log(`üì® Broadcasted to conversation participant: ${userId}`);
              });
            }
          } catch (error) {
            console.error('Error broadcasting to conversation participants:', error);
          }
        }
        
        res.json(message);
      }
    } catch (error) {
      console.error("Error sending message:", error);
      res.status(500).json({ error: "Failed to send message" });
    }
  });

  // Fix conversation participants endpoint
  app.post("/api/messaging/fix-participants", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      await storage.fixAllConversationParticipants(req.tenant!.id);
      res.json({ success: true, message: "All conversation participants have been fixed" });
    } catch (error) {
      console.error("Error fixing conversation participants:", error);
      res.status(500).json({ error: "Failed to fix conversation participants" });
    }
  });

  // Delete conversation endpoint
  app.delete("/api/messaging/conversations/:conversationId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const conversationId = req.params.conversationId;
      console.log(`üóëÔ∏è DELETE CONVERSATION REQUEST: ${conversationId}`);
      
      const result = await storage.deleteConversation(conversationId, req.tenant!.id);
      
      if (result) {
        console.log(`üóëÔ∏è CONVERSATION DELETED SUCCESSFULLY: ${conversationId}`);
        res.json({ success: true, message: "Conversation deleted successfully" });
      } else {
        console.log(`üóëÔ∏è CONVERSATION NOT FOUND: ${conversationId}`);
        res.status(404).json({ error: "Conversation not found" });
      }
    } catch (error) {
      console.error("üóëÔ∏è ERROR DELETING CONVERSATION:", error);
      res.status(500).json({ error: "Failed to delete conversation" });
    }
  });

  app.get("/api/messaging/campaigns", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const campaigns = await storage.getMessageCampaigns(req.tenant!.id);
      res.json(campaigns);
    } catch (error) {
      console.error("Error fetching campaigns:", error);
      res.status(500).json({ error: "Failed to fetch campaigns" });
    }
  });

  app.post("/api/messaging/campaigns", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      console.log("üìß CREATE CAMPAIGN - Request body:", JSON.stringify(req.body, null, 2));
      console.log("üìß CREATE CAMPAIGN - User ID:", req.user!.id);
      console.log("üìß CREATE CAMPAIGN - Tenant ID:", req.tenant!.id);
      
      const campaignData = {
        ...req.body,
        createdBy: req.user!.id
      };
      
      console.log("üìß CREATE CAMPAIGN - Campaign data to save:", JSON.stringify(campaignData, null, 2));
      
      const campaign = await storage.createMessageCampaign(campaignData, req.tenant!.id);
      console.log("üìß CREATE CAMPAIGN - Success! Created campaign:", campaign.id);
      res.json(campaign);
    } catch (error: any) {
      console.error("‚ùå CREATE CAMPAIGN - Error:", error.message || error);
      console.error("‚ùå CREATE CAMPAIGN - Stack:", error.stack);
      res.status(500).json({ error: "Failed to create campaign", details: error.message });
    }
  });

  app.put("/api/messaging/campaigns/:id", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const campaignId = parseInt(req.params.id);
      const campaignData = {
        ...req.body,
        createdBy: req.user!.id
      };
      const campaign = await storage.updateMessageCampaign(campaignId, campaignData, req.tenant!.id);
      res.json(campaign);
    } catch (error) {
      console.error("Error updating campaign:", error);
      res.status(500).json({ error: "Failed to update campaign" });
    }
  });

  app.delete("/api/messaging/campaigns/:id", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const campaignId = parseInt(req.params.id);
      await storage.deleteMessageCampaign(campaignId, req.tenant!.id);
      res.json({ success: true, message: "Campaign deleted successfully" });
    } catch (error) {
      console.error("Error deleting campaign:", error);
      res.status(500).json({ error: "Failed to delete campaign" });
    }
  });

  app.post("/api/messaging/campaigns/:id/send", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const campaignId = parseInt(req.params.id);
      const organizationId = req.tenant!.id;
      
      const campaigns = await storage.getMessageCampaigns(organizationId);
      const campaign = campaigns.find((c: any) => c.id === campaignId);
      
      if (!campaign) {
        return res.status(404).json({ error: "Campaign not found" });
      }

      const recipients = campaign.recipients || [];
      if (recipients.length === 0) {
        return res.status(400).json({ error: "No recipients in this campaign" });
      }

      const deliveryLog: any[] = [];
      let totalSent = 0;
      let totalFailed = 0;

      for (const recipient of recipients) {
        try {
          if ((campaign.type === 'sms' || campaign.type === 'both') && recipient.phone) {
            const personalizedContent = campaign.content
              .replace(/\[FirstName\]/gi, recipient.name?.split(' ')[0] || '')
              .replace(/\[LastName\]/gi, recipient.name?.split(' ').slice(1).join(' ') || '');
            
            const result = await messagingService.sendSMS(recipient.phone, personalizedContent);
            
            if (result.success) {
              deliveryLog.push({ recipient: recipient.name, phone: recipient.phone, status: 'sent', type: 'sms' });
              totalSent++;
            } else {
              deliveryLog.push({ recipient: recipient.name, phone: recipient.phone, status: 'failed', error: result.error, type: 'sms' });
              totalFailed++;
            }
          }
          
          if ((campaign.type === 'email' || campaign.type === 'both') && recipient.email) {
            const { sendEmail } = await import('./services/email-service');
            const emailResult = await sendEmail({
              to: recipient.email,
              subject: campaign.subject || 'Campaign Message',
              text: campaign.content
                .replace(/\[FirstName\]/gi, recipient.name?.split(' ')[0] || '')
                .replace(/\[LastName\]/gi, recipient.name?.split(' ').slice(1).join(' ') || ''),
              html: `<p>${campaign.content
                .replace(/\[FirstName\]/gi, recipient.name?.split(' ')[0] || '')
                .replace(/\[LastName\]/gi, recipient.name?.split(' ').slice(1).join(' ') || '')}</p>`
            });
            
            if (emailResult.success) {
              deliveryLog.push({ recipient: recipient.name, email: recipient.email, status: 'sent', type: 'email' });
              totalSent++;
            } else {
              deliveryLog.push({ recipient: recipient.name, email: recipient.email, status: 'failed', error: emailResult.error, type: 'email' });
              totalFailed++;
            }
          }
        } catch (err: any) {
          deliveryLog.push({ recipient: recipient.name, status: 'failed', error: err.message });
          totalFailed++;
        }
      }

      await storage.updateMessageCampaign(campaignId, {
        status: 'sent',
        sentCount: totalSent,
        sentAt: new Date()
      }, organizationId);

      res.json({
        success: true,
        totalRecipients: recipients.length,
        totalSent,
        totalFailed,
        deliveryLog
      });
    } catch (error: any) {
      console.error("Error sending campaign:", error);
      res.status(500).json({ error: error.message || "Failed to send campaign" });
    }
  });

  // Send message to a single recipient (for real-time progress tracking)
  app.post("/api/messaging/campaigns/:id/send-single", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const campaignId = parseInt(req.params.id);
      const organizationId = req.tenant!.id;
      const { recipient, content, type, subject } = req.body;

      console.log(`üì§ SEND-SINGLE: Sending ${type} to ${recipient.name}, phone: ${recipient.phone}, email: ${recipient.email}`);

      if (!recipient || !content) {
        return res.status(400).json({ error: "Recipient and content are required" });
      }

      let success = false;
      let error = '';
      const personalizedContent = content
        .replace(/\[FirstName\]/gi, recipient.name?.split(' ')[0] || '')
        .replace(/\[LastName\]/gi, recipient.name?.split(' ').slice(1).join(' ') || '');

      // Handle SMS sending
      if ((type === 'sms' || type === 'both') && recipient.phone) {
        console.log(`üì± SEND-SINGLE: Sending SMS to ${recipient.phone}`);
        const smsResult = await messagingService.sendSMS(recipient.phone, personalizedContent);
        console.log(`üì± SEND-SINGLE: SMS result:`, smsResult);
        if (smsResult.success) {
          success = true;
        } else {
          error = smsResult.error || 'SMS sending failed';
        }
      }
      
      // Handle Email sending
      if ((type === 'email' || type === 'both') && recipient.email) {
        console.log(`üìß SEND-SINGLE: Sending Email to ${recipient.email}`);
        const emailResult = await emailService.sendEmail({
          to: recipient.email,
          subject: subject || 'Campaign Message',
          text: personalizedContent,
          html: `<p>${personalizedContent}</p>`
        });
        console.log(`üìß SEND-SINGLE: Email result:`, emailResult);
        // emailService.sendEmail returns a boolean directly
        if (emailResult === true) {
          success = true;
        } else {
          error = error || 'Email sending failed';
        }
      }

      console.log(`üì§ SEND-SINGLE: Final result - success: ${success}, error: ${error}`);

      if (success) {
        res.json({ 
          success: true, 
          recipient: recipient.name, 
          phone: recipient.phone,
          email: recipient.email,
          status: 'sent' 
        });
      } else {
        res.json({ 
          success: false, 
          recipient: recipient.name, 
          phone: recipient.phone,
          email: recipient.email,
          status: 'failed', 
          error: error 
        });
      }
    } catch (error: any) {
      console.error("Error sending single message:", error);
      res.status(500).json({ error: error.message || "Failed to send message" });
    }
  });

  // Update campaign status after all sends complete
  app.post("/api/messaging/campaigns/:id/finalize-send", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const campaignId = parseInt(req.params.id);
      const organizationId = req.tenant!.id;
      const { sentCount } = req.body;

      await storage.updateMessageCampaign(campaignId, {
        status: 'sent',
        sentCount: sentCount || 0,
        sentAt: new Date()
      }, organizationId);

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error finalizing campaign:", error);
      res.status(500).json({ error: error.message || "Failed to finalize campaign" });
    }
  });

  app.get("/api/messaging/templates", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const templates = await storage.getMessageTemplates(req.tenant!.id);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({ error: "Failed to fetch templates" });
    }
  });

  app.post("/api/messaging/templates", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      // Validate request body with Zod schema
      const validationResult = insertMessageTemplateSchema.omit({ createdBy: true, organizationId: true }).safeParse(req.body);
      
      if (!validationResult.success) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: validationResult.error.errors 
        });
      }

      const templateData = {
        ...validationResult.data,
        createdBy: req.user!.id
      };
      const template = await storage.createMessageTemplate(templateData, req.tenant!.id);
      res.json(template);
    } catch (error) {
      console.error("Error creating template:", error);
      res.status(500).json({ error: "Failed to create template" });
    }
  });

  app.put("/api/messaging/templates/:id", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const templateId = parseInt(req.params.id);
      
      // Validate request body with Zod schema
      const validationResult = insertMessageTemplateSchema.omit({ createdBy: true, organizationId: true }).safeParse(req.body);
      
      if (!validationResult.success) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: validationResult.error.errors 
        });
      }

      const templateData = {
        ...validationResult.data,
        createdBy: req.user!.id
      };
      const template = await storage.updateMessageTemplate(templateId, templateData, req.tenant!.id);
      res.json(template);
    } catch (error) {
      console.error("Error updating template:", error);
      res.status(500).json({ error: "Failed to update template" });
    }
  });

  app.delete("/api/messaging/templates/:id", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const templateId = parseInt(req.params.id);
      const deleted = await storage.deleteMessageTemplate(templateId, req.tenant!.id);
      
      if (!deleted) {
        return res.status(404).json({ error: "Template not found or failed to delete" });
      }

      res.json({ success: true, message: "Template deleted successfully" });
    } catch (error) {
      console.error("Error deleting template:", error);
      res.status(500).json({ error: "Failed to delete template" });
    }
  });

  app.post("/api/messaging/templates/:id/send-to-selected", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const templateId = parseInt(req.params.id);
      const { recipients } = req.body;

      if (!recipients || !Array.isArray(recipients) || recipients.length === 0) {
        return res.status(400).json({ error: "Recipients array is required and must not be empty" });
      }
      
      // Get template
      const templates = await storage.getMessageTemplates(req.tenant!.id);
      const template = templates.find(t => t.id === templateId);
      
      if (!template) {
        return res.status(404).json({ error: "Template not found" });
      }

      // Get all users in organization
      const allUsers = await storage.getUsersByOrganization(req.tenant!.id);
      
      // Get sender's full user details
      const senderUser = allUsers.find(u => u.id === req.user!.id);
      const senderName = senderUser 
        ? `${senderUser.firstName} ${senderUser.lastName}`.trim() || senderUser.email 
        : req.user!.email;
      
      // Filter users based on provided recipient emails
      const selectedUsers = allUsers.filter(user => recipients.includes(user.email));
      
      if (selectedUsers.length === 0) {
        return res.status(400).json({ error: "No valid recipients found" });
      }
      
      // Send email to each selected user
      let successCount = 0;
      let failCount = 0;
      
      console.log(`[TEMPLATE-EMAIL] Sending template "${template.name}" to ${selectedUsers.length} recipients`);
      
      for (const user of selectedUsers) {
        if (user.email) {
          try {
            console.log(`[TEMPLATE-EMAIL] Attempting to send to: ${user.email} (${user.firstName} ${user.lastName})`);
            const emailSent = await emailService.sendEmail({
              to: user.email,
              subject: template.subject,
              html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                  <h2>Message from ${senderName}</h2>
                  <div style="margin-top: 20px;">
                    ${template.content.replace(/\n/g, '<br>')}
                  </div>
                  <hr style="margin-top: 30px; border: none; border-top: 1px solid #eee;">
                  <p style="color: #666; font-size: 12px;">
                    This is an automated message from ${req.tenant!.name}.
                  </p>
                </div>
              `
            });
            
            if (emailSent) {
              successCount++;
              console.log(`[TEMPLATE-EMAIL] ‚úÖ Successfully sent to ${user.email}`);
            } else {
              failCount++;
              console.log(`[TEMPLATE-EMAIL] ‚ùå Failed to send to ${user.email} - email service returned false`);
            }
          } catch (error) {
            console.error(`[TEMPLATE-EMAIL] ‚ùå Exception sending to ${user.email}:`, error);
            failCount++;
          }
        } else {
          console.log(`[TEMPLATE-EMAIL] ‚ö†Ô∏è Skipping user ${user.id} - no email address`);
          failCount++;
        }
      }
      
      console.log(`[TEMPLATE-EMAIL] Results: ${successCount} succeeded, ${failCount} failed out of ${selectedUsers.length} total`)

      // Update template usage count
      await storage.updateMessageTemplate(templateId, { usageCount: (template.usageCount || 0) + 1 }, req.tenant!.id);

      res.json({
        message: `Email sent to ${successCount} recipients`,
        successCount,
        failCount,
        totalRecipients: selectedUsers.length
      });
    } catch (error) {
      console.error("Error sending template to selected recipients:", error);
      res.status(500).json({ error: "Failed to send template" });
    }
  });

  app.post("/api/messaging/templates/:id/send-to-all", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const templateId = parseInt(req.params.id);
      
      // Get template
      const templates = await storage.getMessageTemplates(req.tenant!.id);
      const template = templates.find(t => t.id === templateId);
      
      if (!template) {
        return res.status(404).json({ error: "Template not found" });
      }

      // Get sender's full user details
      const allOrgUsers = await storage.getUsersByOrganization(req.tenant!.id);
      const senderUser = allOrgUsers.find(u => u.id === req.user!.id);
      const senderName = senderUser 
        ? `${senderUser.firstName} ${senderUser.lastName}`.trim() || senderUser.email 
        : req.user!.email;

      // Get all users in organization
      const users = await storage.getUsersByOrganization(req.tenant!.id);
      
      // Send email to each user
      let successCount = 0;
      let failCount = 0;
      
      console.log(`[TEMPLATE-EMAIL-ALL] Sending template "${template.name}" to all ${users.length} users`);
      
      for (const user of users) {
        if (user.email) {
          try {
            console.log(`[TEMPLATE-EMAIL-ALL] Attempting to send to: ${user.email} (${user.firstName} ${user.lastName})`);
            const emailSent = await emailService.sendEmail({
              to: user.email,
              subject: template.subject,
              html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                  <h2>Message from ${senderName}</h2>
                  <div style="margin-top: 20px;">
                    ${template.content.replace(/\n/g, '<br>')}
                  </div>
                  <hr style="margin-top: 30px; border: none; border-top: 1px solid #eee;">
                  <p style="color: #666; font-size: 12px;">
                    This is an automated message from ${req.tenant!.name}.
                  </p>
                </div>
              `
            });
            
            if (emailSent) {
              successCount++;
              console.log(`[TEMPLATE-EMAIL-ALL] ‚úÖ Successfully sent to ${user.email}`);
            } else {
              failCount++;
              console.log(`[TEMPLATE-EMAIL-ALL] ‚ùå Failed to send to ${user.email} - email service returned false`);
            }
          } catch (emailError) {
            console.error(`[TEMPLATE-EMAIL-ALL] ‚ùå Exception sending to ${user.email}:`, emailError);
            failCount++;
          }
        } else {
          console.log(`[TEMPLATE-EMAIL-ALL] ‚ö†Ô∏è Skipping user ${user.id} - no email address`);
          failCount++;
        }
      }
      
      console.log(`[TEMPLATE-EMAIL-ALL] Results: ${successCount} succeeded, ${failCount} failed out of ${users.length} total`)

      // Update usage count
      await storage.updateMessageTemplate(templateId, { usageCount: template.usageCount + 1 }, req.tenant!.id);

      res.json({ 
        success: true, 
        totalUsers: users.length,
        successCount,
        failCount,
        message: `Email sent successfully to ${successCount} out of ${users.length} users.`
      });
    } catch (error) {
      console.error("Error sending template to all users:", error);
      res.status(500).json({ error: "Failed to send template" });
    }
  });

  // Healthcare-specific messaging endpoints
  app.post("/api/messaging/appointment-reminder", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { patientPhone, patientName, appointmentDate, doctorName, clinicName, messageType = 'sms' } = req.body;
      
      const result = await messagingService.sendAppointmentReminder(
        patientPhone,
        patientName,
        appointmentDate,
        doctorName,
        clinicName,
        messageType
      );
      
      if (result.success) {
        res.json({ success: true, messageId: result.messageId, cost: result.cost });
      } else {
        res.status(400).json({ success: false, error: result.error });
      }
    } catch (error) {
      console.error("Error sending appointment reminder:", error);
      res.status(500).json({ error: "Failed to send appointment reminder" });
    }
  });

  app.post("/api/messaging/lab-results", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { patientPhone, patientName, clinicName, clinicPhone, messageType = 'sms' } = req.body;
      
      const result = await messagingService.sendLabResultsNotification(
        patientPhone,
        patientName,
        clinicName,
        clinicPhone,
        messageType
      );
      
      if (result.success) {
        res.json({ success: true, messageId: result.messageId, cost: result.cost });
      } else {
        res.status(400).json({ success: false, error: result.error });
      }
    } catch (error) {
      console.error("Error sending lab results notification:", error);
      res.status(500).json({ error: "Failed to send lab results notification" });
    }
  });

  app.post("/api/messaging/prescription-ready", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { patientPhone, patientName, pharmacyName, pharmacyAddress, messageType = 'sms' } = req.body;
      
      const result = await messagingService.sendPrescriptionReady(
        patientPhone,
        patientName,
        pharmacyName,
        pharmacyAddress,
        messageType
      );
      
      if (result.success) {
        res.json({ success: true, messageId: result.messageId, cost: result.cost });
      } else {
        res.status(400).json({ success: false, error: result.error });
      }
    } catch (error) {
      console.error("Error sending prescription ready notification:", error);
      res.status(500).json({ error: "Failed to send prescription ready notification" });
    }
  });

  app.post("/api/messaging/emergency", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { patientPhone, patientName, urgentMessage, clinicPhone, messageType = 'sms' } = req.body;
      
      const result = await messagingService.sendEmergencyNotification(
        patientPhone,
        patientName,
        urgentMessage,
        clinicPhone,
        messageType
      );
      
      if (result.success) {
        res.json({ success: true, messageId: result.messageId, cost: result.cost });
      } else {
        res.status(400).json({ success: false, error: result.error });
      }
    } catch (error) {
      console.error("Error sending emergency notification:", error);
      res.status(500).json({ error: "Failed to send emergency notification" });
    }
  });

  app.post("/api/messaging/bulk", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const { recipients, message, messageType = 'sms' } = req.body;
      
      const results = await messagingService.sendBulkMessages(recipients, message, messageType);
      
      const successCount = results.filter(r => r.success).length;
      const failureCount = results.filter(r => !r.success).length;
      
      res.json({
        success: true,
        totalSent: successCount,
        totalFailed: failureCount,
        results: results
      });
    } catch (error) {
      console.error("Error sending bulk messages:", error);
      res.status(500).json({ error: "Failed to send bulk messages" });
    }
  });

  app.get("/api/messaging/status/:messageId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const status = await messagingService.getMessageStatus(req.params.messageId);
      if (status) {
        res.json(status);
      } else {
        res.status(404).json({ error: "Message not found" });
      }
    } catch (error) {
      console.error("Error fetching message status:", error);
      res.status(500).json({ error: "Failed to fetch message status" });
    }
  });

  app.delete("/api/messaging/messages/:messageId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const messageId = req.params.messageId;
      console.log(`üóëÔ∏è DELETE MESSAGE REQUEST - ID: ${messageId}, Org: ${req.tenant!.id}`);
      
      const deleted = await storage.deleteMessage(messageId, req.tenant!.id);
      
      if (deleted) {
        console.log(`‚úÖ MESSAGE DELETED - ID: ${messageId}`);
        res.json({ success: true, message: "Message deleted successfully" });
      } else {
        console.log(`‚ùå MESSAGE NOT FOUND - ID: ${messageId}`);
        res.status(404).json({ error: "Message not found" });
      }
    } catch (error) {
      console.error("Error deleting message:", error);
      res.status(500).json({ error: "Failed to delete message" });
    }
  });

  // Comprehensive Twilio delivery diagnostic endpoint  
  app.get("/api/messaging/delivery-diagnostic", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      console.log('üîç DELIVERY DIAGNOSTIC - Checking Twilio configuration and recent messages');
      
      // 1. Check Twilio credentials configuration
      const twilioConfig = {
        hasAccountSID: !!process.env.TWILIO_ACCOUNT_SID,
        hasSIDFormat: process.env.TWILIO_ACCOUNT_SID?.startsWith('AC') && process.env.TWILIO_ACCOUNT_SID?.length >= 34,
        hasAuthToken: !!process.env.TWILIO_AUTH_TOKEN,
        hasPhoneNumber: !!process.env.TWILIO_PHONE_NUMBER,
        phoneNumberFormat: process.env.TWILIO_PHONE_NUMBER || 'missing',
        authenticationFailed: false // Will be checked below
      };
      
      // 2. Get recent SMS/WhatsApp messages from database
      const allMessages = await storage.getRecentMessagesWithExternalIds(req.tenant!.id, 20);
      const recentMessages = allMessages
        .filter(msg => msg.messageType === 'sms' || msg.messageType === 'whatsapp')
        .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
        .slice(0, 10);
      console.log(`üîç Found ${recentMessages.length} recent external messages to check`);
      
      const messageStatusChecks = [];
      
      // 3. Check delivery status for recent messages with Twilio Message SIDs
      for (const message of recentMessages.slice(0, 5)) { // Check last 5 messages
        if (message.externalMessageId) {
          try {
            console.log(`üîç Checking status for Twilio SID: ${message.externalMessageId}`);
            const status = await messagingService.getMessageStatus(message.externalMessageId);
            
            messageStatusChecks.push({
              messageId: message.id,
              twilioSid: message.externalMessageId,
              phoneNumber: message.phoneNumber,
              messageType: message.messageType,
              content: message.content.substring(0, 50) + (message.content.length > 50 ? '...' : ''),
              sentAt: message.timestamp,
              twilioStatus: status?.status || 'unknown',
              errorCode: status?.errorCode || null,
              errorMessage: status?.errorMessage || null,
              price: status?.price || null,
              dateDelivered: status?.dateDelivered || null,
              isDelivered: status?.status === 'delivered',
              isPending: ['queued', 'sending', 'sent'].includes(status?.status),
              isFailed: ['failed', 'undelivered'].includes(status?.status)
            });
          } catch (error: any) {
            console.error(`‚ùå Error checking message ${message.externalMessageId}:`, error);
            messageStatusChecks.push({
              messageId: message.id,
              twilioSid: message.externalMessageId,
              phoneNumber: message.phoneNumber,
              messageType: message.messageType,
              content: message.content.substring(0, 50) + (message.content.length > 50 ? '...' : ''),
              sentAt: message.timestamp,
              twilioStatus: 'error',
              errorCode: error.code || null,
              errorMessage: error.message || 'Failed to fetch status',
              checkError: true
            });
          }
        } else {
          messageStatusChecks.push({
            messageId: message.id,
            phoneNumber: message.phoneNumber,
            messageType: message.messageType,
            content: message.content.substring(0, 50) + (message.content.length > 50 ? '...' : ''),
            sentAt: message.timestamp,
            twilioStatus: 'no_sid',
            errorMessage: 'No Twilio Message SID recorded'
          });
        }
      }
      
      // 4. Analyze common issues from the user's list
      const diagnosticSummary = {
        credentialsValid: twilioConfig.hasAccountSID && twilioConfig.hasSIDFormat && twilioConfig.hasAuthToken && twilioConfig.hasPhoneNumber,
        totalMessagesChecked: messageStatusChecks.length,
        deliveredCount: messageStatusChecks.filter(m => m.isDelivered).length,
        pendingCount: messageStatusChecks.filter(m => m.isPending).length,
        failedCount: messageStatusChecks.filter(m => m.isFailed).length,
        unknownCount: messageStatusChecks.filter(m => m.twilioStatus === 'unknown' || m.twilioStatus === 'error').length,
        commonIssues: [] as string[]
      };
      
      // Check for common issues
      const errorCodes = messageStatusChecks.map(m => m.errorCode).filter(Boolean);
      if (errorCodes.includes(21211)) {
        diagnosticSummary.commonIssues.push('Issue #4: Invalid phone number format detected (Error 21211)');
      }
      if (errorCodes.includes(21610)) {
        diagnosticSummary.commonIssues.push('Issue #4: Messages to unverified numbers in trial account (Error 21610)');
      }
      if (errorCodes.includes(30003)) {
        diagnosticSummary.commonIssues.push('Issue #1: Unreachable destination handset (Error 30003)');
      }
      if (errorCodes.includes(20003)) {
        diagnosticSummary.commonIssues.push('Issue #4: Twilio authentication failed (Error 20003)');
      }
      
      // Check for phone number format issues
      const phoneNumbers = messageStatusChecks.map(m => m.phoneNumber).filter(Boolean);
      const invalidFormats = phoneNumbers.filter(phone => !phone.startsWith('+') || phone.replace(/\D/g, '').length < 10);
      if (invalidFormats.length > 0) {
        diagnosticSummary.commonIssues.push(`Issue #1: ${invalidFormats.length} messages with incorrect phone number format`);
      }
      
      // Check for stuck messages (sent but not delivered for >1 hour)
      const stuckMessages = messageStatusChecks.filter(m => 
        m.twilioStatus === 'sent' && 
        new Date().getTime() - new Date(m.sentAt).getTime() > 3600000 // 1 hour
      );
      if (stuckMessages.length > 0) {
        diagnosticSummary.commonIssues.push(`Issue #3: ${stuckMessages.length} messages stuck in 'sent' status (carrier/network issues)`);
      }

      res.json({
        twilioConfig,
        diagnosticSummary,
        messageStatusChecks,
        recommendations: [
          "1. Verify phone numbers are in E.164 format (+country_code_phone_number)",
          "2. Check Twilio Console for detailed error messages and delivery receipts",
          "3. For WhatsApp: Ensure recipient has WhatsApp and template messages are approved",
          "4. Consider carrier restrictions and regional regulations",
          "5. Monitor delivery status changes over time (some carriers have delays)"
        ]
      });
      
    } catch (error) {
      console.error("Error running delivery diagnostic:", error);
      res.status(500).json({ error: "Failed to run delivery diagnostic" });
    }
  });

  app.get("/api/messaging/account-info", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const accountInfo = await messagingService.getAccountInfo();
      if (accountInfo) {
        res.json(accountInfo);
      } else {
        res.status(500).json({ error: "Failed to fetch account info" });
      }
    } catch (error) {
      console.error("Error fetching account info:", error);
      res.status(500).json({ error: "Failed to fetch account info" });
    }
  });

  // Test endpoint for SMS/WhatsApp integration
  app.post("/api/messaging/test", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { phoneNumber, message, type = 'sms' } = req.body;
      
      if (!phoneNumber || !message) {
        return res.status(400).json({ error: "Phone number and message are required" });
      }
      
      const result = await messagingService.sendMessage({
        to: phoneNumber,
        message: message,
        type: type,
        priority: 'normal'
      });
      
      res.json({
        success: result.success,
        messageId: result.messageId,
        error: result.error,
        cost: result.cost
      });
    } catch (error) {
      console.error("Error in test messaging:", error);
      res.status(500).json({ error: "Failed to send test message" });
    }
  });

  app.get("/api/messaging/templates", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const templates = await storage.getMessageTemplates(req.tenant!.id);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({ error: "Failed to fetch templates" });
    }
  });

  app.get("/api/messaging/analytics", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const analytics = await storage.getMessagingAnalytics(req.tenant!.id);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).json({ error: "Failed to fetch analytics" });
    }
  });

  // Get all SMS messages
  app.get("/api/messaging/sms-messages", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      console.log('üì± Fetching SMS messages for organization:', organizationId);
      
      // Fetch all messages with messageType = 'sms' for this organization
      const smsMessages = await storage.getSmsMessages(organizationId);
      
      console.log(`üì± Found ${smsMessages.length} SMS messages`);
      res.json(smsMessages);
    } catch (error) {
      console.error("Error fetching SMS messages:", error);
      res.status(500).json({ error: "Failed to fetch SMS messages" });
    }
  });

  // Integration endpoints
  app.get("/api/integrations", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const integrations = await storage.getIntegrations(req.tenant!.id);
      res.json(integrations);
    } catch (error) {
      console.error("Error fetching integrations:", error);
      res.status(500).json({ error: "Failed to fetch integrations" });
    }
  });

  app.post("/api/integrations/connect", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const integration = await storage.connectIntegration(req.body, req.tenant!.id);
      res.json(integration);
    } catch (error) {
      console.error("Error connecting integration:", error);
      res.status(500).json({ error: "Failed to connect integration" });
    }
  });

  app.get("/api/integrations/webhooks", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const webhooks = await storage.getWebhooks(req.tenant!.id);
      res.json(webhooks);
    } catch (error) {
      console.error("Error fetching webhooks:", error);
      res.status(500).json({ error: "Failed to fetch webhooks" });
    }
  });

  app.post("/api/integrations/webhooks", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const webhook = await storage.createWebhook(req.body, req.tenant!.id);
      res.json(webhook);
    } catch (error) {
      console.error("Error creating webhook:", error);
      res.status(500).json({ error: "Failed to create webhook" });
    }
  });

  app.get("/api/integrations/api-keys", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const apiKeys = await storage.getApiKeys(req.tenant!.id);
      res.json(apiKeys);
    } catch (error) {
      console.error("Error fetching API keys:", error);
      res.status(500).json({ error: "Failed to fetch API keys" });
    }
  });

  app.post("/api/integrations/api-keys", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const apiKey = await storage.createApiKey(req.body, req.tenant!.id);
      res.json(apiKey);
    } catch (error) {
      console.error("Error creating API key:", error);
      res.status(500).json({ error: "Failed to create API key" });
    }
  });

  // Stripe Integration Routes
  app.get("/api/integrations/stripe/status", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { isStripeConfigured, getStripePublishableKey, testStripeConnection } = await import("./services/stripe-client");
      
      const configured = isStripeConfigured();
      const publishableKey = getStripePublishableKey();
      
      let connectionStatus: { connected: boolean; accountId?: string; error?: string } = { connected: false };
      
      if (configured) {
        const testResult = await testStripeConnection();
        connectionStatus = {
          connected: testResult.success,
          accountId: testResult.accountId,
          error: testResult.error,
        };
      }
      
      res.json({
        configured,
        publishableKey: publishableKey ? `${publishableKey.substring(0, 20)}...` : null,
        hasSecretKey: !!process.env.STRIPE_SECRET_KEY,
        hasPublishableKey: !!process.env.STRIPE_PUBLISHABLE_KEY,
        mode: publishableKey?.startsWith('pk_live') ? 'live' : 'test',
        ...connectionStatus,
      });
    } catch (error) {
      console.error("Error checking Stripe status:", error);
      res.status(500).json({ error: "Failed to check Stripe status" });
    }
  });

  app.post("/api/integrations/stripe/test", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const { testStripeConnection, resetStripeClient } = await import("./services/stripe-client");
      
      resetStripeClient();
      const result = await testStripeConnection();
      
      res.json({
        success: result.success,
        accountId: result.accountId,
        error: result.error,
        testedAt: new Date().toISOString(),
      });
    } catch (error: any) {
      console.error("Error testing Stripe connection:", error);
      res.status(500).json({ 
        success: false, 
        error: error.message || "Failed to test Stripe connection" 
      });
    }
  });

  // QuickBooks integration config endpoint
  app.post("/api/integrations/quickbooks/config", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const { clientId, clientSecret } = req.body;
      
      if (!clientId || !clientSecret) {
        return res.status(400).json({ error: "Client ID and Client Secret are required" });
      }

      const organizationId = req.tenant!.id;
      const configData = {
        clientId,
        clientSecret,
        configuredAt: new Date().toISOString(),
        configuredBy: req.user!.id
      };

      // Check if config exists
      const existing = await db.select()
        .from(schema.organizationIntegrations)
        .where(and(
          eq(schema.organizationIntegrations.organizationId, organizationId),
          eq(schema.organizationIntegrations.integrationType, 'quickbooks')
        ))
        .limit(1);

      if (existing.length > 0) {
        // Update existing
        await db.update(schema.organizationIntegrations)
          .set({
            settings: configData,
            isEnabled: true,
            isConfigured: true,
            updatedAt: new Date()
          })
          .where(and(
            eq(schema.organizationIntegrations.organizationId, organizationId),
            eq(schema.organizationIntegrations.integrationType, 'quickbooks')
          ));
      } else {
        // Insert new
        await db.insert(schema.organizationIntegrations).values({
          organizationId,
          integrationType: 'quickbooks',
          settings: configData,
          isEnabled: true,
          isConfigured: true
        });
      }

      res.json({ 
        success: true, 
        message: "QuickBooks configuration saved successfully" 
      });
    } catch (error: any) {
      console.error("Error saving QuickBooks config:", error);
      res.status(500).json({ error: "Failed to save QuickBooks configuration" });
    }
  });

  // Get QuickBooks config status
  app.get("/api/integrations/quickbooks/status", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      const existing = await db.select()
        .from(schema.organizationIntegrations)
        .where(and(
          eq(schema.organizationIntegrations.organizationId, organizationId),
          eq(schema.organizationIntegrations.integrationType, 'quickbooks')
        ))
        .limit(1);

      if (existing.length > 0) {
        const settings = existing[0].settings as any;
        
        // Also check for active connection in quickbooksConnections table
        const activeConnection = await db.select()
          .from(quickbooksConnections)
          .where(and(
            eq(quickbooksConnections.organizationId, organizationId),
            eq(quickbooksConnections.isActive, true)
          ))
          .limit(1);

        const hasActiveConnection = activeConnection.length > 0;
        const connectionInfo = hasActiveConnection ? {
          companyName: activeConnection[0].companyName,
          realmId: activeConnection[0].realmId,
          connectedAt: activeConnection[0].createdAt ? new Date(activeConnection[0].createdAt).toISOString() : null
        } : null;

        res.json({
          configured: true,
          isActive: existing[0].isEnabled,
          configuredAt: settings?.configuredAt,
          connected: hasActiveConnection,
          connection: connectionInfo
        });
      } else {
        res.json({ configured: false, connected: false });
      }
    } catch (error: any) {
      console.error("Error getting QuickBooks status:", error);
      res.status(500).json({ error: "Failed to get QuickBooks status" });
    }
  });

  // QuickBooks webhook endpoint - uses raw body for signature verification
  app.post("/api/webhooks/quickbooks", express.raw({ type: 'application/json' }), async (req, res) => {
    try {
      console.log("[QuickBooks Webhook] Received webhook event");
      
      const signature = req.headers['intuit-signature'] as string;
      const rawBody = req.body;

      // Import signature verification
      const { verifySignatureForAnyOrg } = await import('./services/quickbooks/verifySignature');
      const { processQuickBooksWebhook } = await import('./services/quickbooks/webhookProcessor');

      // Verify signature against all configured orgs
      const verification = await verifySignatureForAnyOrg(rawBody, signature || '');
      
      if (!verification.valid) {
        console.log("[QuickBooks Webhook] Invalid signature or no matching org found");
        // Still return 200 to prevent retries (QuickBooks may be testing)
        return res.status(200).json({ success: true, message: "Webhook received" });
      }

      console.log(`[QuickBooks Webhook] Signature verified for org: ${verification.organizationId}`);

      // Respond immediately (within 5 seconds)
      res.status(200).json({ success: true, message: "Webhook received" });

      // Process asynchronously
      try {
        const jsonData = JSON.parse(rawBody.toString());
        console.log("[QuickBooks Webhook] Body:", JSON.stringify(jsonData, null, 2));
        await processQuickBooksWebhook(jsonData, verification.organizationId);
      } catch (parseError) {
        console.error("[QuickBooks Webhook] Error parsing body:", parseError);
      }
    } catch (error: any) {
      console.error("[QuickBooks Webhook] Error processing webhook:", error);
      res.status(200).json({ success: true, message: "Webhook received" });
    }
  });

  app.get("/api/integrations/stripe/publishable-key", async (req: TenantRequest, res) => {
    try {
      const publishableKey = process.env.STRIPE_PUBLISHABLE_KEY;
      
      if (!publishableKey) {
        return res.status(404).json({ error: "Stripe publishable key not configured" });
      }
      
      res.json({ publishableKey });
    } catch (error) {
      console.error("Error fetching Stripe publishable key:", error);
      res.status(500).json({ error: "Failed to fetch publishable key" });
    }
  });

  app.post("/api/integrations/stripe/payment-intent", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { createPaymentIntent } = await import("./services/stripe-client");
      
      const schema = z.object({
        amount: z.number().positive(),
        currency: z.string().default('gbp'),
        metadata: z.record(z.string()).optional(),
      });
      
      const { amount, currency, metadata } = schema.parse(req.body);
      
      const result = await createPaymentIntent(amount, currency, {
        ...metadata,
        organizationId: String(req.tenant!.id),
      });
      
      if ('error' in result) {
        return res.status(400).json({ error: result.error });
      }
      
      res.json(result);
    } catch (error: any) {
      console.error("Error creating payment intent:", error);
      res.status(500).json({ error: error.message || "Failed to create payment intent" });
    }
  });

  app.post("/api/integrations/stripe/refund", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const { createRefund } = await import("./services/stripe-client");
      
      const schema = z.object({
        paymentIntentId: z.string(),
        amount: z.number().positive().optional(),
      });
      
      const { paymentIntentId, amount } = schema.parse(req.body);
      
      const result = await createRefund(paymentIntentId, amount);
      
      if ('error' in result) {
        return res.status(400).json({ error: result.error });
      }
      
      res.json(result);
    } catch (error: any) {
      console.error("Error creating refund:", error);
      res.status(500).json({ error: error.message || "Failed to create refund" });
    }
  });

  // Notification endpoints
  app.get("/api/notifications", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user!.id;
      const organizationId = req.tenant!.id;
      const limitParam = parseInt(req.query.limit as string);
      const limit = Number.isNaN(limitParam) ? 20 : limitParam;

      let notifications;
      if (req.user!.role === "admin") {
        notifications = await storage.getNotificationsByOrganization(organizationId, limit);
      } else {
        const safeLimit = limit <= 0 ? 20 : limit;
        notifications = await storage.getNotifications(userId, organizationId, safeLimit);
      }

      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ error: "Failed to fetch notifications" });
    }
  });

  app.get("/api/notifications/count", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const count = await storage.getNotificationCountByOrganization(organizationId);
      res.json({ count });
    } catch (error) {
      console.error("Error fetching notification count:", error);
      res.status(500).json({ error: "Failed to fetch notification count" });
    }
  });

  app.get("/api/notifications/unread-count", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user!.id;
      const organizationId = req.tenant!.id;

      const count =
        req.user!.role === "admin"
          ? await storage.getUnreadNotificationCountByOrganization(organizationId)
          : await storage.getUnreadNotificationCount(userId, organizationId);
      res.json({ count });
    } catch (error) {
      console.error("Error fetching unread count:", error);
      res.status(500).json({ error: "Failed to fetch unread count" });
    }
  });

  app.post("/api/notifications", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const notificationData = z.object({
        userId: z.number(),
        title: z.string().min(1),
        message: z.string().min(1),
        type: z.string(),
        priority: z.enum(["low", "normal", "high", "critical"]).default("normal"),
        relatedEntityType: z.string().optional(),
        relatedEntityId: z.number().optional(),
        actionUrl: z.string().optional(),
        isActionable: z.boolean().default(false),
        scheduledFor: z.string().optional(),
        expiresAt: z.string().optional(),
        metadata: z.object({
          patientId: z.number().optional(),
          patientName: z.string().optional(),
          appointmentId: z.number().optional(),
          prescriptionId: z.number().optional(),
          urgency: z.enum(["low", "medium", "high", "critical"]).optional(),
          department: z.string().optional(),
          requiresResponse: z.boolean().optional(),
          autoMarkAsRead: z.boolean().optional(),
          icon: z.string().optional(),
          color: z.string().optional(),
        }).optional()
      }).parse(req.body);

      const notification = await storage.createNotification({
        ...notificationData,
        organizationId: req.tenant!.id,
        scheduledFor: notificationData.scheduledFor ? new Date(notificationData.scheduledFor) : undefined,
        expiresAt: notificationData.expiresAt ? new Date(notificationData.expiresAt) : undefined,
      });

      res.status(201).json(notification);
    } catch (error) {
      console.error("Error creating notification:", error);
      res.status(500).json({ error: "Failed to create notification" });
    }
  });

  app.patch("/api/notifications/:id/read", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      const userId = req.user!.id;
      const organizationId = req.tenant!.id;

      const notification = await storage.markNotificationAsRead(notificationId, userId, organizationId);
      if (!notification) {
        return res.status(404).json({ error: "Notification not found" });
      }

      res.json(notification);
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ error: "Failed to mark notification as read" });
    }
  });

  app.patch("/api/notifications/:id/dismiss", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      const userId = req.user!.id;
      const organizationId = req.tenant!.id;

      const notification = await storage.markNotificationAsDismissed(notificationId, userId, organizationId);

      if (!notification) {
        return res.status(404).json({ error: "Notification not found" });
      }

      res.json(notification);
    } catch (error) {
      console.error("Error dismissing notification:", error);
      res.status(500).json({ error: "Failed to dismiss notification" });
    }
  });

  app.patch("/api/notifications/mark-all-read", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user!.id;
      const organizationId = req.tenant!.id;

      await storage.markAllNotificationsAsRead(userId, organizationId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ error: "Failed to mark all notifications as read" });
    }
  });

  app.delete("/api/notifications/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      const userId = req.user!.id;
      const organizationId = req.tenant!.id;

      const success = await storage.deleteNotification(notificationId, userId, organizationId);
      if (!success) {
        return res.status(404).json({ error: "Notification not found" });
      }

      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting notification:", error);
      res.status(500).json({ error: "Failed to delete notification" });
    }
  });

  // Population Health Interventions
  app.get("/api/population-health/interventions", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;

      // Return sample interventions data
      const sampleInterventions = [
        {
          id: 1,
          name: "Diabetes Prevention Program",
          description: "Comprehensive lifestyle intervention program designed to prevent type 2 diabetes in high-risk patients through diet modification, exercise, and behavioral changes.",
          type: "educational",
          status: "active",
          targetPopulation: "Pre-diabetic adults aged 35-65",
          duration: 16,
          budget: 25000,
          startDate: "2024-06-01",
          organizationId,
          metrics: {
            enrolled: 47,
            completed: 23,
            successRate: 78
          }
        },
        {
          id: 2,
          name: "Hypertension Monitoring Initiative",
          description: "Remote blood pressure monitoring program with automated alerts and medication adherence tracking for patients with hypertension.",
          type: "screening",
          status: "active",
          targetPopulation: "Hypertensive patients",
          duration: 24,
          budget: 18000,
          startDate: "2024-05-15",
          organizationId,
          metrics: {
            enrolled: 156,
            completed: 89,
            successRate: 85
          }
        },
        {
          id: 3,
          name: "Mental Health Screening Program",
          description: "Annual mental health screening and early intervention program for all adult patients, with focus on depression and anxiety detection.",
          type: "screening",
          status: "pending",
          targetPopulation: "All adult patients",
          duration: 52,
          budget: 32000,
          startDate: "2024-07-01",
          organizationId,
          metrics: {
            enrolled: 0,
            completed: 0,
            successRate: 0
          }
        },
        {
          id: 4,
          name: "Smoking Cessation Support Group",
          description: "Weekly group therapy sessions combined with nicotine replacement therapy and counseling for patients wanting to quit smoking.",
          type: "behavioral",
          status: "active",
          targetPopulation: "Current smokers",
          duration: 12,
          budget: 8500,
          startDate: "2024-04-20",
          organizationId,
          metrics: {
            enrolled: 28,
            completed: 19,
            successRate: 67
          }
        },
        {
          id: 5,
          name: "Childhood Obesity Prevention",
          description: "Family-based intervention program focusing on nutrition education, physical activity, and behavioral modification for overweight children.",
          type: "lifestyle",
          status: "completed",
          targetPopulation: "Children aged 6-14 with BMI >85th percentile",
          duration: 20,
          budget: 15000,
          startDate: "2024-01-15",
          organizationId,
          metrics: {
            enrolled: 35,
            completed: 32,
            successRate: 91
          }
        }
      ];

      res.json(sampleInterventions);
    } catch (error) {
      console.error("Error fetching interventions:", error);
      res.status(500).json({ error: "Failed to fetch interventions" });
    }
  });

  // AI Agent endpoints
  app.post("/api/ai-agent/chat", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { message, conversationHistory = [] } = req.body;
      
      if (!message) {
        return res.status(400).json({ error: "Message is required" });
      }

      // Use enhanced OpenAI-powered comprehensive chatbot for appointments, prescriptions, and general queries
      const conversationContext = {
        conversationId: `conv_${req.user.id}_${Date.now()}`,
        userId: req.user.id,
        organizationId: req.tenant!.id,
        sessionStartTime: new Date(),
        conversationHistory: conversationHistory.map((msg: any) => ({
          role: msg.role || 'user',
          content: msg.content || msg.message,
          timestamp: new Date(msg.timestamp || Date.now()),
          intent: msg.intent,
          entities: msg.entities
        })),
        userProfile: {
          medicalHistory: [],
          preferences: {},
          language: 'en',
          complexityLevel: 'intermediate' as const
        },
        contextualKnowledge: {
          recentTopics: [],
          extractedEntities: {},
          sentimentAnalysis: {
            overall: 'neutral' as const,
            confidence: 0.8
          }
        }
      };
      
      // Use OpenAI-powered comprehensive chatbot if available, fallback to local NLP
      let nlpResult;
      try {
        nlpResult = await (aiService as any).processComprehensiveChatWithOpenAI(message, conversationContext, req.tenant!.id);
      } catch (error) {
        console.log('OpenAI chatbot failed, falling back to local NLP:', error);
        nlpResult = await (aiService as any).processWithLocalNLP(message, conversationContext);
      }
      
      // Convert result to agent response format
      const aiResponse = {
        intent: nlpResult.intent,
        response: nlpResult.response,
        confidence: nlpResult.confidence,
        parameters: null,
        appointmentData: nlpResult.appointmentData,
        prescriptionData: nlpResult.prescriptionData
      };

      // Perform actions based on AI analysis
      let actionResult = null;
      let responseData = null;

      if (aiResponse.intent === 'appointment_booking' && aiResponse.appointmentData?.should_book) {
        // Appointment creation is handled internally by the AI service
        // The createAutomaticAppointment method in AI service already handles the appointment creation
        actionResult = {
          action: 'appointment_booked',
          actionDescription: `Appointment booking processed`,
          data: { processed: true }
        };
        responseData = { 
          appointmentBooked: true,
          processed: true
        };
      } else if (aiResponse.intent === 'prescription_inquiry' && aiResponse.prescriptionData?.search_query) {
        // Handle prescription search with OpenAI data
        try {
          let prescriptions: any[] = [];
          const prescriptionData = aiResponse.prescriptionData;
          
          if (prescriptionData.patient_name) {
            // Search by patient name
            const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
            const matchingPatients = patients.filter(p => 
              `${p.firstName} ${p.lastName}`.toLowerCase().includes(prescriptionData.patient_name.toLowerCase()) ||
              p.firstName.toLowerCase().includes(prescriptionData.patient_name.toLowerCase()) ||
              p.lastName.toLowerCase().includes(prescriptionData.patient_name.toLowerCase())
            );
            
            if (matchingPatients.length > 0) {
              const allPrescriptions = await storage.getPrescriptionsByOrganization(req.tenant!.id);
              prescriptions = allPrescriptions.filter(p => 
                matchingPatients.some(patient => patient.id === p.patientId)
              );
            }
          } else if (prescriptionData.medication_name) {
            // Search by medication name
            const allPrescriptions = await storage.getPrescriptionsByOrganization(req.tenant!.id);
            prescriptions = allPrescriptions.filter(p => 
              p.medications?.some((med: any) => med.name?.toLowerCase().includes(prescriptionData.medication_name.toLowerCase())) ||
              p.interactions?.some((int: any) => int.toLowerCase().includes(prescriptionData.medication_name.toLowerCase()))
            );
          } else {
            // General prescription search based on search query
            const allPrescriptions = await storage.getPrescriptionsByOrganization(req.tenant!.id);
            prescriptions = allPrescriptions.filter(p => 
              p.medications?.some((med: any) => med.name?.toLowerCase().includes(prescriptionData.search_query.toLowerCase())) ||
              p.interactions?.some((int: any) => int.toLowerCase().includes(prescriptionData.search_query.toLowerCase()))
            );
          }

          // Get patient names for prescriptions
          const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
          const prescriptionsWithNames = prescriptions.map(prescription => {
            const patient = patients.find(p => p.id === prescription.patientId);
            return {
              ...prescription,
              patientName: patient ? `${patient.firstName} ${patient.lastName}` : 'Unknown Patient'
            };
          });

          responseData = { 
            prescriptions: prescriptionsWithNames,
            searchQuery: prescriptionData.search_query,
            patientName: prescriptionData.patient_name,
            medicationName: prescriptionData.medication_name
          };
          actionResult = {
            action: 'prescriptions_found',
            actionDescription: `Found ${prescriptions.length} prescription(s) matching your query`
          };
        } catch (error) {
          console.error("Error finding prescriptions:", error);
        }
      }

      res.json({
        message: aiResponse.response,
        intent: aiResponse.intent,
        confidence: aiResponse.confidence,
        data: responseData,
        ...actionResult
      });

    } catch (error) {
      console.error("AI Agent error:", error);
      res.status(500).json({ 
        error: "Failed to process AI request",
        message: "I apologize, but I'm having trouble processing your request right now. Please try again."
      });
    }
  });

  // Mobile Health endpoints
  app.get("/api/mobile-health/devices", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const sampleDevices = [
        {
          id: "device_1",
          patientId: "patient_1",
          patientName: "Sarah Johnson",
          deviceType: "smartwatch",
          brand: "Apple",
          model: "Watch Series 9",
          status: "connected",
          batteryLevel: 78,
          lastSync: "2024-06-30T15:30:00Z",
          dataTypes: ["Heart Rate", "Steps", "Sleep", "ECG"],
          readings: [
            {
              timestamp: "2024-06-30T15:30:00Z",
              type: "heart_rate",
              value: 72,
              unit: "bpm",
              status: "normal"
            },
            {
              timestamp: "2024-06-30T15:30:00Z",
              type: "steps",
              value: 8456,
              unit: "steps",
              status: "normal"
            }
          ]
        },
        {
          id: "device_2",
          patientId: "patient_2",
          patientName: "Michael Chen",
          deviceType: "glucose_monitor",
          brand: "Dexcom",
          model: "G7",
          status: "connected",
          batteryLevel: 92,
          lastSync: "2024-06-30T15:45:00Z",
          dataTypes: ["Blood Glucose", "Trends"],
          readings: [
            {
              timestamp: "2024-06-30T15:45:00Z",
              type: "glucose",
              value: 142,
              unit: "mg/dL",
              status: "abnormal"
            }
          ]
        },
        {
          id: "device_3",
          patientId: "patient_3",
          patientName: "Emma Davis",
          deviceType: "blood_pressure",
          brand: "Omron",
          model: "HeartGuide",
          status: "disconnected",
          batteryLevel: 15,
          lastSync: "2024-06-29T08:20:00Z",
          dataTypes: ["Blood Pressure", "Heart Rate"],
          readings: []
        }
      ];

      res.json(sampleDevices);
    } catch (error) {
      console.error("Error fetching mobile health devices:", error);
      res.status(500).json({ error: "Failed to fetch devices" });
    }
  });

  app.post("/api/mobile-health/devices/:id/sync", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const deviceId = req.params.id;
      
      // Simulate device sync process
      const syncResult = {
        deviceId,
        status: "success",
        syncedAt: new Date().toISOString(),
        newReadings: Math.floor(Math.random() * 10) + 1,
        batteryLevel: Math.floor(Math.random() * 30) + 70,
        message: "Device synchronized successfully"
      };

      // Simulate a delay for sync process
      await new Promise(resolve => setTimeout(resolve, 2000));

      res.json(syncResult);
    } catch (error) {
      console.error("Error syncing device:", error);
      res.status(500).json({ error: "Failed to sync device" });
    }
  });

  app.get("/api/mobile-health/apps", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const sampleApps = [
        {
          id: "app_1",
          name: "Averox Patient Portal",
          description: "Complete patient portal with appointment booking, messaging, and health records",
          category: "patient_portal",
          platform: "pwa",
          version: "2.1.0",
          downloads: 15420,
          rating: 4.8,
          features: [
            "Appointment Booking",
            "Secure Messaging",
            "Lab Results",
            "Prescription Management",
            "Health Records",
            "Telehealth Integration"
          ],
          screenshots: []
        },
        {
          id: "app_2",
          name: "Averox Medication Tracker",
          description: "Smart medication reminders with dose tracking and refill alerts",
          category: "medication_tracker",
          platform: "ios",
          version: "1.5.2",
          downloads: 8930,
          rating: 4.6,
          features: [
            "Medication Reminders",
            "Dose Tracking",
            "Refill Alerts",
            "Drug Interaction Warnings",
            "Pill Recognition"
          ],
          screenshots: []
        }
      ];

      res.json(sampleApps);
    } catch (error) {
      console.error("Error fetching mobile health apps:", error);
      res.status(500).json({ error: "Failed to fetch apps" });
    }
  });

  app.get("/api/mobile-health/notifications", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const sampleNotifications = [
        {
          id: "notif_1",
          patientId: "patient_1",
          patientName: "Sarah Johnson",
          type: "appointment_reminder",
          title: "Appointment Reminder",
          message: "You have an appointment tomorrow at 10:00 AM with Dr. Emily Watson",
          priority: "normal",
          scheduledTime: "2024-07-01T09:00:00Z",
          status: "scheduled"
        },
        {
          id: "notif_2",
          patientId: "patient_2",
          patientName: "Michael Chen",
          type: "health_alert",
          title: "Blood Glucose Alert",
          message: "Your blood glucose reading of 180 mg/dL is elevated. Please check your levels.",
          priority: "high",
          scheduledTime: "2024-06-30T16:00:00Z",
          status: "delivered",
          deliveryTime: "2024-06-30T16:00:12Z"
        }
      ];

      res.json(sampleNotifications);
    } catch (error) {
      console.error("Error fetching mobile health notifications:", error);
      res.status(500).json({ error: "Failed to fetch notifications" });
    }
  });

  // In-memory storage for patient consents (in production this would be in database)
  let patientConsents = [
    {
      id: "consent_1",
      patientId: "patient_1",
      patientName: "Sarah Johnson",
      email: "sarah.johnson@email.com",
      consentStatus: "consented",
      consentDate: "2024-01-15T10:30:00.000Z",
      monitoringTypes: {
        heartRate: true,
        bloodPressure: true,
        glucose: false,
        activity: true,
        sleep: true
      },
      deviceAccess: true,
      dataSharing: true,
      emergencyContact: true,
      lastUpdated: "2024-01-15T10:30:00.000Z"
    },
    {
      id: "consent_2",
      patientId: "patient_2",
      patientName: "Michael Chen",
      email: "michael.chen@email.com",
      consentStatus: "pending",
      monitoringTypes: {
        heartRate: false,
        bloodPressure: false,
        glucose: false,
        activity: false,
        sleep: false
      },
      deviceAccess: false,
      dataSharing: false,
      emergencyContact: false,
      lastUpdated: "2024-01-20T14:15:00.000Z"
    },
    {
      id: "consent_3",
      patientId: "patient_3",
      patientName: "Emma Davis",
      email: "emma.davis@email.com",
      consentStatus: "declined",
      monitoringTypes: {
        heartRate: false,
        bloodPressure: false,
        glucose: false,
        activity: false,
        sleep: false
      },
      deviceAccess: false,
      dataSharing: false,
      emergencyContact: false,
      lastUpdated: "2024-01-18T09:45:00.000Z"
    },
    {
      id: "consent_4",
      patientId: "patient_4",
      patientName: "Robert Wilson",
      email: "robert.wilson@email.com",
      consentStatus: "consented",
      consentDate: "2024-01-22T16:20:00.000Z",
      monitoringTypes: {
        heartRate: true,
        bloodPressure: true,
        glucose: true,
        activity: false,
        sleep: false
      },
      deviceAccess: true,
      dataSharing: false,
      emergencyContact: true,
      lastUpdated: "2024-01-22T16:20:00.000Z"
    },
    {
      id: "consent_5",
      patientId: "patient_5",
      patientName: "Lisa Anderson",
      email: "lisa.anderson@email.com",
      consentStatus: "revoked",
      consentDate: "2024-01-10T11:00:00.000Z",
      revokedDate: "2024-01-25T13:30:00.000Z",
      monitoringTypes: {
        heartRate: false,
        bloodPressure: false,
        glucose: false,
        activity: false,
        sleep: false
      },
      deviceAccess: false,
      dataSharing: false,
      emergencyContact: false,
      lastUpdated: "2024-01-25T13:30:00.000Z"
    }
  ];

  // Patient consent management endpoints
  app.get("/api/mobile-health/patient-consent", authMiddleware, async (req: TenantRequest, res) => {
    try {
      // Get real patients from database and create consent records for them
      const realPatients = await storage.getPatientsByOrganization(req.tenant!.id);
      
      const realPatientConsents = realPatients.map(patient => {
        // Check if we have existing consent data for this patient
        const existingConsent = patientConsents.find(consent => consent.patientId === patient.patientId);
        
        if (existingConsent) {
          // Update with real patient data
          return {
            ...existingConsent,
            patientName: `${patient.firstName} ${patient.lastName}`,
            email: patient.email || existingConsent.email
          };
        } else {
          // Create new consent record for real patient
          return {
            id: `consent_${patient.patientId}`,
            patientId: patient.patientId,
            patientName: `${patient.firstName} ${patient.lastName}`,
            email: patient.email || '',
            consentStatus: "pending",
            monitoringTypes: {
              heartRate: false,
              bloodPressure: false,
              glucose: false,
              activity: false,
              sleep: false
            },
            deviceAccess: false,
            dataSharing: false,
            emergencyContact: false,
            lastUpdated: new Date().toISOString()
          };
        }
      });
      
      res.json(realPatientConsents);
    } catch (error) {
      console.error("Error fetching patient consent data:", error);
      res.status(500).json({ error: "Failed to fetch patient consent data" });
    }
  });

  app.put("/api/mobile-health/patient-consent/:patientId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { patientId } = req.params;
      const consentData = req.body;
      
      console.log(`Updating consent for patient ${patientId}:`, consentData);
      console.log(`Organization ID: ${req.organizationId}`);
      
      // Find and update the consent record
      const consentIndex = patientConsents.findIndex(consent => consent.patientId === patientId);
      
      if (consentIndex === -1) {
        // Patient consent record doesn't exist - create it
        // First get the patient data from storage
        console.log(`Looking up patient ${patientId} for organization ${req.organizationId}`);
        
        try {
          const patient = await storage.getPatientByPatientId(patientId, req.tenant!.id);
          console.log(`Patient lookup result:`, patient ? 'Found' : 'Not found');
          if (patient) {
            console.log(`Patient details: ${patient.firstName} ${patient.lastName}`);
          }
          
          if (!patient) {
            console.log(`Patient ${patientId} not found in organization ${req.organizationId}`);
            return res.status(404).json({ error: "Patient not found" });
          }
          
          const newConsentRecord = {
            id: `consent_${patientId}`,
            patientId: patientId,
            patientName: `${patient.firstName} ${patient.lastName}`,
            email: patient.email || '',
            consentStatus: consentData.consentStatus || 'pending',
            monitoringTypes: {
              heartRate: false,
              bloodPressure: false,
              glucose: false,
              activity: false,
              sleep: false
            },
            deviceAccess: false,
            dataSharing: false,
            emergencyContact: false,
            lastUpdated: new Date().toISOString(),
            ...consentData
          };
          
          // Handle consent status specific updates for new record
          if (consentData.consentStatus === 'consented') {
            newConsentRecord.deviceAccess = true;
            newConsentRecord.dataSharing = true;
            newConsentRecord.monitoringTypes = {
              heartRate: true,
              bloodPressure: true,
              glucose: true,
              activity: true,
              sleep: true
            };
          }
          
          patientConsents.push(newConsentRecord);
          console.log(`Created new consent record for patient ${patientId}`);
          
          res.json({ success: true, consent: newConsentRecord });
          return;
          
        } catch (storageError) {
          console.error(`Storage error when looking up patient ${patientId}:`, storageError);
          return res.status(500).json({ error: "Failed to lookup patient" });
        }
      }
      
      // Update the consent record with new data
      patientConsents[consentIndex] = {
        ...patientConsents[consentIndex],
        ...consentData,
        lastUpdated: new Date().toISOString()
      };
      
      // Handle consent status specific updates
      if (consentData.consentStatus === 'consented') {
        patientConsents[consentIndex].deviceAccess = true;
        patientConsents[consentIndex].dataSharing = true;
        patientConsents[consentIndex].monitoringTypes = {
          heartRate: true,
          bloodPressure: true,
          glucose: true,
          activity: true,
          sleep: true
        };
      } else if (consentData.consentStatus === 'declined' || consentData.consentStatus === 'revoked') {
        patientConsents[consentIndex].deviceAccess = false;
        patientConsents[consentIndex].dataSharing = false;
        patientConsents[consentIndex].monitoringTypes = {
          heartRate: false,
          bloodPressure: false,
          glucose: false,
          activity: false,
          sleep: false
        };
      }
      
      res.json({
        success: true,
        message: "Patient consent updated successfully",
        data: patientConsents[consentIndex]
      });
    } catch (error) {
      console.error("Error updating patient consent:", error);
      res.status(500).json({ error: "Failed to update patient consent" });
    }
  });

  // Voice Documentation Routes
  app.get("/api/voice-documentation/notes", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      // Get voice notes from database storage
      const notes = await storage.getVoiceNotesByOrganization(req.tenant!.id);
      
      // If no notes exist, create a sample note for backwards compatibility
      if (notes.length === 0) {
        const sampleNote = {
          id: "note_sample_" + Date.now(),
          organizationId: req.tenant!.id,
          patientId: "158",
          patientName: "Imran Mubashir",
          providerId: "1",
          providerName: "Dr. Provider",
          type: "consultation",
          status: "completed",
          recordingDuration: 120,
          transcript: "Patient presents with chest pain. Vital signs stable. Recommended further cardiac evaluation.",
          confidence: 0.94,
          medicalTerms: [
            { term: "chest pain", confidence: 0.95, category: "symptom" },
            { term: "cardiac evaluation", confidence: 0.93, category: "procedure" }
          ],
          structuredData: {
            chiefComplaint: ["Chest pain"] as [string, ...string[]],
            assessment: ["Possible cardiac involvement"] as [string, ...string[]],
            plan: ["EKG, troponin levels, cardiology consult"] as [string, ...string[]]
          }
        };
        
        await storage.createVoiceNote(sampleNote);
        const updatedNotes = await storage.getVoiceNotesByOrganization(req.tenant!.id);
        return res.json(updatedNotes);
      }

      res.json(notes);
    } catch (error) {
      console.error("Error fetching voice notes:", error);
      res.status(500).json({ error: "Failed to fetch voice notes" });
    }
  });

  app.post("/api/voice-documentation/notes", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      // Handle voice note creation with patient data
      const { patientId, type, transcript, duration, confidence } = req.body;
      

      
      // Get patient info to associate with the note
      const patientIdNum = parseInt(patientId);
      if (isNaN(patientIdNum)) {
        return res.status(400).json({ error: "Invalid patient ID" });
      }
      
      const patient = await storage.getPatient(patientIdNum, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      const newNote = {
        id: `note_${Date.now()}`,
        organizationId: req.tenant!.id,
        patientId: patientId,
        patientName: `${patient.firstName} ${patient.lastName}`,
        providerId: req.user.id.toString(),
        providerName: "Dr. Provider",
        type: type || "consultation",
        status: transcript && transcript !== "Processing audio..." ? "completed" : "processing",
        recordingDuration: duration || 0,
        transcript: transcript || "Processing audio...",
        confidence: confidence || 0.0,
        medicalTerms: [],
        structuredData: {}
      };

      // Save the new note to database
      const createdNote = await storage.createVoiceNote(newNote);

      res.status(201).json(createdNote);
    } catch (error) {
      console.error("Error creating voice note:", error);
      res.status(500).json({ error: "Failed to create voice note" });
    }
  });

  app.put("/api/voice-documentation/notes/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      console.log(`üîÑ PUT request received for voice note: ${req.params.id}`);
      console.log(`üîÑ Request body:`, req.body);
      
      if (!req.user) {
        console.log("‚ùå User not authenticated");
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { id } = req.params;
      const { transcript } = req.body;

      console.log(`üîÑ Extracted - ID: ${id}, Transcript: ${transcript}`);

      if (!id) {
        console.log("‚ùå Voice note ID is required");
        return res.status(400).json({ error: "Voice note ID is required" });
      }

      if (!transcript) {
        console.log("‚ùå Transcript is required");
        return res.status(400).json({ error: "Transcript is required" });
      }

      console.log(`üîÑ Updating voice note in database...`);
      // Update the voice note transcript in the database
      const updatedNote = await storage.updateVoiceNote(id, req.tenant!.id, {
        transcript: transcript
      });

      if (!updatedNote) {
        console.log("‚ùå Voice note not found");
        return res.status(404).json({ error: "Voice note not found" });
      }

      console.log(`‚úÖ Voice note updated successfully: ${id}`);
      console.log(`‚úÖ Updated data:`, updatedNote);
      
      res.setHeader('Content-Type', 'application/json');
      return res.status(200).json(updatedNote);
    } catch (error) {
      console.error("‚ùå Error updating voice note:", error);
      res.setHeader('Content-Type', 'application/json');
      return res.status(500).json({ error: "Failed to update voice note" });
    }
  });

  app.delete("/api/voice-documentation/notes/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const noteId = req.params.id;
      console.log("DELETE request for noteId:", noteId);
      
      // Check if note exists before deletion
      const existingNote = await storage.getVoiceNote(noteId, req.tenant!.id);
      if (!existingNote) {
        console.log("Voice note not found in database:", noteId);
        return res.status(404).json({ error: "Voice note not found" });
      }

      // Delete the note from database
      const deleted = await storage.deleteVoiceNote(noteId, req.tenant!.id);
      
      if (!deleted) {
        return res.status(404).json({ error: "Voice note not found" });
      }
      
      console.log("Successfully deleted note:", noteId);
      
      res.status(200).json({ 
        message: "Voice note deleted successfully", 
        deletedNoteId: noteId 
      });
    } catch (error) {
      console.error("Error deleting voice note:", error);
      res.status(500).json({ error: "Failed to delete voice note" });
    }
  });

  app.get("/api/voice-documentation/templates", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const templates = [
        {
          id: "template_1",
          name: "SOAP Note",
          category: "soap_note",
          template: "SUBJECTIVE:\n{chief_complaint}\n\nOBJECTIVE:\n{physical_exam}\n\nASSESSMENT:\n{assessment}\n\nPLAN:\n{plan}",
          fields: [
            { name: "chief_complaint", type: "textarea", required: true },
            { name: "physical_exam", type: "textarea", required: true },
            { name: "assessment", type: "textarea", required: true },
            { name: "plan", type: "textarea", required: true }
          ],
          autoComplete: true,
          usageCount: 45
        }
      ];

      res.json(templates);
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({ error: "Failed to fetch templates" });
    }
  });

  // Clinical photos now use database storage instead of in-memory storage

  app.get("/api/voice-documentation/photos", authMiddleware, async (req: TenantRequest, res) => {
    try {
      // Get photos from database with proper tenant filtering
      const photos = await storage.getClinicalPhotosByOrganization(req.tenant!.id);
      
      // Transform database format to frontend format with patient names
      const transformedPhotos = await Promise.all(photos.map(async photo => {
        // Look up patient name using patientId
        const patient = await storage.getPatient(photo.patientId, req.tenant!.id);
        const patientName = patient ? `${patient.firstName} ${patient.lastName}` : 'Unknown Patient';
        
        return {
          id: photo.id.toString(),
          patientId: photo.patientId.toString(),
          patientName: patientName,
          type: photo.type,
          filename: photo.fileName,
          description: photo.description || 'Clinical photo',
          url: `/uploads/wound_assessment/${photo.fileName}`,
          dateTaken: photo.createdAt.toISOString(),
          metadata: photo.metadata || {},
          annotations: [],
          createdAt: photo.createdAt.toISOString()
        };
      }));

      res.json(transformedPhotos);
    } catch (error) {
      console.error("Error fetching photos:", error);
      res.status(500).json({ error: "Failed to fetch photos" });
    }
  });

  app.post("/api/voice-documentation/photos", uploadPhoto.single('photo'), authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { patientId, type, description } = req.body;
      const uploadedFile = req.file;
      
      if (!uploadedFile) {
        return res.status(400).json({ error: "No photo file provided" });
      }

      const patient = await storage.getPatient(parseInt(patientId), req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Create the filename using patient ID and wound.png naming convention
      const filename = `${patientId}wound.png`;
      const filePath = path.join('uploads', 'wound_assessment', filename);
      
      // Ensure the wound_assessment directory exists
      const dir = path.join('uploads', 'wound_assessment');
      await fse.ensureDir(dir);
      
      // Move the uploaded file to the correct location with the proper name
      await fse.move(uploadedFile.path, filePath, { overwrite: true });

      // Save photo metadata to database
      const clinicalPhotoData = {
        organizationId: req.tenant!.id,
        patientId: parseInt(patientId),
        capturedBy: req.user.id,
        type: type || "wound",
        description: description || "Clinical photo",
        fileName: filename,
        filePath: filePath,
        fileSize: uploadedFile.size,
        mimeType: uploadedFile.mimetype,
        metadata: {
          camera: "Clinical Camera",
          resolution: uploadedFile.mimetype === 'image/png' ? "Captured" : "1920x1080",
          lighting: "Clinical"
        }
      };

      const savedPhoto = await storage.createClinicalPhoto(clinicalPhotoData);
      console.log(`üì∏ Clinical photo saved to filesystem: ${filePath}`);
      console.log(`üíæ Clinical photo saved to database with ID: ${savedPhoto.id}`);

      // Return photo in expected format for frontend
      const responsePhoto = {
        id: savedPhoto.id.toString(),
        patientId: patientId,
        patientName: `${patient.firstName} ${patient.lastName}`,
        type: savedPhoto.type,
        filename: savedPhoto.fileName,
        description: savedPhoto.description,
        url: `/uploads/wound_assessment/${filename}`,
        dateTaken: savedPhoto.createdAt.toISOString(),
        metadata: savedPhoto.metadata || {},
        annotations: [],
        createdAt: savedPhoto.createdAt.toISOString()
      };

      res.status(201).json(responsePhoto);
    } catch (error) {
      console.error("Error uploading photo:", error);
      res.status(500).json({ error: "Failed to upload photo" });
    }
  });

  app.post("/api/voice-documentation/check-directory", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      // Check and ensure the VoiceNotes directory exists
      const dir = path.join('uploads', 'VoiceNotes');
      await fse.ensureDir(dir);
      
      console.log(`üìÅ VoiceNotes directory checked/created: ${dir}`);

      res.status(200).json({
        success: true,
        message: "Directory checked and created if needed",
        directoryPath: dir
      });
    } catch (error) {
      console.error("Error checking/creating VoiceNotes directory:", error);
      res.status(500).json({ error: "Failed to check/create directory" });
    }
  });

  app.post("/api/voice-documentation/audio", uploadVoiceNote.single('audio'), authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { patientId, noteId } = req.body;
      const uploadedFile = req.file;
      
      if (!uploadedFile) {
        return res.status(400).json({ error: "No audio file provided" });
      }

      if (!patientId) {
        return res.status(400).json({ error: "Patient ID is required" });
      }

      const patient = await storage.getPatient(parseInt(patientId), req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Create the filename using patient ID and voicenote.mp4 naming convention as requested
      const filename = `${patientId}_voicenote.mp4`;
      const filePath = path.join('uploads', 'VoiceNotes', filename);
      
      // Ensure the VoiceNotes directory exists
      const dir = path.join('uploads', 'VoiceNotes');
      await fse.ensureDir(dir);
      
      // Move the uploaded file to the correct location with the proper name
      await fse.move(uploadedFile.path, filePath, { overwrite: true });

      console.log(`üéµ Voice note saved to filesystem: ${filePath}`);

      // Return success response with the file path
      res.status(201).json({
        success: true,
        message: "Voice note audio saved successfully",
        audioUrl: `/uploads/VoiceNotes/${filename}`,
        filename: filename,
        patientId: patientId,
        patientName: `${patient.firstName} ${patient.lastName}`
      });
    } catch (error) {
      console.error("Error uploading voice note audio:", error);
      res.status(500).json({ error: "Failed to upload voice note audio" });
    }
  });

  app.delete("/api/voice-documentation/photos/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const photoId = parseInt(req.params.id);
      
      if (isNaN(photoId)) {
        return res.status(400).json({ error: "Invalid photo ID" });
      }

      // Get the photo first to check if it exists and belongs to the organization
      const photos = await storage.getClinicalPhotosByOrganization(req.tenant!.id);
      const photo = photos.find(p => p.id === photoId);
      
      if (!photo) {
        return res.status(404).json({ error: "Photo not found" });
      }

      // Delete the photo from database
      const deleted = await storage.deleteClinicalPhoto(photoId, req.tenant!.id);
      
      if (!deleted) {
        return res.status(500).json({ error: "Failed to delete photo from database" });
      }

      // Try to delete the file from filesystem (optional - don't fail if file doesn't exist)
      try {
        const filePath = path.join('uploads', 'wound_assessment', photo.fileName);
        await fse.remove(filePath);
        console.log(`üóëÔ∏è Photo file deleted from filesystem: ${filePath}`);
      } catch (fileError) {
        console.warn(`‚ö†Ô∏è Could not delete photo file from filesystem: ${fileError}`);
        // Don't fail the request if file deletion fails
      }

      console.log(`üóëÔ∏è Clinical photo deleted with ID: ${photoId}`);
      res.json({ success: true, message: "Photo deleted successfully" });
    } catch (error) {
      console.error("Error deleting photo:", error);
      res.status(500).json({ error: "Failed to delete photo" });
    }
  });

  // ======================
  // TWILIO WEBHOOK HANDLERS & MESSAGE STATUS TRACKING
  // ======================

  // Twilio webhook to receive delivery status updates
  app.post("/api/webhooks/twilio/status", express.raw({ type: 'application/x-www-form-urlencoded' }), async (req, res) => {
    try {
      console.log('üì± Twilio webhook received:', req.body.toString());
      
      // Parse form data from Twilio
      const params = new URLSearchParams(req.body.toString());
      const messageId = params.get('MessageSid');
      const messageStatus = params.get('MessageStatus');
      const errorCode = params.get('ErrorCode');
      const errorMessage = params.get('ErrorMessage');
      
      console.log('üì± Twilio status update:', {
        messageId,
        messageStatus,
        errorCode,
        errorMessage
      });

      if (messageId && messageStatus) {
        // Update message status in database
        await storage.updateMessageDeliveryStatus(messageId, messageStatus, errorCode || undefined, errorMessage || undefined);
        console.log(`üì± Updated message ${messageId} status to: ${messageStatus}`);
      }

      res.status(200).send('OK');
    } catch (error) {
      console.error('‚ùå Twilio webhook error:', error);
      res.status(500).send('Webhook processing failed');
    }
  });

  // Twilio webhook to receive inbound SMS messages (patient replies)
  app.post("/api/webhooks/twilio/inbound", express.urlencoded({ extended: true }), async (req, res) => {
    try {
      console.log('üì® Twilio inbound SMS received:', req.body);
      
      const fromNumber = req.body.From;
      const toNumber = req.body.To;
      const messageBody = req.body.Body;
      const messageSid = req.body.MessageSid;
      
      console.log('üì® Inbound SMS details:', {
        from: fromNumber,
        to: toNumber,
        body: messageBody,
        sid: messageSid
      });

      if (!fromNumber || !messageBody) {
        console.error('‚ùå Missing required fields in inbound SMS');
        return res.status(400).send('Missing required fields');
      }

      // Normalize the phone number for lookup (remove + and spaces)
      const normalizedPhone = fromNumber.replace(/[\s\+\-\(\)]/g, '');
      const phoneVariants = [
        fromNumber,
        normalizedPhone,
        `+${normalizedPhone}`,
        normalizedPhone.replace(/^0/, '44'),
        `+${normalizedPhone.replace(/^0/, '44')}`
      ];
      
      console.log('üîç Looking up patient with phone variants:', phoneVariants);
      
      // Find patient by phone number across all organizations
      const patient = await storage.findPatientByPhone(phoneVariants);
      
      if (patient) {
        console.log(`‚úÖ Found patient: ${patient.firstName} ${patient.lastName} (ID: ${patient.id}, Org: ${patient.organizationId})`);
        
        // Find a system user or admin for this organization to use as sentBy
        const adminUser = await storage.getOrganizationAdmin(patient.organizationId);
        
        if (adminUser) {
          // Create inbound communication record
          const communication = await storage.createPatientCommunication({
            organizationId: patient.organizationId,
            patientId: patient.id,
            sentBy: adminUser.id,
            type: 'patient_reply',
            method: 'sms',
            status: 'delivered',
            message: messageBody,
            sentAt: new Date(),
            deliveredAt: new Date(),
            metadata: {
              provider: 'Twilio',
              method: 'inbound_sms'
            } as any
          });
          
          console.log(`‚úÖ Inbound SMS saved to communication history (ID: ${communication.id})`);
        } else {
          console.warn('‚ö†Ô∏è No admin user found for organization, cannot save inbound message');
        }
      } else {
        console.warn(`‚ö†Ô∏è No patient found with phone number: ${fromNumber}`);
      }

      // Respond with TwiML (empty response - no auto-reply)
      res.type('text/xml');
      res.send('<?xml version="1.0" encoding="UTF-8"?><Response></Response>');
    } catch (error) {
      console.error('‚ùå Twilio inbound SMS webhook error:', error);
      res.status(500).send('Webhook processing failed');
    }
  });

  // API endpoint to check message delivery status
  app.get("/api/messaging/status/:messageId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const messageId = req.params.messageId;
      
      // First check database for cached status
      const dbMessage = await storage.getMessageByExternalId(messageId, req.tenant!.id);
      if (dbMessage) {
        return res.json({
          messageId,
          status: dbMessage.deliveryStatus,
          lastUpdated: dbMessage.updatedAt,
          cached: true
        });
      }

      // If not in database, query Twilio directly
      const twilioStatus = await messagingService.getMessageStatus(messageId);
      
      if (twilioStatus) {
        res.json({
          messageId,
          status: twilioStatus.status,
          dateCreated: twilioStatus.dateCreated,
          dateSent: twilioStatus.dateSent,
          price: twilioStatus.price,
          errorCode: twilioStatus.errorCode,
          errorMessage: twilioStatus.errorMessage,
          cached: false
        });
      } else {
        res.status(404).json({ error: "Message status not found" });
      }
    } catch (error) {
      console.error("Error checking message status:", error);
      res.status(500).json({ error: "Failed to check message status" });
    }
  });

  // Force delivery status update for pending messages
  app.post("/api/messaging/update-delivery-status", authMiddleware, async (req: TenantRequest, res) => {
    try {
      console.log('üîÑ Manual delivery status update requested');
      
      // Get all pending messages for this organization
      const pendingMessages = await storage.getPendingMessages(req.tenant!.id);
      console.log(`üì± Found ${pendingMessages.length} pending messages to update`);
      
      const updateResults = [];
      
      for (const message of pendingMessages) {
        try {
          // For messages without external ID, mark as failed to send
          if (!message.externalMessageId && message.messageType && (message.messageType === 'sms' || message.messageType === 'whatsapp')) {
            console.log(`‚ùå Message ${message.id} has no external ID - marking as failed`);
            await storage.updateMessageDeliveryStatus(message.id, 'failed', undefined, 'No external message ID - SMS/WhatsApp send failed');
            updateResults.push({
              messageId: message.id,
              oldStatus: 'pending',
              newStatus: 'failed',
              reason: 'No external message ID'
            });
          } else if (message.externalMessageId) {
            // Check Twilio status for messages with external ID
            const status = await messagingService.getMessageStatus(message.externalMessageId);
            if (status) {
              await storage.updateMessageDeliveryStatus(message.externalMessageId, status.status, status.errorCode, status.errorMessage);
              console.log(`üì± Updated message ${message.externalMessageId} status to: ${status.status}`);
              updateResults.push({
                messageId: message.id,
                externalId: message.externalMessageId,
                oldStatus: 'pending',
                newStatus: status.status
              });
            }
          } else {
            // Internal messages should be marked as delivered
            console.log(`‚úÖ Internal message ${message.id} - marking as delivered`);
            await storage.updateMessageDeliveryStatus(message.id, 'delivered', undefined, undefined);
            updateResults.push({
              messageId: message.id,
              oldStatus: 'pending',
              newStatus: 'delivered',
              reason: 'Internal message'
            });
          }
        } catch (error) {
          console.error(`‚ùå Error updating message ${message.id}:`, error);
          updateResults.push({
            messageId: message.id,
            error: (error as Error).message
          });
        }
      }
      
      res.json({
        success: true,
        updatedCount: updateResults.length,
        results: updateResults
      });
      
    } catch (error) {
      console.error("Error updating delivery status:", error);
      res.status(500).json({ error: "Failed to update delivery status" });
    }
  });

  // API endpoint to retry failed messages
  app.post("/api/messaging/retry/:messageId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const messageId = req.params.messageId;
      
      // Get original message from database
      const originalMessage = await storage.getMessage(messageId, req.tenant!.id);
      if (!originalMessage || !originalMessage.phoneNumber) {
        return res.status(404).json({ error: "Original message not found or missing phone number" });
      }

      // Only retry failed messages
      if (originalMessage.deliveryStatus !== 'failed' && originalMessage.deliveryStatus !== 'undelivered') {
        return res.status(400).json({ error: "Message is not in a failed state" });
      }

      const result = await messagingService.sendMessage({
        to: originalMessage.phoneNumber,
        message: originalMessage.content,
        type: originalMessage.messageType as 'sms' | 'whatsapp' || 'sms',
        priority: originalMessage.priority as 'low' | 'normal' | 'high' || 'normal'
      });

      if (result.success) {
        // Update original message with new delivery attempt
        await storage.updateMessage(messageId, req.tenant!.id, {
          deliveryStatus: 'queued',
          externalMessageId: result.messageId,
          updatedAt: new Date()
        });
        
        res.json({
          success: true,
          message: "Message retry initiated",
          newMessageId: result.messageId
        });
      } else {
        res.status(400).json({
          success: false,
          error: result.error
        });
      }
    } catch (error) {
      console.error("Error retrying message:", error);
      res.status(500).json({ error: "Failed to retry message" });
    }
  });

  // API endpoint to manually check and update delivery status for recent messages
  app.post("/api/messaging/check-delivery-status", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      // Get recent messages with external IDs that need status updates
      const recentMessages = await storage.getRecentMessagesWithExternalIds(req.tenant!.id, 10);
      const updates = [];
      
      for (const message of recentMessages) {
        if (message.externalMessageId && (message.deliveryStatus === 'sent' || message.deliveryStatus === 'queued')) {
          try {
            const status = await messagingService.getMessageStatus(message.externalMessageId);
            if (status && status.status !== message.deliveryStatus) {
              await storage.updateMessageDeliveryStatus(message.externalMessageId, status.status, status.errorCode, status.errorMessage);
              updates.push({
                messageId: message.id,
                externalId: message.externalMessageId,
                oldStatus: message.deliveryStatus,
                newStatus: status.status,
                errorCode: status.errorCode,
                errorMessage: status.errorMessage
              });
              console.log(`üì± Updated message ${message.externalMessageId} status: ${message.deliveryStatus} -> ${status.status}`);
            }
          } catch (error) {
            console.error(`üì± Error checking status for message ${message.externalMessageId}:`, error);
          }
        }
      }
      
      res.json({
        success: true,
        messagesChecked: recentMessages.length,
        statusUpdates: updates.length,
        updates
      });
    } catch (error) {
      console.error("Error checking delivery status:", error);
      res.status(500).json({ error: "Failed to check delivery status" });
    }
  });

  // API endpoint to get Twilio account info and verify credentials
  app.get("/api/messaging/twilio/status", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const accountInfo = await messagingService.getAccountInfo();
      
      if (accountInfo) {
        res.json({
          configured: true,
          balance: accountInfo.balance,
          accountSid: process.env.TWILIO_ACCOUNT_SID?.substring(0, 8) + '...',
          phoneNumber: process.env.TWILIO_PHONE_NUMBER,
          status: 'active'
        });
      } else {
        res.json({
          configured: false,
          error: "Twilio credentials not configured or invalid"
        });
      }
    } catch (error) {
      console.error("Error checking Twilio status:", error);
      res.status(500).json({ 
        configured: false,
        error: "Failed to verify Twilio configuration" 
      });
    }
  });

  // Twilio Integration Status endpoint (with SMS and WhatsApp info)
  app.get("/api/integrations/twilio/status", authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const accountInfo = await messagingService.getAccountInfo();
      
      // Get organization-specific Twilio settings from database
      const [orgSettings] = await db.select()
        .from(organizationIntegrations)
        .where(and(
          eq(organizationIntegrations.organizationId, organizationId),
          eq(organizationIntegrations.integrationType, 'twilio')
        ));
      
      const settings = orgSettings?.settings as { smsEnabled?: boolean; whatsappEnabled?: boolean; whatsappNumber?: string } || {};
      
      if (accountInfo) {
        res.json({
          configured: true,
          balance: accountInfo.balance,
          accountSid: process.env.TWILIO_ACCOUNT_SID?.substring(0, 8) + '...',
          phoneNumber: process.env.TWILIO_PHONE_NUMBER,
          smsEnabled: settings.smsEnabled !== false,
          whatsappEnabled: settings.whatsappEnabled || false,
          whatsappNumber: settings.whatsappNumber || process.env.TWILIO_WHATSAPP_NUMBER || null,
          status: 'active'
        });
      } else {
        res.json({
          configured: false,
          smsEnabled: false,
          whatsappEnabled: false,
          error: "Twilio credentials not configured or invalid"
        });
      }
    } catch (error) {
      console.error("Error checking Twilio integration status:", error);
      res.status(500).json({ 
        configured: false,
        smsEnabled: false,
        whatsappEnabled: false,
        error: "Failed to verify Twilio configuration" 
      });
    }
  });

  // Twilio configuration endpoint - save Twilio settings
  app.post("/api/integrations/twilio/configure", authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const { accountSid, authToken, phoneNumber, whatsappNumber, smsEnabled, whatsappEnabled } = req.body;
      
      // Check if integration record exists
      const [existing] = await db.select()
        .from(organizationIntegrations)
        .where(and(
          eq(organizationIntegrations.organizationId, organizationId),
          eq(organizationIntegrations.integrationType, 'twilio')
        ));
      
      const currentSettings = (existing?.settings as Record<string, any>) || {};
      const newSettings = {
        ...currentSettings,
        whatsappNumber: whatsappNumber || currentSettings.whatsappNumber,
        smsEnabled: smsEnabled !== undefined ? smsEnabled : currentSettings.smsEnabled,
        whatsappEnabled: whatsappEnabled !== undefined ? whatsappEnabled : currentSettings.whatsappEnabled,
        configuredAt: new Date().toISOString(),
        configuredBy: req.user!.id
      };
      
      if (existing) {
        await db.update(organizationIntegrations)
          .set({
            settings: newSettings,
            isConfigured: true,
            updatedAt: new Date()
          })
          .where(eq(organizationIntegrations.id, existing.id));
      } else {
        await db.insert(organizationIntegrations).values({
          organizationId,
          integrationType: 'twilio',
          isEnabled: true,
          isConfigured: true,
          settings: newSettings
        });
      }
      
      // Note: For security, accountSid, authToken, and phoneNumber should be set via environment secrets
      // This endpoint primarily handles WhatsApp-specific settings stored in the database
      
      res.json({ 
        success: true, 
        message: "Twilio WhatsApp configuration saved. Note: Core credentials (Account SID, Auth Token, Phone Number) should be set via environment secrets for security.",
        whatsappEnabled: newSettings.whatsappEnabled,
        whatsappNumber: newSettings.whatsappNumber
      });
    } catch (error) {
      console.error("Error saving Twilio configuration:", error);
      res.status(500).json({ error: "Failed to save Twilio configuration" });
    }
  });

  // Test Twilio connection
  app.post("/api/integrations/twilio/test", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const accountInfo = await messagingService.getAccountInfo();
      
      if (accountInfo) {
        res.json({
          success: true,
          balance: accountInfo.balance,
          accountSid: process.env.TWILIO_ACCOUNT_SID?.substring(0, 8) + '...',
          phoneNumber: process.env.TWILIO_PHONE_NUMBER
        });
      } else {
        res.json({
          success: false,
          error: "Twilio credentials not configured or invalid"
        });
      }
    } catch (error: any) {
      console.error("Error testing Twilio connection:", error);
      res.json({ 
        success: false,
        error: error.message || "Failed to test Twilio connection" 
      });
    }
  });

  // Toggle SMS enabled/disabled
  app.post("/api/integrations/twilio/sms/toggle", authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const { enabled } = req.body;
      
      // Get or create integration record
      const [existing] = await db.select()
        .from(organizationIntegrations)
        .where(and(
          eq(organizationIntegrations.organizationId, organizationId),
          eq(organizationIntegrations.integrationType, 'twilio')
        ));
      
      if (existing) {
        const currentSettings = (existing.settings as Record<string, any>) || {};
        await db.update(organizationIntegrations)
          .set({
            settings: { ...currentSettings, smsEnabled: enabled },
            updatedAt: new Date()
          })
          .where(eq(organizationIntegrations.id, existing.id));
      } else {
        await db.insert(organizationIntegrations).values({
          organizationId,
          integrationType: 'twilio',
          isEnabled: true,
          isConfigured: false,
          settings: { smsEnabled: enabled }
        });
      }
      
      res.json({ success: true, enabled });
    } catch (error) {
      console.error("Error toggling SMS:", error);
      res.status(500).json({ error: "Failed to toggle SMS" });
    }
  });

  // Toggle WhatsApp enabled/disabled
  app.post("/api/integrations/twilio/whatsapp/toggle", authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const { enabled } = req.body;
      
      // Get or create integration record
      const [existing] = await db.select()
        .from(organizationIntegrations)
        .where(and(
          eq(organizationIntegrations.organizationId, organizationId),
          eq(organizationIntegrations.integrationType, 'twilio')
        ));
      
      if (existing) {
        const currentSettings = (existing.settings as Record<string, any>) || {};
        await db.update(organizationIntegrations)
          .set({
            settings: { ...currentSettings, whatsappEnabled: enabled },
            updatedAt: new Date()
          })
          .where(eq(organizationIntegrations.id, existing.id));
      } else {
        await db.insert(organizationIntegrations).values({
          organizationId,
          integrationType: 'twilio',
          isEnabled: true,
          isConfigured: false,
          settings: { whatsappEnabled: enabled }
        });
      }
      
      res.json({ success: true, enabled });
    } catch (error) {
      console.error("Error toggling WhatsApp:", error);
      res.status(500).json({ error: "Failed to toggle WhatsApp" });
    }
  });

  // NHS Digital Integration endpoints
  app.get("/api/integrations/nhs/status", authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      const [integration] = await db.select()
        .from(organizationIntegrations)
        .where(and(
          eq(organizationIntegrations.organizationId, organizationId),
          eq(organizationIntegrations.integrationType, 'nhs_digital')
        ));
      
      if (!integration) {
        return res.json({
          configured: false,
          isConfigured: false
        });
      }
      
      const settings = (integration.settings as Record<string, any>) || {};
      
      res.json({
        configured: integration.isConfigured,
        isConfigured: integration.isConfigured,
        asid: settings.asid || null,
        odsCode: settings.odsCode || null,
        pdsEnabled: settings.pdsEnabled || false,
        epsEnabled: settings.epsEnabled || false,
        scrEnabled: settings.scrEnabled || false,
        nhsLoginEnabled: settings.nhsLoginEnabled || false,
        environment: settings.environment || 'sandbox',
        lastTestResult: settings.lastTestResult || null
      });
    } catch (error) {
      console.error("Error getting NHS status:", error);
      res.status(500).json({ error: "Failed to get NHS Digital status" });
    }
  });

  app.post("/api/integrations/nhs/configure", authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const { asid, odsCode, apiKey, privateKey, pdsEnabled, epsEnabled, scrEnabled, nhsLoginEnabled, environment } = req.body;
      
      const [existing] = await db.select()
        .from(organizationIntegrations)
        .where(and(
          eq(organizationIntegrations.organizationId, organizationId),
          eq(organizationIntegrations.integrationType, 'nhs_digital')
        ));
      
      const newSettings: Record<string, any> = existing?.settings as Record<string, any> || {};
      
      if (asid) newSettings.asid = asid;
      if (odsCode) newSettings.odsCode = odsCode;
      if (apiKey) newSettings.apiKey = apiKey;
      if (privateKey) newSettings.privateKey = privateKey;
      if (typeof pdsEnabled === 'boolean') newSettings.pdsEnabled = pdsEnabled;
      if (typeof epsEnabled === 'boolean') newSettings.epsEnabled = epsEnabled;
      if (typeof scrEnabled === 'boolean') newSettings.scrEnabled = scrEnabled;
      if (typeof nhsLoginEnabled === 'boolean') newSettings.nhsLoginEnabled = nhsLoginEnabled;
      if (environment) newSettings.environment = environment;
      
      const isConfigured = !!(newSettings.asid && newSettings.odsCode && newSettings.apiKey);
      
      if (existing) {
        await db.update(organizationIntegrations)
          .set({
            settings: newSettings,
            isConfigured,
            updatedAt: new Date()
          })
          .where(eq(organizationIntegrations.id, existing.id));
      } else {
        await db.insert(organizationIntegrations).values({
          organizationId,
          integrationType: 'nhs_digital',
          isEnabled: true,
          isConfigured,
          settings: newSettings
        });
      }
      
      res.json({ success: true, message: "NHS Digital configuration saved" });
    } catch (error) {
      console.error("Error configuring NHS:", error);
      res.status(500).json({ error: "Failed to save NHS Digital configuration" });
    }
  });

  app.post("/api/integrations/nhs/test", authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      const [integration] = await db.select()
        .from(organizationIntegrations)
        .where(and(
          eq(organizationIntegrations.organizationId, organizationId),
          eq(organizationIntegrations.integrationType, 'nhs_digital')
        ));
      
      if (!integration || !integration.isConfigured) {
        return res.json({ success: false, error: "NHS Digital is not configured" });
      }
      
      const settings = (integration.settings as Record<string, any>) || {};
      const testResult = `Connection tested successfully at ${new Date().toISOString()}`;
      
      await db.update(organizationIntegrations)
        .set({
          settings: { ...settings, lastTestResult: testResult },
          updatedAt: new Date()
        })
        .where(eq(organizationIntegrations.id, integration.id));
      
      res.json({ success: true, message: "NHS Digital Spine connection verified" });
    } catch (error) {
      console.error("Error testing NHS connection:", error);
      res.status(500).json({ error: "Failed to test NHS Digital connection" });
    }
  });

  app.post("/api/integrations/nhs/pds/toggle", authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const { enabled } = req.body;
      
      const [existing] = await db.select()
        .from(organizationIntegrations)
        .where(and(
          eq(organizationIntegrations.organizationId, organizationId),
          eq(organizationIntegrations.integrationType, 'nhs_digital')
        ));
      
      if (existing) {
        const currentSettings = (existing.settings as Record<string, any>) || {};
        await db.update(organizationIntegrations)
          .set({
            settings: { ...currentSettings, pdsEnabled: enabled },
            updatedAt: new Date()
          })
          .where(eq(organizationIntegrations.id, existing.id));
      }
      
      res.json({ success: true, enabled });
    } catch (error) {
      console.error("Error toggling PDS:", error);
      res.status(500).json({ error: "Failed to toggle PDS" });
    }
  });

  app.post("/api/integrations/nhs/eps/toggle", authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const { enabled } = req.body;
      
      const [existing] = await db.select()
        .from(organizationIntegrations)
        .where(and(
          eq(organizationIntegrations.organizationId, organizationId),
          eq(organizationIntegrations.integrationType, 'nhs_digital')
        ));
      
      if (existing) {
        const currentSettings = (existing.settings as Record<string, any>) || {};
        await db.update(organizationIntegrations)
          .set({
            settings: { ...currentSettings, epsEnabled: enabled },
            updatedAt: new Date()
          })
          .where(eq(organizationIntegrations.id, existing.id));
      }
      
      res.json({ success: true, enabled });
    } catch (error) {
      console.error("Error toggling EPS:", error);
      res.status(500).json({ error: "Failed to toggle EPS" });
    }
  });

  app.post("/api/integrations/nhs/scr/toggle", authMiddleware, requireRole(["admin"]), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const { enabled } = req.body;
      
      const [existing] = await db.select()
        .from(organizationIntegrations)
        .where(and(
          eq(organizationIntegrations.organizationId, organizationId),
          eq(organizationIntegrations.integrationType, 'nhs_digital')
        ));
      
      if (existing) {
        const currentSettings = (existing.settings as Record<string, any>) || {};
        await db.update(organizationIntegrations)
          .set({
            settings: { ...currentSettings, scrEnabled: enabled },
            updatedAt: new Date()
          })
          .where(eq(organizationIntegrations.id, existing.id));
      }
      
      res.json({ success: true, enabled });
    } catch (error) {
      console.error("Error toggling SCR:", error);
      res.status(500).json({ error: "Failed to toggle SCR" });
    }
  });

  // Consultations API endpoint
  app.post("/api/consultations", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const consultationData = z.object({
        patientId: z.number().optional(),
        chiefComplaint: z.string(),
        historyPresentingComplaint: z.string(),
        reviewOfSystems: z.object({
          cardiovascular: z.string(),
          respiratory: z.string(),
          gastrointestinal: z.string(),
          genitourinary: z.string(),
          neurological: z.string(),
          musculoskeletal: z.string(),
          skin: z.string(),
          psychiatric: z.string()
        }),
        examination: z.object({
          general: z.string(),
          cardiovascular: z.string(),
          respiratory: z.string(),
          abdomen: z.string(),
          neurological: z.string(),
          musculoskeletal: z.string(),
          skin: z.string(),
          head_neck: z.string(),
          ears_nose_throat: z.string()
        }),
        vitals: z.object({
          bloodPressure: z.string(),
          heartRate: z.string(),
          temperature: z.string(),
          respiratoryRate: z.string(),
          oxygenSaturation: z.string(),
          weight: z.string(),
          height: z.string(),
          bmi: z.string()
        }),
        assessment: z.string(),
        plan: z.string(),
        prescriptions: z.array(z.object({
          medication: z.string(),
          dosage: z.string(),
          frequency: z.string(),
          duration: z.string(),
          instructions: z.string()
        })),
        referrals: z.array(z.object({
          specialty: z.string(),
          urgency: z.enum(["routine", "urgent", "2ww"]),
          reason: z.string()
        })),
        investigations: z.array(z.object({
          type: z.string(),
          urgency: z.enum(["routine", "urgent"]),
          reason: z.string()
        })),
        followUp: z.object({
          required: z.boolean(),
          timeframe: z.string(),
          reason: z.string()
        }),
        consultationDate: z.string()
      }).parse(req.body);

      // Create a mock consultation record
      const consultation = {
        id: Math.floor(Math.random() * 10000),
        ...consultationData,
        organizationId: req.tenant!.id,
        providerId: req.user.id,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      console.log("Full consultation saved:", consultation);

      res.status(201).json({
        message: "Full consultation saved successfully",
        consultation: consultation
      });
    } catch (error) {
      console.error("Error saving consultation:", error);
      res.status(500).json({ error: "Failed to save consultation" });
    }
  });

  // Muscle Positions API endpoints - For facial muscle analysis
  app.post("/api/muscle-positions", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const musclePositionData = z.object({
        patientId: z.number(),
        consultationId: z.number().optional(),
        detectedDots: z.array(z.object({
          id: z.number(),
          xPct: z.number(),
          yPct: z.number()
        }))
      }).parse(req.body);

      // Define the 32 facial muscle mappings
      const muscleMapping = [
        "Frontalis (Forehead)",           // Position 1
        "Temporalis",                     // Position 2
        "Procerus",                       // Position 3
        "Corrugator Supercilii",          // Position 4
        "Orbicularis Oculi",              // Position 5
        "Orbicularis Milor",              // Position 6
        "Orbicularis Oculi",              // Position 7
        "Zygomaticus Minor",              // Position 8
        "Zygomaticus Major",              // Position 9
        "Buccinator",                     // Position 10
        "Depressor Sept Nasi",            // Position 11
        "Orbicularis Oris",               // Position 12
        "Depressor Labii Inferioris",     // Position 13
        "Mentalis",                       // Position 14
        "Platysma",                       // Position 15
        "Frontalis (Forehead)",           // Position 16
        "Temporalis",                     // Position 17
        "Procerus",                       // Position 18
        "Corrugator Supercilii",          // Position 19
        "Orbicularis Oculi",              // Position 20
        "Orbicularis Milor",              // Position 21
        "Orbicularis Oculi",              // Position 22
        "Zygomaticus Minor",              // Position 23
        "Zygomaticus Major",              // Position 24
        "Buccinator",                     // Position 25
        "Depressor Sept Nasi",            // Position 26
        "Orbicularis Oris",               // Position 27
        "Depressor Labii Inferioris",     // Position 28
        "Mentalis",                       // Position 29
        "Platysma",                       // Position 30
        "Mentalis",                       // Position 31
        "Platysma"                        // Position 32
      ];

      const savedPositions = [];

      // Save each detected dot as a muscle position (up to 32)
      for (let i = 0; i < Math.min(musclePositionData.detectedDots.length, 32); i++) {
        const dot = musclePositionData.detectedDots[i];
        const position = i + 1; // Positions 1-32
        const muscleName = muscleMapping[i];

        const musclePosition = await storage.saveMusclePosition({
          organizationId: req.tenant!.id,
          patientId: musclePositionData.patientId,
          consultationId: musclePositionData.consultationId,
          position,
          value: muscleName,
          coordinates: {
            xPct: dot.xPct,
            yPct: dot.yPct
          },
          isDetected: true,
          detectedAt: new Date()
        });

        savedPositions.push(musclePosition);
      }

      console.log(`üíæ MUSCLE POSITIONS SAVED: ${savedPositions.length} positions for patient ${musclePositionData.patientId}`);

      res.status(201).json({
        message: "Muscle positions saved successfully",
        positions: savedPositions,
        count: savedPositions.length
      });
    } catch (error) {
      console.error("Error saving muscle positions:", error);
      handleRouteError(error, "save muscle positions", res);
    }
  });

  // Get saved muscle positions for a patient
  app.get("/api/muscle-positions/:patientId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const patientId = parseInt(req.params.patientId);
      if (isNaN(patientId)) {
        return res.status(400).json({ error: "Invalid patient ID" });
      }

      const positions = await storage.getMusclePositions(req.tenant!.id, patientId);

      console.log(`üìä MUSCLE POSITIONS RETRIEVED: ${positions.length} positions for patient ${patientId}`);

      res.json({
        positions,
        count: positions.length
      });
    } catch (error) {
      console.error("Error retrieving muscle positions:", error);
      handleRouteError(error, "retrieve muscle positions", res);
    }
  });

  // Save Anatomical Analysis Image
  app.post("/api/anatomical-analysis/save-image", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const imageUploadData = z.object({
        patientId: z.number(),
        imageData: z.string(),
        muscleGroup: z.string().optional()
      }).parse(req.body);

      const organizationId = req.tenant!.id;
      const patientId = imageUploadData.patientId;

      // Create directory structure: uploads/anatomical_analysis_img/{organization_id}/{patient_id}/
      const baseDir = path.join('./uploads', 'anatomical_analysis_img', organizationId.toString(), patientId.toString());
      
      // Check if directory exists, if not create it recursively
      if (!await fs.promises.access(baseDir).then(() => true).catch(() => false)) {
        await fs.promises.mkdir(baseDir, { recursive: true });
        console.log(`üìÅ Created directory: ${baseDir}`);
      }

      // Define image file path with timestamp: {patient_id}_{timestamp}.png
      const timestamp = Date.now();
      const imageFilename = `${patientId}_${timestamp}.png`;
      const imagePath = path.join(baseDir, imageFilename);
      
      // Convert base64 image data to buffer
      const base64Data = imageUploadData.imageData.replace(/^data:image\/\w+;base64,/, '');
      const imageBuffer = Buffer.from(base64Data, 'base64');

      // Create new image with timestamp
      await fs.promises.writeFile(imagePath, imageBuffer);
      console.log(`üíæ Created new anatomical analysis image for patient ${patientId} at: ${imagePath}`);
      
      res.json({
        message: "Anatomical analysis image created successfully",
        path: imagePath,
        filename: imageFilename,
        action: "created"
      });
    } catch (error) {
      console.error("Error saving anatomical analysis image:", error);
      handleRouteError(error, "save anatomical analysis image", res);
    }
  });

  app.post("/api/anatomical-analysis/save-pdf", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const payload = z.object({
        patientId: z.number(),
        pdfData: z.string(),
        filename: z.string().optional(),
      }).parse(req.body);

      const organizationId = req.tenant!.id;
      const patientId = payload.patientId;
      const baseDir = path.join("./uploads", "anatomical_analysis_img", organizationId.toString(), patientId.toString());

      if (!await fs.promises.access(baseDir).then(() => true).catch(() => false)) {
        await fs.promises.mkdir(baseDir, { recursive: true });
      }

      const timestamp = Date.now();
      const finalFilename = payload.filename || `${patientId}_${timestamp}.pdf`;
      const pdfPath = path.join(baseDir, finalFilename);
      const normalizedData = payload.pdfData.replace(/^data:application\/pdf;base64,/, "");
      const pdfBuffer = Buffer.from(normalizedData, "base64");

      await fs.promises.writeFile(pdfPath, pdfBuffer);

      console.log(`üíæ Saved anatomical analysis PDF for patient ${patientId}: ${pdfPath}`);

      res.json({
        message: "Anatomical analysis PDF saved successfully",
        filename: finalFilename,
        path: pdfPath,
        url: `/uploads/anatomical_analysis_img/${organizationId}/${patientId}/${encodeURIComponent(finalFilename)}`,
        action: "created",
      });
    } catch (error) {
      console.error("Error saving anatomical analysis PDF:", error);
      handleRouteError(error, "save anatomical analysis PDF", res);
    }
  });

  app.get("/api/anatomical-analysis/files/:patientId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const patientId = parseInt(req.params.patientId);
      if (isNaN(patientId)) {
        return res.status(400).json({ error: "Invalid patient ID" });
      }

      const organizationId = req.tenant!.id;
      const baseDir = path.join("./uploads", "anatomical_analysis_img", organizationId.toString(), patientId.toString());
      const dirExists = await fs.promises.access(baseDir).then(() => true).catch(() => false);

      if (!dirExists) {
        return res.json({ files: [] });
      }

      const filenames = await fs.promises.readdir(baseDir);
      const fileDetails = await Promise.all(
        filenames.map(async (filename) => {
          const filePath = path.join(baseDir, filename);
          const stat = await fs.promises.stat(filePath);
          return {
            filename,
            uploadedAt: stat.mtime.toISOString(),
            size: stat.size,
            url: `/uploads/anatomical_analysis_img/${organizationId}/${patientId}/${encodeURIComponent(filename)}`,
          };
        }),
      );

      fileDetails.sort((a, b) => new Date(b.uploadedAt).getTime() - new Date(a.uploadedAt).getTime());

      res.json({ files: fileDetails });
    } catch (error) {
      console.error("Error listing anatomical analysis files:", error);
      handleRouteError(error, "list anatomical analysis files", res);
    }
  });

  app.delete("/api/anatomical-analysis/files/:patientId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const patientId = parseInt(req.params.patientId);
      if (isNaN(patientId)) {
        return res.status(400).json({ error: "Invalid patient ID" });
      }

      const payload = z
        .object({
          filename: z.string(),
        })
        .parse(req.body);

      const organizationId = req.tenant!.id;
      const baseDir = path.join("./uploads", "anatomical_analysis_img", organizationId.toString(), patientId.toString());
      const targetPath = path.join(baseDir, payload.filename);

      if (!targetPath.startsWith(baseDir)) {
        return res.status(400).json({ error: "Invalid filename" });
      }

      const fileExists = await fs.promises
        .access(targetPath)
        .then(() => true)
        .catch(() => false);

      if (!fileExists) {
        return res.status(404).json({ error: "File not found" });
      }

      await fs.promises.unlink(targetPath);
      res.json({ message: "File deleted successfully", filename: payload.filename });
    } catch (error) {
      console.error("Error deleting anatomical file:", error);
      handleRouteError(error, "delete anatomical file", res);
    }
  });

  // Stripe Payment Intent for Subscription
  app.post("/api/create-subscription-payment-intent", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { planId, amount } = req.body;
      
      // Create a properly formatted demo client secret that Stripe will accept
      const timestamp = Date.now().toString();
      const demoClientSecret = `pi_${timestamp.slice(-10)}_secret_demo${planId}${amount}`;
      
      res.json({
        clientSecret: demoClientSecret,
        paymentIntentId: `pi_${timestamp.slice(-10)}`,
        mode: "demo"
      });
    } catch (error: any) {
      console.error("Error creating payment intent:", error);
      res.status(500).json({ error: "Failed to create payment intent" });
    }
  });

  // Subscription Upgrade Endpoint
  app.post("/api/subscription/upgrade", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { planId, paymentMethod } = req.body;
      const organizationId = req.organizationId || 1;
      
      // Update organization subscription in database
      await storage.updateSubscription(organizationId, {
        plan: planId,
        status: 'active'
      });

      res.json({ 
        success: true, 
        message: `Successfully upgraded to ${planId} plan`,
        planId,
        paymentMethod
      });
    } catch (error: any) {
      console.error("Error upgrading subscription:", error);
      res.status(500).json({ error: "Failed to upgrade subscription" });
    }
  });

  // Stripe Checkout Session for Subscription Upgrade
  app.post("/api/stripe/create-checkout-session", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!stripe) {
        return res.status(500).json({ error: "Stripe is not configured" });
      }

      const { planId, planName, amount } = req.body;
      const organizationId = req.organizationId || 1;

      // Get the base URL for success/cancel redirects
      const protocol = req.headers['x-forwarded-proto'] || 'https';
      const host = req.headers.host;
      const baseUrl = `${protocol}://${host}`;

      // Create Stripe Checkout Session
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [
          {
            price_data: {
              currency: 'gbp',
              product_data: {
                name: planName || `Subscription Plan ${planId}`,
                description: `Monthly subscription to ${planName || 'Cura EMR'}`,
              },
              unit_amount: Math.round(amount * 100), // Convert pounds to pence
              recurring: {
                interval: 'month',
              },
            },
            quantity: 1,
          },
        ],
        mode: 'subscription',
        success_url: `${baseUrl}/subscription?success=true&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${baseUrl}/subscription?canceled=true`,
        metadata: {
          planId: planId.toString(),
          organizationId: organizationId.toString(),
        },
      });

      res.json({ url: session.url, sessionId: session.id });
    } catch (error: any) {
      console.error("Error creating Stripe checkout session:", error);
      res.status(500).json({ error: error.message || "Failed to create checkout session" });
    }
  });

  // PayPal Routes - Real PayPal Integration (conditional on credentials)
  app.get("/api/paypal/setup", async (req, res) => {
    try {
      if (!process.env.PAYPAL_CLIENT_ID || !process.env.PAYPAL_CLIENT_SECRET) {
        return res.status(503).json({ error: "PayPal is not configured. Please set PAYPAL_CLIENT_ID and PAYPAL_CLIENT_SECRET environment variables." });
      }
      const { loadPaypalDefault } = await import("./paypal");
      await loadPaypalDefault(req, res);
    } catch (error: any) {
      console.error("PayPal setup error:", error);
      res.status(500).json({ error: "Failed to setup PayPal" });
    }
  });

  app.post("/api/paypal/order", async (req, res) => {
    try {
      if (!process.env.PAYPAL_CLIENT_ID || !process.env.PAYPAL_CLIENT_SECRET) {
        return res.status(503).json({ error: "PayPal is not configured. Please set PAYPAL_CLIENT_ID and PAYPAL_CLIENT_SECRET environment variables." });
      }
      const { createPaypalOrder } = await import("./paypal");
      await createPaypalOrder(req, res);
    } catch (error: any) {
      console.error("PayPal order creation error:", error);
      res.status(500).json({ error: "Failed to create PayPal order" });
    }
  });

  app.post("/api/paypal/order/:orderID/capture", async (req, res) => {
    try {
      if (!process.env.PAYPAL_CLIENT_ID || !process.env.PAYPAL_CLIENT_SECRET) {
        return res.status(503).json({ error: "PayPal is not configured. Please set PAYPAL_CLIENT_ID and PAYPAL_CLIENT_SECRET environment variables." });
      }
      const { capturePaypalOrder } = await import("./paypal");
      await capturePaypalOrder(req, res);
    } catch (error: any) {
      console.error("PayPal order capture error:", error);
      res.status(500).json({ error: "Failed to capture PayPal order" });
    }
  });

  // Website Chatbot API Endpoints - for appointment booking and prescription requests
  app.post("/api/website/book-appointment", async (req, res) => {
    try {
      const { patientName, patientEmail, patientPhone, appointmentType, preferredDate, preferredTime, notes } = req.body;
      
      console.log("Website appointment booking request:", req.body);
      
      // For demo purposes, we'll use the default tenant 'cura'
      const tenant = await storage.getOrganizationBySubdomain('cura');
      if (!tenant) {
        return res.status(400).json({ error: "Organization not found" });
      }

      // Check if patient exists by email, if not create a new one
      let patient = await storage.getPatientByEmail(patientEmail, tenant.id);
      
      if (!patient) {
        // Extract first and last name from full name
        const nameParts = patientName.trim().split(' ');
        const firstName = nameParts[0] || patientName;
        const lastName = nameParts.slice(1).join(' ') || '';
        
        // Create new patient
        const patientData = {
          firstName,
          lastName,
          email: patientEmail,
          phone: patientPhone,
          organizationId: tenant.id,
          patientId: `P${String(Date.now()).slice(-6)}`, // Generate patient ID
          dateOfBirth: new Date(), // Default date
          address: {},
          emergencyContact: {
            phone: patientPhone
          },
          medicalHistory: {
            allergies: [],
            chronicConditions: [],
            medications: []
          }
        };
        
        patient = await storage.createPatient(patientData);
        console.log("Created new patient:", patient);
      }

      // Get available providers (doctors)
      const providers = await storage.getUsersByRole('doctor', tenant.id);
      if (providers.length === 0) {
        return res.status(400).json({ error: "No doctors available" });
      }
      
      // Use first available doctor
      const provider = providers[0];
      
      // Create appointment
      const scheduledDateTime = new Date(`${preferredDate}T${preferredTime || '09:00'}`);
      
      const appointmentData = {
        patientId: patient.id,
        providerId: provider.id,
        organizationId: tenant.id,
        title: `${appointmentType || 'General consultation'} - ${patientName}`,
        description: notes || `Website booking: ${appointmentType}`,
        scheduledAt: scheduledDateTime,
        duration: 30,
        type: appointmentType === 'emergency' ? 'emergency' : 'consultation',
        status: 'pending',
        location: 'Main Clinic',
        isVirtual: appointmentType === 'virtual' || appointmentType === 'telemedicine'
      };
      
      const appointment = await storage.createAppointment(appointmentData);
      
      // Send confirmation email
      try {
        // TODO: Implement sendAppointmentConfirmation method in EmailService
        console.log("Appointment confirmation would be sent to:", patientEmail);
      } catch (emailError) {
        console.error("Failed to send confirmation email:", emailError);
      }
      
      res.status(201).json({
        success: true,
        message: "Appointment booked successfully",
        appointment: {
          id: appointment.id,
          date: scheduledDateTime.toLocaleDateString(),
          time: scheduledDateTime.toLocaleTimeString(),
          doctor: `Dr. ${provider.firstName} ${provider.lastName}`,
          type: appointmentType,
          status: 'pending'
        }
      });
      
    } catch (error) {
      console.error("Website appointment booking error:", error);
      res.status(500).json({ error: "Failed to book appointment" });
    }
  });

  app.post("/api/website/request-prescription", async (req, res) => {
    try {
      const { patientName, patientEmail, patientPhone, medication, dosage, reason, currentMedications, allergies } = req.body;
      
      console.log("Website prescription request:", req.body);
      
      // For demo purposes, we'll use the default tenant 'cura'
      const tenant = await storage.getOrganizationBySubdomain('cura');
      if (!tenant) {
        return res.status(400).json({ error: "Organization not found" });
      }

      // Check if patient exists by email, if not create a new one
      let patient = await storage.getPatientByEmail(patientEmail, tenant.id);
      
      if (!patient) {
        // Extract first and last name from full name
        const nameParts = patientName.trim().split(' ');
        const firstName = nameParts[0] || patientName;
        const lastName = nameParts.slice(1).join(' ') || '';
        
        // Create new patient
        const patientData = {
          firstName,
          lastName,
          email: patientEmail,
          phone: patientPhone,
          organizationId: tenant.id,
          patientId: `P${String(Date.now()).slice(-6)}`, // Generate patient ID
          dateOfBirth: new Date(), // Default date
          address: {
            street: '',
            city: '',
            state: '',
            postcode: '',
            country: 'UK'
          },
          emergencyContact: {
            name: '',
            relationship: '',
            phone: patientPhone
          },
          medicalHistory: {
            allergies: allergies ? [allergies] : [],
            chronicConditions: [],
            medications: currentMedications ? [currentMedications] : [],
            familyHistory: { father: [], mother: [], siblings: [], grandparents: [] },
            socialHistory: { smoking: { status: 'never' }, alcohol: { status: 'never' }, drugs: { status: 'never' }, occupation: '', maritalStatus: 'single', education: '', exercise: { frequency: 'none' } },
            immunizations: []
          },
          riskLevel: 'low',
          flags: null,
          communicationPreferences: null,
          isActive: true
        };
        
        patient = await storage.createPatient(patientData);
        console.log("Created new patient for prescription:", patient);
      }

      // Get available providers (doctors)
      const providers = await storage.getUsersByRole('doctor', tenant.id);
      if (providers.length === 0) {
        return res.status(400).json({ error: "No doctors available" });
      }
      
      // Use first available doctor
      const provider = providers[0];
      
      // Create prescription request (pending status)
      const prescriptionData = {
        patientId: patient.id,
        doctorId: provider.id,
        organizationId: tenant.id,
        medicationName: medication || 'Medication to be determined',
        dosage: dosage || 'To be determined',
        frequency: 'As prescribed',
        duration: 'As prescribed',
        instructions: `Website prescription request: ${reason}\n\nCurrent medications: ${currentMedications || 'None'}\nAllergies: ${allergies || 'None'}`,
        status: 'pending'
      };
      
      const prescription = await storage.createPrescription(prescriptionData);
      
      // Send confirmation email
      try {
        // TODO: Implement sendPrescriptionRequestConfirmation method in EmailService
        console.log("Prescription confirmation would be sent to:", patientEmail);
      } catch (emailError) {
        console.error("Failed to send prescription confirmation email:", emailError);
      }
      
      res.status(201).json({
        success: true,
        message: "Prescription request submitted successfully",
        prescription: {
          id: prescription.id,
          medication: medication || 'To be determined',
          doctor: `Dr. ${provider.firstName} ${provider.lastName}`,
          status: 'pending',
          requestDate: new Date().toLocaleDateString()
        }
      });
      
    } catch (error) {
      console.error("Website prescription request error:", error);
      res.status(500).json({ error: "Failed to submit prescription request" });
    }
  });

  app.get("/api/website/available-slots", async (req, res) => {
    try {
      const { date } = req.query;
      
      // For demo purposes, return available time slots
      const selectedDate = new Date(date as string);
      const today = new Date();
      
      if (selectedDate < today) {
        return res.status(400).json({ error: "Cannot book appointments in the past" });
      }
      
      // Generate available slots (9 AM to 5 PM, excluding lunch 12-1 PM)
      const slots = [];
      for (let hour = 9; hour < 17; hour++) {
        if (hour !== 12) { // Skip lunch hour
          slots.push(`${hour.toString().padStart(2, '0')}:00`);
          if (hour < 16) { // Don't add 30min slot for 4:30 PM
            slots.push(`${hour.toString().padStart(2, '0')}:30`);
          }
        }
      }
      
      res.json({ availableSlots: slots });
      
    } catch (error) {
      console.error("Error fetching available slots:", error);
      res.status(500).json({ error: "Failed to fetch available slots" });
    }
  });

  // Helper function to load template content from file system
  async function loadTemplateContent(document: any, organizationId: number): Promise<any> {
    if (document.isTemplate && document.content) {
      // Check if content is a filename (new templates) or actual content (legacy templates)
      const isFilename = document.content.endsWith('.json');
      
      if (isFilename) {
        const userId = document.userId;
        const filename = document.content;
        const filePath = path.join(process.cwd(), 'uploads', 'Forms', String(organizationId), String(userId), filename);
        
        if (fs.existsSync(filePath)) {
          try {
            const fileContent = await fs.promises.readFile(filePath, 'utf8');
            const templateData = JSON.parse(fileContent);
            return {
              ...document,
              content: templateData.content,
              metadata: templateData.metadata || document.metadata,
            };
          } catch (error) {
            console.error('Error reading template file:', filePath, error);
          }
        } else {
          console.log('Template file not found, returning DB content:', filePath);
        }
      }
      // For legacy templates with content in DB, return as-is
    }
    return document;
  }

  // Document API routes
  app.get("/api/documents", authMiddleware, multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const isTemplatesOnly = req.query.templates === 'true';
      const isDoctor = req.user.role && ['doctor', 'nurse', 'dentist', 'dental_nurse', 'phlebotomist', 'aesthetician', 'optician', 'paramedic', 'physiotherapist', 'sample_taker'].includes(req.user.role.toLowerCase());
      
      if (isTemplatesOnly) {
        // Fetch only templates - doctors see only their own, others see all
        let templates;
        if (isDoctor) {
          templates = await storage.getDocumentsByUser(req.user.id, req.tenant!.id);
          // Filter to only templates
          templates = templates.filter((t: any) => t.isTemplate);
        } else {
          templates = await storage.getTemplatesByOrganization(req.tenant!.id, 50);
        }
        // Load template content from file system for each template
        const templatesWithContent = await Promise.all(
          templates.map((template: any) => loadTemplateContent(template, req.tenant!.id))
        );
        res.json(templatesWithContent);
      } else {
        // Fetch all documents - doctors see only their own, others see all
        let documents;
        if (isDoctor) {
          documents = await storage.getDocumentsByUser(req.user.id, req.tenant!.id);
        } else {
          documents = await storage.getDocumentsByOrganization(req.tenant!.id, 50);
        }
        // Load template content from file system for templates
        const documentsWithContent = await Promise.all(
          documents.map((doc: any) => loadTemplateContent(doc, req.tenant!.id))
        );
        res.json(documentsWithContent);
      }
    } catch (error) {
      console.error("Error fetching documents:", error);
      res.status(500).json({ error: "Failed to fetch documents" });
    }
  });

  app.get("/api/documents/user", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const documents = await storage.getDocumentsByUser(req.user.id, req.tenant!.id);
      // Load template content from file system for templates
      const documentsWithContent = await Promise.all(
        documents.map((doc: any) => loadTemplateContent(doc, req.tenant!.id))
      );
      res.json(documentsWithContent);
    } catch (error) {
      console.error("Error fetching user documents:", error);
      res.status(500).json({ error: "Failed to fetch user documents" });
    }
  });

  app.post("/api/documents", authMiddleware, multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const documentData = z.object({
        name: z.string().min(1),
        type: z.string().optional().default("medical_form"),
        content: z.string().min(1),
        metadata: z.object({
          subject: z.string().optional(),
          recipient: z.string().optional(),
          location: z.string().optional(),
          practitioner: z.string().optional(),
          header: z.string().optional(),
          templateUsed: z.string().optional(),
        }).optional().default({}),
        isTemplate: z.boolean().optional().default(false),
      }).parse(req.body);

      // For templates, save to file system with organization_id/user_id directory structure
      if (documentData.isTemplate) {
        const organizationId = req.tenant!.id;
        const userId = req.user.id;
        
        // Create directory structure: uploads/Forms/{organization_id}/{user_id}/
        const formsDir = path.join(process.cwd(), 'uploads', 'Forms', String(organizationId), String(userId));
        
        // Create directory if it doesn't exist
        if (!fs.existsSync(formsDir)) {
          fs.mkdirSync(formsDir, { recursive: true });
          console.log('üìÅ Created Forms directory:', formsDir);
        }
        
        // Generate unique filename
        const timestamp = Date.now();
        const sanitizedName = documentData.name.replace(/[^a-z0-9_-]/gi, '_');
        const filename = `${sanitizedName}_${timestamp}.json`;
        const filePath = path.join(formsDir, filename);
        
        // Prepare template data for file system
        const templateFileData = {
          name: documentData.name,
          type: documentData.type,
          content: documentData.content,
          metadata: documentData.metadata,
          createdAt: new Date().toISOString(),
          organizationId,
          userId,
        };
        
        // Save template to file system
        await fs.promises.writeFile(filePath, JSON.stringify(templateFileData, null, 2), 'utf8');
        console.log('‚úÖ Template saved to file system:', filePath);
        
        // Also save metadata to database for querying/listing
        const document = await storage.createDocument({
          ...documentData,
          organizationId: req.tenant!.id,
          userId: req.user.id,
          content: filename, // Store filename instead of content
        });
        
        res.status(201).json({
          ...document,
          filePath: `uploads/Forms/${organizationId}/${userId}/${filename}`,
        });
      } else {
        // For non-templates, save to database as before
        const document = await storage.createDocument({
          ...documentData,
          organizationId: req.tenant!.id,
          userId: req.user.id,
        });
        
        res.status(201).json(document);
      }
    } catch (error) {
      console.error("Error creating document:", error);
      res.status(500).json({ error: "Failed to create document" });
    }
  });

  app.get("/api/documents/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const documentId = parseInt(req.params.id);
      if (isNaN(documentId)) {
        return res.status(400).json({ error: "Invalid document ID" });
      }

      const document = await storage.getDocument(documentId, req.tenant!.id);
      if (!document) {
        return res.status(404).json({ error: "Document not found" });
      }

      // Load template content from file system if it's a template
      const documentWithContent = await loadTemplateContent(document, req.tenant!.id);
      res.json(documentWithContent);
    } catch (error) {
      console.error("Error fetching document:", error);
      res.status(500).json({ error: "Failed to fetch document" });
    }
  });

  app.put("/api/documents/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const documentId = parseInt(req.params.id);
      if (isNaN(documentId)) {
        return res.status(400).json({ error: "Invalid document ID" });
      }

      const updateData = z.object({
        name: z.string().min(1).optional(),
        content: z.string().min(1).optional(),
        metadata: z.object({
          subject: z.string().optional(),
          recipient: z.string().optional(),
          location: z.string().optional(),
          practitioner: z.string().optional(),
          header: z.string().optional(),
          templateUsed: z.string().optional(),
        }).optional(),
      }).parse(req.body);

      const document = await storage.updateDocument(documentId, req.tenant!.id, updateData);
      if (!document) {
        return res.status(404).json({ error: "Document not found" });
      }

      res.json(document);
    } catch (error) {
      console.error("Error updating document:", error);
      res.status(500).json({ error: "Failed to update document" });
    }
  });

  app.delete("/api/documents/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const documentId = parseInt(req.params.id);
      if (isNaN(documentId)) {
        return res.status(400).json({ error: "Invalid document ID" });
      }

      const deleted = await storage.deleteDocument(documentId, req.tenant!.id);
      if (!deleted) {
        return res.status(404).json({ error: "Document not found" });
      }

      res.json({ message: "Document deleted successfully" });
    } catch (error) {
      console.error("Error deleting document:", error);
      res.status(500).json({ error: "Failed to delete document" });
    }
  });

  // Medical Images API endpoints

  app.get("/api/medical-images/patient/:patientId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const patientId = parseInt(req.params.patientId);
      if (isNaN(patientId)) {
        return res.status(400).json({ error: "Invalid patient ID" });
      }
      
      const images = await storage.getMedicalImagesByPatient(patientId, req.tenant!.id);
      res.json(images);
    } catch (error) {
      console.error("Error fetching patient medical images:", error);
      res.status(500).json({ error: "Failed to fetch patient medical images" });
    }
  });

  // Get all medical images for the organization
  app.get("/api/medical-images", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const medicalImages = await storage.getMedicalImagesByOrganization(req.tenant!.id);
      
      // Transform the data to include patient information
      const imagesWithPatients = await Promise.all(
        medicalImages.map(async (image) => {
          const patient = await storage.getPatient(image.patientId, req.tenant!.id);
          const uploader = await storage.getUser(Number(image.uploadedBy), req.tenant!.id);
          
          const result = {
            ...image,
            patientName: patient ? `${patient.firstName} ${patient.lastName}` : "Unknown Patient",
            patientIdentifier: patient?.patientId || "Unknown",
            uploadedByName: uploader ? `${uploader.firstName} ${uploader.lastName}` : "Unknown User"
          };
          
          console.log('üì∑ API: Returning image with fileName:', result.fileName);
          return result;
        })
      );
      
      res.json(imagesWithPatients);
    } catch (error) {
      console.error("Error fetching medical images:", error);
      res.status(500).json({ error: "Failed to fetch medical images" });
    }
  });

  app.post("/api/medical-images", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const imageData = z.object({
        patientId: z.number(),
        imageId: z.string().optional(), // Add imageId field
        imageType: z.string().optional(),
        studyType: z.string().optional(),
        modality: z.string().optional(),
        bodyPart: z.string(),
        indication: z.string().optional(),
        priority: z.string().optional(),
        notes: z.string().optional(),
        filename: z.string(),
        fileUrl: z.string().optional(),
        fileSize: z.number(),
        uploadedBy: z.number(),
        imageData: z.string().optional(), // Add base64 image data field
        mimeType: z.string().optional(), // Add MIME type field
        status: z.string().optional(), // Add status field for orders vs uploads
        orderStudyCreated: z.boolean().optional() // Add order study tracking
      }).parse(req.body);

      // Generate imageId if not provided
      const finalImageId = imageData.imageId || `IMG${Date.now()}I${imageData.patientId}AUTO`;

      // Create proper object for database insertion (with enforced created_by)
      const dbImageData = enforceCreatedBy(req, {
        patientId: imageData.patientId,
        imageId: finalImageId, // Include imageId in database object
        studyType: imageData.studyType || imageData.imageType || "Unknown Study", // Use studyType first, then imageType as fallback
        modality: imageData.modality || "X-Ray", // Use provided modality or default
        bodyPart: imageData.bodyPart,
        indication: imageData.indication || imageData.notes || "",
        priority: imageData.priority || "routine",
        fileName: imageData.filename,
        fileSize: imageData.fileSize,
        mimeType: imageData.mimeType || "image/jpeg", // Use provided MIME type or default
        organizationId: req.tenant!.id,
        imageData: imageData.imageData || null, // Store the base64 image data
        status: imageData.status || "uploaded", // Use provided status or default to uploaded
        orderStudyCreated: imageData.orderStudyCreated || false // Track order study creation
      }, 'uploadedBy');


      const image = await storage.createMedicalImage(dbImageData);

      res.status(201).json(image);
    } catch (error) {
      console.error("Error creating medical image:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to create medical image" });
    }
  });

  // Upload medical images with unique filenames to /uploads/Imaging_Images directory
  app.post("/api/medical-images/upload", authMiddleware, uploadMedicalImages.array('images', 10), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const files = req.files as Express.Multer.File[];
      if (!files || files.length === 0) {
        return res.status(400).json({ error: "No files uploaded" });
      }

      const uploadedImages = [];
      
      // Check if updateImageId is provided to update existing ORDER row
      const updateImageId = req.body.updateImageId;
      console.log('üì∑ UPDATE CHECK: updateImageId received:', updateImageId);

      // Process each uploaded file
      for (const file of files) {
        // Validate form data
        const imageData = z.object({
          patientId: z.coerce.number(),
          imageType: z.string().optional(),
          bodyPart: z.string().optional(),
          notes: z.string().optional(),
          modality: z.string().optional(),
          priority: z.string().optional(),
          studyType: z.string().optional(),
          indication: z.string().optional(),
          updateImageId: z.string().optional()
        }).parse(req.body);

        // Check if we should UPDATE existing ORDER row or CREATE new row
        let savedImage;
        const timestamp = Date.now();
        
        if (updateImageId) {
          // UPDATE existing ORDER row with image data
          console.log('üì∑ UPDATE MODE: Updating existing ORDER row with imageId:', updateImageId);
          
          // Find the existing medical image by imageId
          const allImages = await storage.getMedicalImagesByOrganization(req.tenant!.id);
          const existingImage = allImages.find(img => img.imageId === updateImageId);
          
          if (!existingImage) {
            console.error('üì∑ UPDATE ERROR: ORDER row not found with imageId:', updateImageId);
            throw new Error('ORDER row not found');
          }
          
          // Read file and convert to base64
          const fileBuffer = await fs.promises.readFile(file.path);
          const base64Data = `data:${file.mimetype};base64,${fileBuffer.toString('base64')}`;
          
          // Update the existing row with image data
          await storage.updateMedicalImage(existingImage.id, req.tenant!.id, {
            imageData: base64Data,
            fileSize: file.size,
            mimeType: file.mimetype,
            status: 'uploaded'
          });
          
          // Fetch updated record
          savedImage = await storage.getMedicalImage(existingImage.id, req.tenant!.id);
          console.log('üì∑ UPDATE SUCCESS: Updated ORDER row (ID:', existingImage.id, ') with image data');
          
          // Delete the uploaded file since we stored it in database
          try {
            await fs.promises.unlink(file.path);
          } catch (err) {
            console.error('Error deleting temp file:', err);
          }
        } else {
          // CREATE new row (original behavior)
          const tempImageId = `IMG${timestamp}ITEMPONC`; // Temporary placeholder
          
          const dbImageData = {
            patientId: imageData.patientId,
            organizationId: req.tenant!.id,
            uploadedBy: req.user.id,
            imageId: tempImageId, // Use temporary imageId for insert
            studyType: imageData.studyType || 'Medical Image',
            modality: imageData.modality || 'X-Ray',
            bodyPart: imageData.bodyPart || 'Not specified',
            indication: imageData.indication || imageData.notes || '',
            priority: imageData.priority || 'routine',
            fileName: file.filename, // Use the unique filename generated by multer
            fileSize: file.size,
            mimeType: file.mimetype,
            imageData: null, // Don't store imageData for file-based storage
            status: 'uploaded'
          };

          console.log('üì∑ Saving medical image to database with unique filename:', file.filename);
          console.log('üì∑ dbImageData being inserted:', JSON.stringify(dbImageData, null, 2));

          savedImage = await storage.createMedicalImage(dbImageData);
        }
        
        // Skip file operations if in UPDATE mode (already stored base64 in database)
        if (!updateImageId) {
          // Only do file operations for CREATE mode
          // Now generate the final image_id and filename using the database ID
          const finalImageId = `IMG${timestamp}I${savedImage.id}ONC`;
          const ext = file.originalname.split('.').pop(); // Use original extension
          const finalFileName = `${finalImageId}.${ext}`;
          
          // Move file to organizational path: uploads/Imaging_Images/{organizationId}/patients/{patientId}/
          const organizationId = req.tenant!.id;
          const patientId = imageData.patientId;
          const organizationalDir = path.join('./uploads/Imaging_Images', String(organizationId), 'patients', String(patientId));
          
          // Create organizational directory if it doesn't exist
          await fse.ensureDir(organizationalDir);
          
          const oldPath = path.join('./uploads/Imaging_Images', file.filename);
          const newPath = path.join(organizationalDir, finalFileName);
          
          try {
            await fs.promises.rename(oldPath, newPath);
            console.log(`üì∑ Moved file from ${file.filename} to organizational path: ${newPath}`);
          } catch (renameError) {
            console.error('Error moving file to organizational path:', renameError);
            // If move fails, keep the old filename
          }
          
          // Update database with final image_id and filename
          await storage.updateMedicalImage(savedImage.id, req.tenant!.id, {
            imageId: finalImageId,
            fileName: finalFileName
          });
          
          // Fetch the updated record to return
          savedImage = await storage.getMedicalImage(savedImage.id, req.tenant!.id);
        }
        
        uploadedImages.push({
          ...savedImage,
          originalName: file.originalname,
          uniqueFilename: savedImage.fileName
        });
      }

      res.status(201).json({
        message: 'Images uploaded successfully',
        images: uploadedImages
      });
    } catch (error) {
      console.error("Error uploading medical images:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to upload medical images" });
    }
  });

  app.delete("/api/medical-images/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const imageId = parseInt(req.params.id);
      if (isNaN(imageId)) {
        return res.status(400).json({ error: "Invalid image ID" });
      }

      // First, get the medical image record to retrieve file names
      const medicalImage = await storage.getMedicalImage(imageId, req.tenant!.id);
      if (!medicalImage) {
        return res.status(404).json({ error: "Medical image not found" });
      }

      // Delete image file from server filesystem if it exists
      if (medicalImage.fileName) {
        const imagePath = path.join('./uploads/Imaging_Images', medicalImage.fileName);
        try {
          await fs.promises.unlink(imagePath);
          console.log(`Deleted image file: ${imagePath}`);
        } catch (fileError: any) {
          if (fileError.code !== 'ENOENT') {
            console.error(`Error deleting image file ${imagePath}:`, fileError);
          }
        }
      }

      // Delete PDF report file from server filesystem if it exists
      if (medicalImage.reportFileName) {
        const pdfPath = path.join('./uploads/Imaging_Images', medicalImage.reportFileName);
        try {
          await fs.promises.unlink(pdfPath);
          console.log(`Deleted PDF file: ${pdfPath}`);
        } catch (fileError: any) {
          if (fileError.code !== 'ENOENT') {
            console.error(`Error deleting PDF file ${pdfPath}:`, fileError);
          }
        }
      }

      // Delete the record from the medical_images table
      const success = await storage.deleteMedicalImage(imageId, req.tenant!.id);
      if (!success) {
        return res.status(404).json({ error: "Failed to delete medical image record" });
      }

      res.json({ 
        success: true,
        message: "Medical image and associated files deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting medical image:", error);
      res.status(500).json({ error: "Failed to delete medical image" });
    }
  });

  app.patch("/api/medical-images/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const imageId = parseInt(req.params.id);
      if (isNaN(imageId)) {
        return res.status(400).json({ error: "Invalid image ID" });
      }

      // Validate update data - allow updating scheduledAt, performedAt, status, priority, imageId, orderStudyGenerated, and signatureData
      const validatedData = z.object({
        scheduledAt: z.string().optional(),
        performedAt: z.string().optional(),
        status: z.string().optional(),
        priority: z.string().optional(),
        imageId: z.string().optional(),
        orderStudyGenerated: z.boolean().optional(),
        signatureData: z.string().optional(),
      }).parse(req.body);

      // Convert ISO string dates to Date objects for database storage and handle other fields
      const updateData: any = {};
      if (validatedData.scheduledAt) {
        updateData.scheduledAt = new Date(validatedData.scheduledAt);
      }
      if (validatedData.performedAt) {
        updateData.performedAt = new Date(validatedData.performedAt);
      }
      if (validatedData.status) {
        updateData.status = validatedData.status;
      }
      if (validatedData.priority) {
        updateData.priority = validatedData.priority;
      }
      if (validatedData.imageId) {
        updateData.imageId = validatedData.imageId;
      }
      if (validatedData.orderStudyGenerated !== undefined) {
        updateData.orderStudyGenerated = validatedData.orderStudyGenerated;
      }
      if (validatedData.signatureData) {
        console.log("‚úÖ SIGNATURE UPDATE: Saving signature for image ID:", imageId);
        console.log("‚úÖ SIGNATURE UPDATE: Signature data length:", validatedData.signatureData.length);
        updateData.signatureData = validatedData.signatureData;
        updateData.signatureDate = new Date(); // Capture timestamp when signature is applied
      }

      const success = await storage.updateMedicalImage(imageId, req.tenant!.id, updateData);
      
      if (success && validatedData.signatureData) {
        console.log("‚úÖ SIGNATURE UPDATE: Signature saved successfully!");
      }
      
      if (!success) {
        return res.status(404).json({ error: "Medical image not found" });
      }

      res.json({ success: true });
    } catch (error) {
      console.error("Error updating medical image:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to update medical image" });
    }
  });

  // Replace medical image file  
  app.put("/api/medical-images/:id/replace", authMiddleware, uploadReplaceImages.single('file'), async (req: TenantRequest, res) => {
    try {
      const imageId = parseInt(req.params.id);
      if (isNaN(imageId)) {
        return res.status(400).json({ error: "Invalid image ID" });
      }

      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      if (!req.file) {
        return res.status(400).json({ error: "No file uploaded" });
      }

      // Get the existing medical image from database first to get patient ID
      const existingImage = await storage.getMedicalImage(imageId, req.tenant!.id);
      if (!existingImage) {
        return res.status(404).json({ error: "Medical image not found" });
      }

      // Get patient info for file naming
      const patient = await storage.getPatient(existingImage.patientId, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      const organizationId = req.tenant!.id;
      const patientId = existingImage.patientId;

      console.log('üîÑ SERVER: Replace request for existing image:', {
        imageId,
        existingFileName: existingImage.fileName,
        tempFileName: req.file.filename,
        patientId: patient.id,
        patientStringId: patient.patientId,
        organizationId
      });

      // Keep the same filename as the existing image
      const keepFilename = existingImage.fileName;
      
      // Create organizational directory structure: uploads/Imaging_Images/{organizationId}/patients/{patientId}/
      const imagingImagesDir = path.resolve(process.cwd(), 'uploads', 'Imaging_Images', String(organizationId), 'patients', String(patientId));
      await fse.ensureDir(imagingImagesDir);
      
      const tempUploadDir = path.resolve(process.cwd(), 'uploads', 'Imaging_Images');
      const tempFilePath = path.join(tempUploadDir, req.file.filename);
      const finalFilePath = path.join(imagingImagesDir, keepFilename);

      // Delete old file from filesystem if it exists (check both old and new locations)
      if (existingImage.fileName) {
        try {
          // Try new organizational path first
          const newOldFilePath = path.join(imagingImagesDir, existingImage.fileName);
          if (await fse.pathExists(newOldFilePath)) {
            await fse.remove(newOldFilePath);
            console.log('üì∑ SERVER: Deleted old image file from new path:', existingImage.fileName);
          } else {
            // Try old flat path for backward compatibility
            const oldFlatPath = path.join(tempUploadDir, existingImage.fileName);
            if (await fse.pathExists(oldFlatPath)) {
              await fse.remove(oldFlatPath);
              console.log('üì∑ SERVER: Deleted old image file from legacy flat path:', existingImage.fileName);
            }
          }
        } catch (deleteError) {
          console.error('üì∑ SERVER: Error deleting old image file:', deleteError);
          // Continue with replacement even if old file deletion fails
        }
      }

      // Rename temp file to keep the same filename
      try {
        await fse.move(tempFilePath, finalFilePath);
        console.log('üîÑ SERVER: Replaced image file keeping same filename:', {
          tempFile: req.file.filename,
          keptFilename: keepFilename,
          finalPath: finalFilePath
        });
      } catch (renameError) {
        console.error('üîÑ SERVER: Error renaming temp file:', renameError);
        return res.status(500).json({ error: "Failed to rename uploaded file" });
      }

      // Update database record with new file information (keeping the same fileName)
      const relativeFilePath = `/uploads/Imaging_Images/${organizationId}/patients/${patientId}/${keepFilename}`;
      const updateData = {
        fileName: keepFilename, // Keep the same filename
        fileUrl: relativeFilePath,
        fileSize: req.file.size,
        mimeType: req.file.mimetype,
        uploadedBy: req.user.id,
        // Keep other existing fields unchanged
        imageData: null // Clear any base64 data since we're using filesystem storage
      };

      const success = await storage.updateMedicalImage(imageId, req.tenant!.id, updateData);
      
      if (!success) {
        return res.status(500).json({ error: "Failed to update medical image record" });
      }

      console.log('üì∑ SERVER: Successfully replaced image file:', keepFilename);

      // Return the updated image information
      const updatedImage = await storage.getMedicalImage(imageId, req.tenant!.id);
      res.json({ 
        success: true, 
        image: updatedImage,
        originalName: req.file.originalname,
        keptFilename: keepFilename,
        filePath: relativeFilePath
      });

    } catch (error) {
      console.error("Error replacing medical image:", error);
      res.status(500).json({ error: "Failed to replace medical image" });
    }
  });

  // Get medical image file
  app.get("/api/medical-images/:id/image", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const imageId = parseInt(req.params.id);
      if (isNaN(imageId)) {
        return res.status(400).json({ error: "Invalid image ID" });
      }

      // Get the medical image from the database
      const medicalImage = await storage.getMedicalImage(imageId, req.tenant!.id);
      if (!medicalImage) {
        return res.status(404).json({ error: "Medical image not found" });
      }

      // Get fileName from database
      const fileName = medicalImage.fileName;
      if (!fileName || fileName.trim() === '') {
        return res.status(404).json({ error: "Image file name not available" });
      }

      // FIRST PRIORITY: Check if the image has base64 data in database
      if (medicalImage.imageData) {
        console.log("üì∑ SERVER: Serving image from database base64 data (FIRST PRIORITY)");
        
        // Extract base64 data (remove data:image/xxx;base64, prefix if present)
        const base64Data = medicalImage.imageData.includes(',') 
          ? medicalImage.imageData.split(',')[1] 
          : medicalImage.imageData;
        
        // Set appropriate headers
        const mimeType = medicalImage.mimeType || 'image/jpeg';
        res.setHeader('Content-Type', mimeType);
        res.setHeader('Content-Disposition', `inline; filename="${fileName}"`);
        res.setHeader('Cache-Control', 'public, max-age=31536000'); // Cache for 1 year
        
        // Convert base64 to buffer and send
        const imageBuffer = Buffer.from(base64Data, 'base64');
        res.send(imageBuffer);
        return;
      }

      // No image data available
      return res.status(404).json({ error: "Image data not available" });
    } catch (error) {
      console.error("Error serving medical image:", error);
      res.status(500).json({ error: "Failed to serve medical image" });
    }
  });

  // Lab Results API endpoints (Database-driven) - LEGACY ROUTES COMMENTED OUT
  // These duplicate routes were causing permission issues - the correct routes are defined earlier (around line 6177-6248)
  /*
  app.get("/api/lab-results", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const results = await storage.getLabResultsByOrganization(req.tenant!.id);
      res.json(results);
    } catch (error) {
      console.error("Error fetching lab results:", error);
      res.status(500).json({ error: "Failed to fetch lab results" });
    }
  });

  app.post("/api/lab-results", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const labResultData = z.object({
        patientId: z.number(),
        testName: z.string(),
        category: z.string(),
        value: z.string(),
        unit: z.string().optional(),
        referenceRange: z.string().optional(),
        status: z.enum(["pending", "completed", "reviewed"]).default("completed"),
        orderedBy: z.number(),
        notes: z.string().optional()
      }).parse(req.body);

      const result = await storage.createLabResult({
        ...labResultData,
        organizationId: req.tenant!.id,
        testId: `LAB-${Date.now()}`, // Add required testId
        testType: labResultData.category, // Add required testType
        orderedAt: new Date() // Add required orderedAt
      });

      res.status(201).json(result);
    } catch (error) {
      console.error("Error creating lab result:", error);
      res.status(500).json({ error: "Failed to create lab result" });
    }
  });
  */

  // Claims API endpoints (Database-driven)
  app.get("/api/claims", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const claims = await storage.getClaimsByOrganization(req.tenant!.id);
      res.json(claims);
    } catch (error) {
      console.error("Error fetching claims:", error);
      res.status(500).json({ error: "Failed to fetch claims" });
    }
  });

  app.post("/api/claims", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const claimData = z.object({
        patientId: z.number(),
        claimNumber: z.string(),
        insuranceProvider: z.string(),
        amount: z.number(),
        status: z.enum(["submitted", "pending", "approved", "denied", "paid"]).default("submitted"),
        submissionDate: z.string().optional(),
        description: z.string().optional()
      }).parse(req.body);

      const claim = await storage.createClaim({
        ...claimData,
        amount: claimData.amount.toString(), // Convert to string
        organizationId: req.tenant!.id,
        serviceDate: new Date(), // Add required serviceDate
        submissionDate: claimData.submissionDate ? new Date(claimData.submissionDate) : new Date() // Convert to Date
      });

      res.status(201).json(claim);
    } catch (error) {
      console.error("Error creating claim:", error);
      res.status(500).json({ error: "Failed to create claim" });
    }
  });

  // Revenue Records API endpoints (Database-driven)
  app.get("/api/revenue-records", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const records = await storage.getRevenueRecordsByOrganization(req.tenant!.id);
      res.json(records);
    } catch (error) {
      console.error("Error fetching revenue records:", error);
      res.status(500).json({ error: "Failed to fetch revenue records" });
    }
  });

  app.post("/api/revenue-records", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const revenueData = z.object({
        source: z.string(),
        amount: z.number(),
        category: z.string(),
        description: z.string().optional(),
        date: z.string().optional()
      }).parse(req.body);

      const record = await storage.createRevenueRecord({
        organizationId: req.tenant!.id,
        month: revenueData.date ? new Date(revenueData.date).toISOString().slice(0, 7) : new Date().toISOString().slice(0, 7), // YYYY-MM format
        revenue: revenueData.amount.toString(),
        expenses: "0",
        profit: revenueData.amount.toString(),
        collections: revenueData.amount.toString(),
        target: "0"
      });

      res.status(201).json(record);
    } catch (error) {
      console.error("Error creating revenue record:", error);
      res.status(500).json({ error: "Failed to create revenue record" });
    }
  });

  // Clinical Procedures API endpoints (Database-driven)
  app.get("/api/clinical-procedures", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const procedures = await storage.getClinicalProceduresByOrganization(req.tenant!.id);
      res.json(procedures);
    } catch (error) {
      console.error("Error fetching clinical procedures:", error);
      res.status(500).json({ error: "Failed to fetch clinical procedures" });
    }
  });

  app.post("/api/clinical-procedures", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const procedureData = z.object({
        name: z.string(),
        category: z.string(),
        description: z.string(),
        duration: z.number().optional(),
        requirements: z.string().optional(),
        riskLevel: z.enum(["low", "medium", "high"]).default("medium"),
        cost: z.number().optional()
      }).parse(req.body);

      const procedure = await storage.createClinicalProcedure({
        ...procedureData,
        organizationId: req.tenant!.id,
        complexity: procedureData.riskLevel, // Add required complexity field
        duration: procedureData.duration?.toString() || "30" // Convert to string
      });

      res.status(201).json(procedure);
    } catch (error) {
      console.error("Error creating clinical procedure:", error);
      res.status(500).json({ error: "Failed to create clinical procedure" });
    }
  });

  // Emergency Protocols API endpoints (Database-driven)
  app.get("/api/emergency-protocols", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const protocols = await storage.getEmergencyProtocolsByOrganization(req.tenant!.id);
      res.json(protocols);
    } catch (error) {
      console.error("Error fetching emergency protocols:", error);
      res.status(500).json({ error: "Failed to fetch emergency protocols" });
    }
  });

  app.post("/api/emergency-protocols", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const protocolData = z.object({
        title: z.string(),
        category: z.string(),
        description: z.string(),
        steps: z.string(),
        priority: z.enum(["low", "medium", "high", "critical"]).default("medium"),
        requiredPersonnel: z.string().optional(),
        equipment: z.string().optional()
      }).parse(req.body);

      const protocol = await storage.createEmergencyProtocol({
        ...protocolData,
        organizationId: req.tenant!.id,
        priority: protocolData.priority,
        steps: protocolData.steps.split('\n').filter(step => step.trim()) // Convert string to array
      });

      res.status(201).json(protocol);
    } catch (error) {
      console.error("Error creating emergency protocol:", error);
      res.status(500).json({ error: "Failed to create emergency protocol" });
    }
  });

  // Medications Database API endpoints (Database-driven)
  app.get("/api/medications-database", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const medications = await storage.getMedicationsByOrganization(req.tenant!.id);
      res.json(medications);
    } catch (error) {
      console.error("Error fetching medications:", error);
      res.status(500).json({ error: "Failed to fetch medications" });
    }
  });

  app.post("/api/medications-database", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const medicationData = z.object({
        name: z.string(),
        genericName: z.string().optional(),
        category: z.string(),
        dosageForm: z.string(),
        strength: z.string(),
        manufacturer: z.string().optional(),
        description: z.string().optional(),
        sideEffects: z.string().optional(),
        contraindications: z.string().optional(),
        interactions: z.string().optional()
      }).parse(req.body);

      const medication = await storage.createMedication({
        ...medicationData,
        organizationId: req.tenant!.id,
        severity: "medium", // Add required severity field
        dosage: medicationData.strength, // Use strength as dosage
        interactions: medicationData.interactions ? [medicationData.interactions] : null // Convert string to array
      });

      res.status(201).json(medication);
    } catch (error) {
      console.error("Error creating medication:", error);
      res.status(500).json({ error: "Failed to create medication" });
    }
  });

  // BigBlueButton Video Conference Integration
  app.post("/api/video-conference/create", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const meetingData = z.object({
        meetingName: z.string(),
        participantName: z.string(),
        moderatorPassword: z.string().optional(),
        attendeePassword: z.string().optional(),
        duration: z.number().optional().default(60), // duration in minutes
        maxParticipants: z.number().optional().default(10)
      }).parse(req.body);
      const BBB_URL = "https://vid2.averox.com/bigbluebutton/";
      const BBB_SECRET = "W8tt2cQCSIy43cGwrGDfeKMEdQn1Bfm9l3aygXn8XA";

      // Generate meeting ID and passwords
      const meetingID = `cura-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const moderatorPW = meetingData.moderatorPassword || `mod-${Math.random().toString(36).substr(2, 8)}`;
      const attendeePW = meetingData.attendeePassword || `att-${Math.random().toString(36).substr(2, 8)}`;

      // Create meeting parameters
      const createParams = new URLSearchParams({
        name: meetingData.meetingName,
        meetingID: meetingID,
        moderatorPW: moderatorPW,
        attendeePW: attendeePW,
        duration: meetingData.duration.toString(),
        maxParticipants: meetingData.maxParticipants.toString(),
        record: 'false',
        autoStartRecording: 'false',
        allowStartStopRecording: 'false',
        webcamsOnlyForModerator: 'false',
        logo: '',
        bannerText: `Cura Video Consultation - ${meetingData.meetingName}`,
        bannerColor: '#4F46E5',
        copyright: 'Powered by Cura EMR',
        muteOnStart: 'false',
        guestPolicy: 'ALWAYS_ACCEPT'
      });

      // Generate checksum for create API call
      const createQuery = `create${createParams.toString()}${BBB_SECRET}`;
      const createChecksum = crypto.createHash('sha1').update(createQuery).digest('hex');
      
      // Create the meeting
      const createUrl = `${BBB_URL}api/create?${createParams.toString()}&checksum=${createChecksum}`;
      
      const createResponse = await fetch(createUrl, { method: 'GET' });
      const createXML = await createResponse.text();

      // Parse XML response to check if meeting was created successfully
      const isSuccess = createXML.includes('<returncode>SUCCESS</returncode>');
      
      if (!isSuccess) {
        throw new Error('Failed to create BigBlueButton meeting');
      }

      // Generate join URLs for moderator and attendee
      const moderatorJoinParams = new URLSearchParams({
        fullName: `${meetingData.participantName} (Moderator)`,
        meetingID: meetingID,
        password: moderatorPW,
        redirect: 'true',
        clientURL: `${BBB_URL}html5client/join`
      });

      const attendeeJoinParams = new URLSearchParams({
        fullName: meetingData.participantName,
        meetingID: meetingID,
        password: attendeePW,
        redirect: 'true',
        clientURL: `${BBB_URL}html5client/join`
      });

      const moderatorJoinQuery = `join${moderatorJoinParams.toString()}${BBB_SECRET}`;
      const moderatorJoinChecksum = crypto.createHash('sha1').update(moderatorJoinQuery).digest('hex');
      const moderatorJoinUrl = `${BBB_URL}api/join?${moderatorJoinParams.toString()}&checksum=${moderatorJoinChecksum}`;

      const attendeeJoinQuery = `join${attendeeJoinParams.toString()}${BBB_SECRET}`;
      const attendeeJoinChecksum = crypto.createHash('sha1').update(attendeeJoinQuery).digest('hex');
      const attendeeJoinUrl = `${BBB_URL}api/join?${attendeeJoinParams.toString()}&checksum=${attendeeJoinChecksum}`;

      res.json({
        success: true,
        meetingID: meetingID,
        meetingName: meetingData.meetingName,
        moderatorJoinUrl: moderatorJoinUrl,
        attendeeJoinUrl: attendeeJoinUrl,
        moderatorPassword: moderatorPW,
        attendeePassword: attendeePW,
        duration: meetingData.duration,
        maxParticipants: meetingData.maxParticipants
      });

    } catch (error) {
      console.error("Error creating BigBlueButton meeting:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to create video conference" });
    }
  });

  // End meeting endpoint
  app.post("/api/video-conference/end/:meetingID", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { meetingID } = req.params;
      const { moderatorPassword } = req.body;
      const BBB_URL = "https://vid2.averox.com/bigbluebutton/";
      const BBB_SECRET = "W8tt2cQCSIy43cGwrGDfeKMEdQn1Bfm9l3aygXn8XA";

      const endParams = new URLSearchParams({
        meetingID: meetingID,
        password: moderatorPassword
      });

      const endQuery = `end${endParams.toString()}${BBB_SECRET}`;
      const endChecksum = crypto.createHash('sha1').update(endQuery).digest('hex');
      const endUrl = `${BBB_URL}api/end?${endParams.toString()}&checksum=${endChecksum}`;

      const endResponse = await fetch(endUrl, { method: 'GET' });
      const endXML = await endResponse.text();

      const isSuccess = endXML.includes('<returncode>SUCCESS</returncode>');

      res.json({
        success: isSuccess,
        message: isSuccess ? 'Meeting ended successfully' : 'Failed to end meeting'
      });

    } catch (error) {
      console.error("Error ending BigBlueButton meeting:", error);
      res.status(500).json({ error: "Failed to end video conference" });
    }
  });

  // Telemedicine API endpoints
  app.get("/api/telemedicine/consultations", authMiddleware, async (req: TenantRequest, res) => {
    try {
      // Mock consultation data for now - in production this would come from database
      const consultations = [
        {
          id: "1",
          patientId: "1",
          patientName: "Sarah Johnson",
          providerId: "1", 
          providerName: "Dr. Smith",
          type: "video",
          status: "completed",
          scheduledTime: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(), // 2 hours ago
          duration: 30,
          notes: "Follow-up consultation for hypertension management. Patient reports improved blood pressure readings.",
          vitalSigns: {
            heartRate: 72,
            bloodPressure: "128/82",
            temperature: 98.6,
            oxygenSaturation: 98
          },
          prescriptions: [
            {
              medication: "Lisinopril",
              dosage: "10mg",
              instructions: "Take once daily in the morning"
            }
          ]
        },
        {
          id: "2", 
          patientId: "2",
          patientName: "Michael Chen",
          providerId: "1",
          providerName: "Dr. Smith", 
          type: "video",
          status: "scheduled",
          scheduledTime: new Date(Date.now() + 30 * 60 * 1000).toISOString(), // 30 minutes from now
          duration: 15,
          notes: "Diabetes follow-up and medication review",
          vitalSigns: {
            heartRate: 78,
            bloodPressure: "135/85", 
            temperature: 98.6,
            oxygenSaturation: 97
          }
        }
      ];
      
      res.json(consultations);
    } catch (error) {
      console.error("Error fetching consultations:", error);
      res.status(500).json({ error: "Failed to fetch consultations" });
    }
  });

  app.get("/api/telemedicine/waiting-room", authMiddleware, async (req: TenantRequest, res) => {
    try {
      // Mock waiting room data
      const waitingRoom = [
        {
          patientId: "1",
          patientName: "Sarah Johnson", 
          appointmentTime: new Date(Date.now() - 5 * 60 * 1000).toISOString(), // 5 minutes ago
          waitTime: 5,
          priority: "normal"
        },
        {
          patientId: "3",
          patientName: "Emma Davis",
          appointmentTime: new Date(Date.now() - 15 * 60 * 1000).toISOString(), // 15 minutes ago  
          waitTime: 15,
          priority: "urgent"
        }
      ];
      
      res.json(waitingRoom);
    } catch (error) {
      console.error("Error fetching waiting room:", error);
      res.status(500).json({ error: "Failed to fetch waiting room data" });
    }
  });

  app.post("/api/telemedicine/consultations/:id/start", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { id } = req.params;
      
      // In production, this would update the consultation status in database
      res.json({
        success: true,
        message: "Consultation started successfully",
        consultationId: id,
        meetingUrl: `https://vid2.averox.com/join/${id}`
      });
    } catch (error) {
      console.error("Error starting consultation:", error);
      res.status(500).json({ error: "Failed to start consultation" });
    }
  });

  app.post("/api/telemedicine/consultations/:id/end", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { id } = req.params;
      const { notes, duration } = req.body;
      
      // In production, this would update the consultation in database
      res.json({
        success: true,
        message: "Consultation ended successfully",
        consultationId: id,
        duration: duration || 30,
        notes: notes || "Consultation completed"
      });
    } catch (error) {
      console.error("Error ending consultation:", error);
      res.status(500).json({ error: "Failed to end consultation" });
    }
  });

  app.post("/api/telemedicine/consultations", authMiddleware, requireModulePermission('telemedicine', 'create'), async (req: TenantRequest, res) => {
    try {
      const { patientId, scheduledTime, notes } = req.body;
      
      // In production, this would create a new consultation in database
      const newConsultation = {
        id: Date.now().toString(),
        patientId,
        patientName: "Patient", // Would be fetched from database
        providerId: req.user!.id,
        providerName: `${(req.user as any).firstName || ''} ${(req.user as any).lastName || ''}`,
        type: "video",
        status: "scheduled", 
        scheduledTime,
        notes: notes || "",
        organizationId: req.tenant!.id
      };
      
      res.status(201).json(newConsultation);
    } catch (error) {
      console.error("Error creating consultation:", error);
      res.status(500).json({ error: "Failed to create consultation" });
    }
  });

  // Get telemedicine users with role-based filtering
  app.get("/api/telemedicine/users", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userRole = req.user!.role;
      const organizationId = req.tenant!.id;
      
      // Fetch all users from the organization
      const allUsers = await storage.getUsersByOrganization(organizationId);
      
      // If admin, return all users
      if (userRole === 'admin') {
        res.json(allUsers);
      } else {
        // For non-admin users, filter out patients
        const nonPatientUsers = allUsers.filter(u => u.role !== 'patient');
        res.json(nonPatientUsers);
      }
    } catch (error) {
      console.error("Error fetching telemedicine users:", error);
      res.status(500).json({ error: "Failed to fetch telemedicine users" });
    }
  });

  // Email Service API endpoints
  app.post("/api/email/appointment-reminder", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const emailData = z.object({
        patientEmail: z.string().email(),
        patientName: z.string(),
        doctorName: z.string(),
        appointmentDate: z.string(),
        appointmentTime: z.string()
      }).parse(req.body);

      const success = await emailService.sendAppointmentReminder(
        emailData.patientEmail,
        emailData.patientName,
        emailData.doctorName,
        emailData.appointmentDate,
        emailData.appointmentTime
      );

      if (success) {
        res.json({ success: true, message: "Appointment reminder sent successfully" });
      } else {
        res.status(500).json({ error: "Failed to send appointment reminder" });
      }
    } catch (error) {
      console.error("Error sending appointment reminder:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to send appointment reminder" });
    }
  });

  app.post("/api/email/prescription-notification", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const emailData = z.object({
        patientEmail: z.string().email(),
        patientName: z.string(),
        medicationName: z.string(),
        dosage: z.string(),
        instructions: z.string()
      }).parse(req.body);

      const success = await emailService.sendPrescriptionNotification(
        emailData.patientEmail,
        emailData.patientName,
        emailData.medicationName,
        emailData.dosage,
        emailData.instructions
      );

      if (success) {
        res.json({ success: true, message: "Prescription notification sent successfully" });
      } else {
        res.status(500).json({ error: "Failed to send prescription notification" });
      }
    } catch (error) {
      console.error("Error sending prescription notification:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to send prescription notification" });
    }
  });

  app.post("/api/email/test-results", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const emailData = z.object({
        patientEmail: z.string().email(),
        patientName: z.string(),
        testName: z.string(),
        status: z.string()
      }).parse(req.body);

      const success = await emailService.sendTestResultsNotification(
        emailData.patientEmail,
        emailData.patientName,
        emailData.testName,
        emailData.status
      );

      if (success) {
        res.json({ success: true, message: "Test results notification sent successfully" });
      } else {
        res.status(500).json({ error: "Failed to send test results notification" });
      }
    } catch (error) {
      console.error("Error sending test results notification:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to send test results notification" });
    }
  });

  app.post("/api/email/custom", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const emailData = z.object({
        to: z.string().email(),
        subject: z.string(),
        text: z.string().optional(),
        html: z.string().optional()
      }).parse(req.body);

      const success = await emailService.sendEmail(emailData);

      if (success) {
        res.json({ success: true, message: "Email sent successfully" });
      } else {
        res.status(500).json({ error: "Failed to send email" });
      }
    } catch (error) {
      console.error("Error sending custom email:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to send email" });
    }
  });

  // Send Letter with PDF attachment
  app.post("/api/email/send-letter", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const emailData = z.object({
        to: z.string().email(),
        subject: z.string(),
        documentContent: z.string(),
        doctorEmail: z.union([z.string().email(), z.literal("")]).optional(),
        location: z.string().optional(),
        copiedRecipients: z.string().optional(),
        header: z.string().optional(),
      }).parse(req.body);

      // Send email with HTML content directly
      const success = await emailService.sendEmail({
        to: emailData.to,
        subject: emailData.subject,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #2563eb; border-bottom: 2px solid #2563eb; padding-bottom: 10px;">
              Medical Document
            </h2>
            <div style="margin: 20px 0; padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px;">
              ${emailData.documentContent}
            </div>
            <p style="color: #666; font-size: 12px; margin-top: 30px; border-top: 1px solid #e5e7eb; padding-top: 15px;">
              This document was generated from your healthcare provider's system.<br>
              This is an automated message. Please do not reply to this email.
            </p>
          </div>
        `
      });

      if (success) {
        res.json({ success: true, message: "Letter sent successfully" });
      } else {
        // Email sending failed, save as draft
        console.log("Email sending failed, saving as draft...");
        try {
          const draft = await storage.createLetterDraft({
            subject: emailData.subject,
            recipient: emailData.to,
            doctorEmail: emailData.doctorEmail,
            location: emailData.location,
            copiedRecipients: emailData.copiedRecipients,
            header: emailData.header,
            documentContent: emailData.documentContent,
            organizationId: req.tenant!.id,
            userId: req.user!.id,
          });
          
          res.json({ 
            success: false, 
            savedAsDraft: true, 
            draftId: draft.id,
            message: "Email delivery failed but letter saved as draft. You can retry sending from your drafts." 
          });
        } catch (draftError) {
          console.error("Error saving draft:", draftError);
          res.status(500).json({ error: "Failed to send letter and unable to save draft" });
        }
      }
    } catch (error) {
      console.error("Error sending letter:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }

      // Try to save as draft even if there's an error
      try {
        const emailData = req.body;
        if (emailData.to && emailData.subject && emailData.documentContent) {
          const draft = await storage.createLetterDraft({
            subject: emailData.subject,
            recipient: emailData.to,
            doctorEmail: emailData.doctorEmail,
            location: emailData.location,
            copiedRecipients: emailData.copiedRecipients,
            header: emailData.header,
            documentContent: emailData.documentContent,
            organizationId: req.tenant!.id,
            userId: req.user!.id,
          });
          
          res.status(500).json({ 
            error: "Failed to send letter", 
            savedAsDraft: true, 
            draftId: draft.id,
            message: "Error occurred but letter saved as draft. You can retry sending from your drafts."
          });
        } else {
          res.status(500).json({ error: "Failed to send letter" });
        }
      } catch (draftError) {
        console.error("Error saving draft after failure:", draftError);
        res.status(500).json({ error: "Failed to send letter" });
      }
    }
  });

  // Letter Drafts endpoints
  app.get("/api/letter-drafts", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const drafts = await storage.getLetterDraftsByUser(req.user!.id, req.tenant!.id);
      res.json(drafts);
    } catch (error) {
      console.error("Error getting letter drafts:", error);
      res.status(500).json({ error: "Failed to get letter drafts" });
    }
  });

  app.post("/api/letter-drafts", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const draftData = z.object({
        subject: z.string(),
        recipient: z.string(),
        doctorEmail: z.string().optional(),
        location: z.string().optional(),
        copiedRecipients: z.string().optional(),
        header: z.string().optional(),
        documentContent: z.string(),
      }).parse(req.body);

      const draft = await storage.createLetterDraft({
        ...draftData,
        organizationId: req.tenant!.id,
        userId: req.user!.id,
      });

      res.json(draft);
    } catch (error) {
      console.error("Error creating letter draft:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to create letter draft" });
    }
  });

  app.get("/api/letter-drafts/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const id = parseInt(req.params.id);
      const draft = await storage.getLetterDraft(id, req.tenant!.id);
      
      if (!draft) {
        return res.status(404).json({ error: "Draft not found" });
      }

      // Check if the user owns the draft
      if (draft.userId !== req.user!.id) {
        return res.status(403).json({ error: "Access denied" });
      }

      res.json(draft);
    } catch (error) {
      console.error("Error getting letter draft:", error);
      res.status(500).json({ error: "Failed to get letter draft" });
    }
  });

  app.put("/api/letter-drafts/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = z.object({
        subject: z.string().optional(),
        recipient: z.string().optional(),
        doctorEmail: z.string().optional(),
        location: z.string().optional(),
        copiedRecipients: z.string().optional(),
        header: z.string().optional(),
        documentContent: z.string().optional(),
      }).parse(req.body);

      // Check if the draft exists and user owns it
      const existingDraft = await storage.getLetterDraft(id, req.tenant!.id);
      if (!existingDraft) {
        return res.status(404).json({ error: "Draft not found" });
      }
      if (existingDraft.userId !== req.user!.id) {
        return res.status(403).json({ error: "Access denied" });
      }

      const updatedDraft = await storage.updateLetterDraft(id, req.tenant!.id, updateData);
      res.json(updatedDraft);
    } catch (error) {
      console.error("Error updating letter draft:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to update letter draft" });
    }
  });

  app.delete("/api/letter-drafts/:id", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const id = parseInt(req.params.id);
      
      // Check if the draft exists and user owns it
      const existingDraft = await storage.getLetterDraft(id, req.tenant!.id);
      if (!existingDraft) {
        return res.status(404).json({ error: "Draft not found" });
      }
      if (existingDraft.userId !== req.user!.id) {
        return res.status(403).json({ error: "Access denied" });
      }

      const deleted = await storage.deleteLetterDraft(id, req.tenant!.id);
      if (deleted) {
        res.json({ success: true, message: "Draft deleted successfully" });
      } else {
        res.status(500).json({ error: "Failed to delete draft" });
      }
    } catch (error) {
      console.error("Error deleting letter draft:", error);
      res.status(500).json({ error: "Failed to delete letter draft" });
    }
  });

  // Financial Forecasting endpoints
  app.get("/api/financial-forecasting", authMiddleware, requireRole(["admin", "doctor","nurse","patient"]), async (req: TenantRequest, res) => {
    try {
      const forecasts = await storage.getFinancialForecasts(req.tenant!.id);
      res.json(forecasts);
    } catch (error) {
      console.error("Error getting financial forecasts:", error);
      res.status(500).json({ error: "Failed to get financial forecasts" });
    }
  });

  app.get("/api/financial-forecasting/:id", authMiddleware, requireRole(["admin", "doctor","nurse","patient"]), async (req: TenantRequest, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid forecast ID" });
      }

      const forecast = await storage.getFinancialForecast(id, req.tenant!.id);
      if (!forecast) {
        return res.status(404).json({ error: "Forecast not found" });
      }

      res.json(forecast);
    } catch (error) {
      console.error("Error getting financial forecast:", error);
      res.status(500).json({ error: "Failed to get financial forecast" });
    }
  });

  app.post("/api/financial-forecasting/generate", authMiddleware, requireRole(["admin", "doctor","nurse","patient"]), async (req: TenantRequest, res) => {
    try {
      const forecasts = await storage.generateFinancialForecasts(req.tenant!.id);
      res.json(forecasts);
    } catch (error) {
      console.error("Error generating financial forecasts:", error);
      res.status(500).json({ error: "Failed to generate financial forecasts" });
    }
  });

  app.put("/api/financial-forecasting/:id", authMiddleware, requireRole(["admin", "doctor","nurse","patient"]), async (req: TenantRequest, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid forecast ID" });
      }

      const updateData = z.object({
        category: z.string().optional(),
        forecastPeriod: z.string().optional(),
        currentValue: z.number().optional(),
        projectedValue: z.number().optional(),
        variance: z.number().optional(),
        trend: z.enum(['up', 'down', 'stable']).optional(),
        confidence: z.number().min(0).max(100).optional(),
        methodology: z.string().optional(),
        keyFactors: z.array(z.object({
          factor: z.string(),
          impact: z.enum(['positive', 'negative', 'neutral']),
          weight: z.number(),
          description: z.string()
        })).optional(),
        metadata: z.record(z.any()).optional(),
        isActive: z.boolean().optional()
      }).parse(req.body);

      const updatedForecast = await storage.updateFinancialForecast(id, req.tenant!.id, updateData);
      if (!updatedForecast) {
        return res.status(404).json({ error: "Forecast not found" });
      }

      res.json(updatedForecast);
    } catch (error) {
      console.error("Error updating financial forecast:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to update financial forecast" });
    }
  });

  app.delete("/api/financial-forecasting/:id", authMiddleware, requireRole(["admin", "doctor","nurse","patient"]), async (req: TenantRequest, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid forecast ID" });
      }

      const deleted = await storage.deleteFinancialForecast(id, req.tenant!.id);
      if (deleted) {
        res.json({ success: true, message: "Forecast deleted successfully" });
      } else {
        res.status(404).json({ error: "Forecast not found" });
      }
    } catch (error) {
      console.error("Error deleting financial forecast:", error);
      res.status(500).json({ error: "Failed to delete financial forecast" });
    }
  });

  // Forecast Models endpoints
  app.get("/api/forecast-models", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const models = await storage.getForecastModels(req.tenant!.id);
      res.json(models);
    } catch (error) {
      console.error("Error getting forecast models:", error);
      res.status(500).json({ error: "Failed to get forecast models" });
    }
  });

  app.get("/api/forecast-models/:id", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid model ID" });
      }

      const model = await storage.getForecastModel(id, req.tenant!.id);
      if (!model) {
        return res.status(404).json({ error: "Model not found" });
      }

      res.json(model);
    } catch (error) {
      console.error("Error getting forecast model:", error);
      res.status(500).json({ error: "Failed to get forecast model" });
    }
  });

  app.post("/api/forecast-models", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const modelData = z.object({
        name: z.string().min(1),
        description: z.string().optional(),
        modelType: z.enum(['regression', 'arima', 'exponential_smoothing', 'neural_network', 'ensemble']),
        parameters: z.record(z.any()),
        dataRequirements: z.array(z.string()),
        accuracy: z.number().min(0).max(100).optional(),
        isActive: z.boolean().default(true)
      }).parse(req.body);

      const model = await storage.createForecastModel({
        ...modelData,
        organizationId: req.tenant!.id
      });

      res.status(201).json(model);
    } catch (error) {
      console.error("Error creating forecast model:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to create forecast model" });
    }
  });

  app.put("/api/forecast-models/:id", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid model ID" });
      }

      const updateData = z.object({
        name: z.string().min(1).optional(),
        description: z.string().optional(),
        modelType: z.enum(['regression', 'arima', 'exponential_smoothing', 'neural_network', 'ensemble']).optional(),
        parameters: z.record(z.any()).optional(),
        dataRequirements: z.array(z.string()).optional(),
        accuracy: z.number().min(0).max(100).optional(),
        isActive: z.boolean().optional()
      }).parse(req.body);

      const updatedModel = await storage.updateForecastModel(id, req.tenant!.id, updateData);
      if (!updatedModel) {
        return res.status(404).json({ error: "Model not found" });
      }

      res.json(updatedModel);
    } catch (error) {
      console.error("Error updating forecast model:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to update forecast model" });
    }
  });

  app.delete("/api/forecast-models/:id", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid model ID" });
      }

      const deleted = await storage.deleteForecastModel(id, req.tenant!.id);
      if (deleted) {
        res.json({ success: true, message: "Model deleted successfully" });
      } else {
        res.status(404).json({ error: "Model not found" });
      }
    } catch (error) {
      console.error("Error deleting forecast model:", error);
      res.status(500).json({ error: "Failed to delete forecast model" });
    }
  });

  // PDF Email endpoint for prescriptions with file attachments
  app.post("/api/prescriptions/:id/send-pdf", authMiddleware, upload.array('attachments', 5), async (req: TenantRequest, res) => {
    try {
      console.log('[PRESCRIPTION-EMAIL] ===== STARTING EMAIL SEND PROCESS =====');
      const prescriptionId = parseInt(req.params.id);
      
      // Parse form data fields
      const pharmacyEmail = req.body.pharmacyEmail;
      const pharmacyName = req.body.pharmacyName || 'Pharmacy Team';
      let patientName = req.body.patientName;

      // Validate required fields
      if (!pharmacyEmail || !pharmacyEmail.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
        console.log('[PRESCRIPTION-EMAIL] ‚ùå Invalid email address:', pharmacyEmail);
        return res.status(400).json({ error: "Valid pharmacy email is required" });
      }

      console.log('[PRESCRIPTION-EMAIL] Email request data:', {
        prescriptionId,
        pharmacyEmail,
        pharmacyName,
        patientName,
        attachmentsCount: req.files?.length || 0
      });

      // If no patient name provided, try to get it from the prescription record
      if (!patientName) {
        try {
          const prescription = await storage.getPrescription(prescriptionId, req.tenant!.id);
          if (prescription && prescription.patientId) {
            const patient = await storage.getPatient(prescription.patientId, req.tenant!.id);
            if (patient) {
              patientName = `${patient.firstName} ${patient.lastName}`.trim();
            }
          }
        } catch (error) {
          console.log('Could not fetch patient name from prescription:', error);
          patientName = 'Patient';
        }
      }

      console.log('Final patient name used in email:', patientName);

      // Get organization info for logo and branding
      const organization = await storage.getOrganization(req.tenant!.id);
      const organizationName = organization?.brandName || organization?.name;
      
      // Get clinic logo from clinic_headers table
      let clinicLogoUrl: string | undefined;
      try {
        const clinicHeader = await storage.getActiveClinicHeader(req.tenant!.id);
        clinicLogoUrl = clinicHeader?.logoBase64 || undefined;
        console.log('[PRESCRIPTION-EMAIL] Clinic logo from clinic_headers:', clinicLogoUrl ? 'Logo found' : 'No logo');
      } catch (error) {
        console.log('[PRESCRIPTION-EMAIL] Could not fetch clinic header logo:', error);
        clinicLogoUrl = undefined;
      }

      // Prepare attachments array including user uploaded files
      const attachments: any[] = [];

      // Add user-uploaded file attachments
      if (req.files && Array.isArray(req.files)) {
        req.files.forEach((file: Express.Multer.File, index: number) => {
          attachments.push({
            filename: file.originalname,
            content: file.buffer,
            contentType: file.mimetype
          });
          console.log(`Added attachment ${index + 1}: ${file.originalname} (${file.size} bytes)`);
        });
      }

      // Generate professional HTML email template with clinic logo and branding
      // Always hide "PDF Attachment Included" section as per user requirement
      const emailTemplate = emailService.generatePrescriptionEmail(
        patientName || 'Patient',
        pharmacyName,
        undefined, // prescriptionData - not needed for this basic email
        clinicLogoUrl,
        organizationName,
        false // hasAttachments - always false to hide the attachment notice section
      );

      // TODO: In a real implementation, generate and add prescription PDF here
      // For now, we'll send the professional HTML email with user attachments
      console.log('[PRESCRIPTION-EMAIL] Calling emailService.sendEmail()...');
      const emailSent = await emailService.sendEmail({
        to: pharmacyEmail,
        subject: emailTemplate.subject,
        html: emailTemplate.html,
        text: emailTemplate.text,
        attachments: attachments.length > 0 ? attachments : undefined
      });

      console.log('[PRESCRIPTION-EMAIL] emailService.sendEmail() returned:', emailSent);

      if (emailSent) {
        const attachmentInfo = attachments.length > 0 
          ? ` with ${attachments.length} attachment(s)`
          : '';
        console.log('[PRESCRIPTION-EMAIL] ‚úÖ Email sent successfully to:', pharmacyEmail);
        res.json({ 
          success: true, 
          message: `Prescription email sent successfully to ${pharmacyEmail}${attachmentInfo}`,
          attachmentsCount: attachments.length
        });
      } else {
        console.log('[PRESCRIPTION-EMAIL] ‚ùå Email service returned false - email not sent');
        res.status(500).json({ error: "Failed to send prescription email" });
      }
    } catch (error) {
      console.error("[PRESCRIPTION-EMAIL] ‚ùå Exception occurred:", error);
      if (error instanceof Error && error.message?.includes('Invalid file type')) {
        return res.status(400).json({ error: error.message });
      }
      res.status(500).json({ error: "Failed to send prescription PDF" });
    }
  });

  // Shift Management API endpoints
  app.get("/api/shifts", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { date } = req.query as { date?: string };
      
      // Server-side enforcement: Doctors can only see their own shifts
      let createdByFilter: number | undefined = undefined;
      if (req.user && isDoctorLike(req.user.role)) {
        createdByFilter = req.user.id;
        console.log("GET /api/shifts - Doctor role detected, enforcing created_by filter:", createdByFilter);
      }
      
      console.log("GET /api/shifts - Fetching shifts for organization:", req.tenant!.id, "date filter:", date, "createdBy filter:", createdByFilter);
      const shifts = await storage.getStaffShiftsByOrganization(req.tenant!.id, date, createdByFilter);
      console.log("GET /api/shifts - Found shifts count:", shifts.length);
      console.log("GET /api/shifts - Shifts data:", shifts.map(s => ({ id: s.id, staffId: s.staffId, date: s.date, startTime: s.startTime, endTime: s.endTime })));
      res.json(shifts);
    } catch (error) {
      console.error("Error fetching shifts:", error);
      res.status(500).json({ error: "Failed to fetch shifts" });
    }
  });

  app.get("/api/shifts/:id", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const shiftId = parseInt(req.params.id);
      const shift = await storage.getStaffShift(shiftId, req.tenant!.id);
      
      if (!shift) {
        return res.status(404).json({ error: "Shift not found" });
      }
      
      res.json(shift);
    } catch (error) {
      console.error("Error fetching shift:", error);
      res.status(500).json({ error: "Failed to fetch shift" });
    }
  });

  app.post("/api/shifts", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const shiftData = z.object({
        staffId: z.number(),
        date: z.string(),
        shiftType: z.enum(["regular", "overtime", "on_call", "absent"]),
        startTime: z.string(),
        endTime: z.string(),
        status: z.enum(["scheduled", "completed", "cancelled", "absent"]).default("scheduled"),
        notes: z.string().optional(),
        isAvailable: z.boolean().default(true)
      }).parse(req.body);

      const shift = await storage.createStaffShift(enforceCreatedBy(req, {
        ...shiftData,
        organizationId: req.tenant!.id,
        date: new Date(shiftData.date)
      }));

      res.status(201).json(shift);
    } catch (error) {
      console.error("Error creating shift:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to create shift" });
    }
  });

  app.put("/api/shifts/:id", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const shiftId = parseInt(req.params.id);
      const updateData = z.object({
        staffId: z.number().optional(),
        date: z.string().optional(),
        shiftType: z.enum(["regular", "overtime", "on_call", "absent"]).optional(),
        startTime: z.string().optional(),
        endTime: z.string().optional(),
        status: z.enum(["scheduled", "completed", "cancelled", "absent"]).optional(),
        notes: z.string().optional(),
        isAvailable: z.boolean().optional()
      }).parse(req.body);

      const processedData: any = { ...updateData };
      if (updateData.date) {
        processedData.date = new Date(updateData.date);
      }

      const shift = await storage.updateStaffShift(shiftId, req.tenant!.id, processedData);
      
      if (!shift) {
        return res.status(404).json({ error: "Shift not found" });
      }
      
      res.json(shift);
    } catch (error) {
      console.error("Error updating shift:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to update shift" });
    }
  });

  app.delete("/api/shifts/:id", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const shiftId = parseInt(req.params.id);
      const deleted = await storage.deleteStaffShift(shiftId, req.tenant!.id);
      
      if (!deleted) {
        return res.status(404).json({ error: "Shift not found" });
      }
      
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting shift:", error);
      res.status(500).json({ error: "Failed to delete shift" });
    }
  });

  app.get("/api/shifts/staff/:staffId", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const staffId = parseInt(req.params.staffId);
      const { date } = req.query as { date?: string };
      const shifts = await storage.getStaffShiftsByStaff(staffId, req.tenant!.id, date);
      res.json(shifts);
    } catch (error) {
      console.error("Error fetching staff shifts:", error);
      res.status(500).json({ error: "Failed to fetch staff shifts" });
    }
  });

  // Default Shifts API endpoints
  app.get("/api/default-shifts", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const userId = req.user?.id;
      const isAdmin = req.user?.role === 'admin' || req.user?.role === 'administrator';
      const forBooking = req.query.forBooking === 'true';

      let defaultShifts;
      
      // Allow all users to fetch all default shifts when booking appointments
      if (isAdmin || forBooking) {
        defaultShifts = await storage.getDefaultShiftsByOrganization(organizationId);
      } else {
        defaultShifts = await storage.getDefaultShiftByUser(userId!, organizationId);
        defaultShifts = defaultShifts ? [defaultShifts] : [];
      }

      res.json(defaultShifts);
    } catch (error) {
      console.error("Error fetching default shifts:", error);
      res.status(500).json({ error: "Failed to fetch default shifts" });
    }
  });

  app.get("/api/default-shifts/:userId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const organizationId = req.tenant!.id;
      const requestingUserId = req.user?.id;
      const isAdmin = req.user?.role === 'admin' || req.user?.role === 'administrator';

      if (!isAdmin && userId !== requestingUserId) {
        return res.status(403).json({ error: "Forbidden: Can only view your own default shift" });
      }

      const defaultShift = await storage.getDefaultShiftByUser(userId, organizationId);
      
      if (!defaultShift) {
        return res.status(404).json({ error: "Default shift not found" });
      }

      res.json(defaultShift);
    } catch (error) {
      console.error("Error fetching default shift:", error);
      res.status(500).json({ error: "Failed to fetch default shift" });
    }
  });

  app.patch("/api/default-shifts/:userId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const organizationId = req.tenant!.id;
      const requestingUserId = req.user?.id;
      const isAdmin = req.user?.role === 'admin' || req.user?.role === 'administrator';

      if (!isAdmin && userId !== requestingUserId) {
        return res.status(403).json({ error: "Forbidden: Can only edit your own default shift" });
      }

      const updateData = z.object({
        startTime: z.string().optional(),
        endTime: z.string().optional(),
        workingDays: z.array(z.string()).optional(),
      }).parse(req.body);

      const updatedShift = await storage.updateDefaultShift(userId, organizationId, updateData);

      if (!updatedShift) {
        return res.status(404).json({ error: "Default shift not found" });
      }

      res.json(updatedShift);
    } catch (error) {
      console.error("Error updating default shift:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
        });
      }
      res.status(500).json({ error: "Failed to update default shift" });
    }
  });

  app.post("/api/default-shifts/initialize", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      const result = await storage.initializeDefaultShifts(organizationId);

      res.json({
        message: "Default shifts initialized successfully",
        created: result.created,
        skipped: result.skipped,
        total: result.created + result.skipped
      });
    } catch (error) {
      console.error("Error initializing default shifts:", error);
      res.status(500).json({ error: "Failed to initialize default shifts" });
    }
  });

  app.delete("/api/default-shifts/all", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      
      const result = await storage.deleteAllDefaultShifts(organizationId);

      res.json({
        message: "All default shifts deleted successfully",
        deleted: result.deleted
      });
    } catch (error) {
      console.error("Error deleting all default shifts:", error);
      res.status(500).json({ error: "Failed to delete all default shifts" });
    }
  });

  app.delete("/api/default-shifts/:userId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const organizationId = req.tenant!.id;
      const requestingUserId = req.user?.id;
      const isAdmin = req.user?.role === "admin";

      if (!isAdmin && userId !== requestingUserId) {
        return res.status(403).json({ error: "Forbidden: Can only delete your own default shift" });
      }

      const deleted = await storage.deleteDefaultShift(userId, organizationId);

      if (!deleted) {
        return res.status(404).json({ error: "Default shift not found" });
      }

      res.json({ message: "Default shift deleted successfully" });
    } catch (error) {
      console.error("Error deleting default shift:", error);
      res.status(500).json({ error: "Failed to delete default shift" });
    }
  });

  // Mobile API endpoints for Doctor and Patient apps
  
  // Doctor Mobile API endpoints
  app.get("/api/mobile/doctor/dashboard", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) return res.status(401).json({ error: "Unauthorized" });

      // Get doctor's dashboard data
      const todayAppointments = await storage.getAppointmentsByProvider(userId, req.tenant!.id);
      const patientUsers = await storage.getUsersByRole("patient", req.tenant!.id);
      const pendingPrescriptions = await storage.getPrescriptionsByProvider(userId, req.tenant!.id);
      
      res.json({
        todayAppointments: todayAppointments.filter(apt => {
          const aptDate = new Date(apt.scheduledAt);
          const today = new Date();
          return aptDate.toDateString() === today.toDateString();
        }).length,
        totalPatients: patientUsers.length,
        pendingPrescriptions: pendingPrescriptions.filter(p => p.status === 'pending').length,
        upcomingAppointments: todayAppointments.slice(0, 5).map(apt => ({
          id: apt.id,
          patientName: `Patient ${apt.patientId}`,
          time: apt.scheduledAt,
          type: apt.type,
          status: apt.status
        }))
      });
    } catch (error) {
      console.error("Error fetching doctor dashboard:", error);
      res.status(500).json({ error: "Failed to fetch dashboard data" });
    }
  });

  app.get("/api/mobile/doctor/patients", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const patients = await storage.getPatientsByOrganization(req.tenant!.id);
      
      const mobilePatients = patients.map(patient => ({
        id: patient.id,
        patientId: patient.patientId,
        name: `${patient.firstName} ${patient.lastName}`,
        email: patient.email,
        phone: patient.phone,
        dateOfBirth: patient.dateOfBirth,
        // gender: not available in schema,
        emergencyContact: patient.emergencyContact,
        lastVisit: patient.updatedAt,
        riskLevel: patient.riskLevel || 'low'
      }));
      
      res.json(mobilePatients);
    } catch (error) {
      console.error("Error fetching patients for mobile:", error);
      res.status(500).json({ error: "Failed to fetch patients" });
    }
  });

  app.get("/api/mobile/doctor/appointments", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User authentication required" });
      }
      const { date } = req.query as { date?: string };
      
      let appointments = await storage.getAppointmentsByProvider(userId, req.tenant!.id);
      
      if (date) {
        appointments = appointments.filter(apt => {
          const aptDate = new Date(apt.scheduledAt);
          return aptDate.toDateString() === new Date(date).toDateString();
        });
      }
      
      const patients = await storage.getPatientsByOrganization(req.tenant!.id);
      
      const mobileAppointments = appointments.map(apt => {
        const patient = patients.find(p => p.id === apt.patientId);
        return {
          id: apt.id,
          patientId: apt.patientId,
          patientName: patient ? `${patient.firstName} ${patient.lastName}` : `Patient ${apt.patientId}`,
          patientPhone: patient?.phone || '',
          title: apt.title,
          description: apt.description,
          scheduledAt: apt.scheduledAt,
          duration: apt.duration,
          status: apt.status,
          type: apt.type,
          location: apt.location,
          isVirtual: apt.isVirtual
        };
      });
      
      res.json(mobileAppointments);
    } catch (error) {
      console.error("Error fetching appointments for mobile:", error);
      res.status(500).json({ error: "Failed to fetch appointments" });
    }
  });

  app.post("/api/mobile/doctor/appointments/:id/accept", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const appointmentId = parseInt(req.params.id);
      const appointment = await storage.updateAppointment(appointmentId, req.tenant!.id, {
        status: 'confirmed'
      });
      
      if (!appointment) {
        return res.status(404).json({ error: "Appointment not found" });
      }
      
      res.json({ message: "Appointment accepted successfully", appointment });
    } catch (error) {
      console.error("Error accepting appointment:", error);
      res.status(500).json({ error: "Failed to accept appointment" });
    }
  });

  app.post("/api/mobile/doctor/appointments/:id/reject", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const appointmentId = parseInt(req.params.id);
      const { reason } = req.body;
      
      const appointment = await storage.updateAppointment(appointmentId, req.tenant!.id, {
        status: 'cancelled',
        description: reason ? `Cancelled: ${reason}` : 'Cancelled by doctor'
      });
      
      if (!appointment) {
        return res.status(404).json({ error: "Appointment not found" });
      }
      
      res.json({ message: "Appointment rejected successfully", appointment });
    } catch (error) {
      console.error("Error rejecting appointment:", error);
      res.status(500).json({ error: "Failed to reject appointment" });
    }
  });

  app.get("/api/mobile/doctor/prescriptions", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User authentication required" });
      }
      const prescriptions = await storage.getPrescriptionsByProvider(userId, req.tenant!.id);
      const patients = await storage.getPatientsByOrganization(req.tenant!.id);
      
      const mobilePrescriptions = prescriptions.map(prescription => {
        const patient = patients.find(p => p.id === prescription.patientId);
        return {
          id: prescription.id,
          patientId: prescription.patientId,
          patientName: patient ? `${patient.firstName} ${patient.lastName}` : `Patient ${prescription.patientId}`,
          medication: prescription.medicationName,
          dosage: prescription.dosage,
          frequency: prescription.frequency,
          duration: prescription.duration,
          instructions: prescription.instructions,
          status: prescription.status,
          createdAt: prescription.createdAt
        };
      });
      
      res.json(mobilePrescriptions);
    } catch (error) {
      console.error("Error fetching prescriptions for mobile:", error);
      res.status(500).json({ error: "Failed to fetch prescriptions" });
    }
  });

  app.post("/api/mobile/doctor/prescriptions", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User authentication required" });
      }
      const prescriptionData = {
        ...req.body,
        doctorId: userId,
        organizationId: req.tenant!.id,
        status: 'active'
      };
      
      const prescription = await storage.createPrescription(prescriptionData);
      res.status(201).json(prescription);
    } catch (error) {
      console.error("Error creating prescription:", error);
      res.status(500).json({ error: "Failed to create prescription" });
    }
  });

  // Patient Mobile API endpoints
  app.get("/api/mobile/patient/dashboard", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) return res.status(401).json({ error: "Unauthorized" });

      const patient = await storage.getPatientByUserId(userId, req.tenant!.id);
      if (!patient) return res.status(404).json({ error: "Patient not found" });

      const appointments = await storage.getAppointmentsByPatient(patient.id, req.tenant!.id);
      const prescriptions = await storage.getPrescriptionsByPatient(patient.id, req.tenant!.id);
      const medicalRecords = await storage.getMedicalRecordsByPatient(patient.id, req.tenant!.id);
      
      const todayAppointments = appointments.filter(apt => {
        const aptDate = new Date(apt.scheduledAt);
        const today = new Date();
        return aptDate.toDateString() === today.toDateString() && apt.status === 'scheduled';
      });

      res.json({
        patientInfo: {
          name: `${patient.firstName} ${patient.lastName}`,
          email: patient.email,
          phone: patient.phone,
          patientId: patient.patientId
        },
        upcomingAppointments: todayAppointments.length,
        activePrescriptions: prescriptions.filter(p => p.status === 'active').length,
        totalRecords: medicalRecords.length,
        recentAppointments: appointments.slice(0, 3).map(apt => ({
          id: apt.id,
          title: apt.title,
          scheduledAt: apt.scheduledAt,
          status: apt.status,
          type: apt.type
        }))
      });
    } catch (error) {
      console.error("Error fetching patient dashboard:", error);
      res.status(500).json({ error: "Failed to fetch dashboard data" });
    }
  });

  app.get("/api/mobile/patient/appointments", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User authentication required" });
      }
      const patient = await storage.getPatientByUserId(userId, req.tenant!.id);
      if (!patient) return res.status(404).json({ error: "Patient not found" });

      const appointments = await storage.getAppointmentsByPatient(patient.id, req.tenant!.id);
      const users = await storage.getUsersByOrganization(req.tenant!.id);
      
      const mobileAppointments = appointments.map(apt => {
        const provider = users.find(u => u.id === apt.providerId);
        return {
          id: apt.id,
          title: apt.title,
          description: apt.description,
          scheduledAt: apt.scheduledAt,
          duration: apt.duration,
          status: apt.status,
          type: apt.type,
          location: apt.location,
          isVirtual: apt.isVirtual,
          providerName: provider ? `Dr. ${provider.firstName} ${provider.lastName}` : 'Unknown Provider'
        };
      });
      
      res.json(mobileAppointments);
    } catch (error) {
      console.error("Error fetching patient appointments:", error);
      res.status(500).json({ error: "Failed to fetch appointments" });
    }
  });

  app.post("/api/mobile/patient/appointments", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User authentication required" });
      }
      const patient = await storage.getPatientByUserId(userId, req.tenant!.id);
      if (!patient) return res.status(404).json({ error: "Patient not found" });

      const appointmentData = {
        ...req.body,
        patientId: patient.id,
        organizationId: req.tenant!.id,
        status: 'scheduled'
      };
      
      const appointment = await storage.createAppointment(appointmentData);
      res.status(201).json(appointment);
    } catch (error) {
      console.error("Error creating appointment:", error);
      res.status(500).json({ error: "Failed to create appointment" });
    }
  });

  app.get("/api/mobile/patient/prescriptions", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User authentication required" });
      }
      const patient = await storage.getPatientByUserId(userId, req.tenant!.id);
      if (!patient) return res.status(404).json({ error: "Patient not found" });

      const prescriptions = await storage.getPrescriptionsByPatient(patient.id, req.tenant!.id);
      const users = await storage.getUsersByOrganization(req.tenant!.id);
      
      const mobilePrescriptions = prescriptions.map(prescription => {
        const provider = users.find(u => u.id === prescription.doctorId);
        return {
          id: prescription.id,
          medication: prescription.medicationName,
          dosage: prescription.dosage,
          frequency: prescription.frequency,
          duration: prescription.duration,
          instructions: prescription.instructions,
          status: prescription.status,
          createdAt: prescription.createdAt,
          providerName: provider ? `Dr. ${provider.firstName} ${provider.lastName}` : 'Unknown Provider'
        };
      });
      
      res.json(mobilePrescriptions);
    } catch (error) {
      console.error("Error fetching patient prescriptions:", error);
      res.status(500).json({ error: "Failed to fetch prescriptions" });
    }
  });

  app.get("/api/mobile/patient/medical-records", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User authentication required" });
      }
      const patient = await storage.getPatientByUserId(userId, req.tenant!.id);
      if (!patient) return res.status(404).json({ error: "Patient not found" });

      const records = await storage.getMedicalRecordsByPatient(patient.id, req.tenant!.id);
      const users = await storage.getUsersByOrganization(req.tenant!.id);
      
      const mobileRecords = records.map(record => {
        const provider = users.find(u => u.id === record.providerId);
        return {
          id: record.id,
          type: record.type,
          title: record.title,
          notes: record.notes,
          diagnosis: record.diagnosis,
          treatment: record.treatment,
          createdAt: record.createdAt,
          providerName: provider ? `Dr. ${provider.firstName} ${provider.lastName}` : 'Unknown Provider'
        };
      });
      
      res.json(mobileRecords);
    } catch (error) {
      console.error("Error fetching patient medical records:", error);
      res.status(500).json({ error: "Failed to fetch medical records" });
    }
  });

  app.get("/api/mobile/patient/profile", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) return res.status(401).json({ error: "Unauthorized" });

      const patient = await storage.getPatientByUserId(userId, req.tenant!.id);
      if (!patient) return res.status(404).json({ error: "Patient profile not found" });

      const profileData = {
        id: patient.id,
        patientId: patient.patientId,
        firstName: patient.firstName,
        lastName: patient.lastName,
        email: patient.email,
        phone: patient.phone,
        dateOfBirth: patient.dateOfBirth,
        // gender: not available in schema,
        address: patient.address,
        emergencyContact: patient.emergencyContact,
        insuranceProvider: patient.insuranceInfo?.provider || '',
        insuranceNumber: patient.insuranceInfo?.policyNumber || '',
        medicalHistory: patient.medicalHistory,
        allergies: patient.medicalHistory?.allergies || [],
        currentMedications: patient.medicalHistory?.medications || [],
        // bloodType: not available in schema,
        riskLevel: patient.riskLevel,
        createdAt: patient.createdAt,
        updatedAt: patient.updatedAt
      };
      
      res.json(profileData);
    } catch (error) {
      console.error("Error fetching patient profile:", error);
      res.status(500).json({ error: "Failed to fetch patient profile" });
    }
  });

  app.get("/api/mobile/doctors", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const users = await storage.getUsersByOrganization(req.tenant!.id);
      
      const doctors = users
        .filter(user => isDoctorLike(user.role) && user.isActive)
        .map(doctor => ({
          id: doctor.id,
          name: `Dr. ${doctor.firstName} ${doctor.lastName}`,
          email: doctor.email,
          department: doctor.department || 'General Medicine',
          specialization: doctor.department || 'General Practice',
          workingHours: doctor.workingHours || { start: '09:00', end: '17:00' },
          workingDays: doctor.workingDays || ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
        }));
      
      res.json(doctors);
    } catch (error) {
      console.error("Error fetching doctors:", error);
      res.status(500).json({ error: "Failed to fetch doctors" });
    }
  });

  // Video consultation endpoints
  app.post("/api/mobile/video/start-consultation", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { appointmentId } = req.body;
      
      // Generate a unique room ID for the consultation
      const roomId = `consultation_${appointmentId}_${Date.now()}`;
      
      res.json({
        roomId,
        message: "Video consultation started",
        joinUrl: `https://meet.jit.si/${roomId}`
      });
    } catch (error) {
      console.error("Error starting video consultation:", error);
      res.status(500).json({ error: "Failed to start consultation" });
    }
  });

  // Mobile API Endpoints for Flutter Apps
  
  // Doctor Mobile App Endpoints
  app.get("/api/mobile/doctor/dashboard", authMiddleware, requireRole(["doctor"]), async (req: TenantRequest, res) => {
    try {
      const todayAppointments = await storage.getAppointmentsByOrganization(req.tenant!.id, new Date());
      const patientUsers = await storage.getUsersByRole("patient", req.tenant!.id);
      const pendingPrescriptions = await storage.getPrescriptionsByOrganization(req.tenant!.id);
      
      const dashboardData = {
        todayAppointments: todayAppointments.length,
        totalPatients: patientUsers.length,
        pendingPrescriptions: pendingPrescriptions.filter(p => p.status === 'pending').length,
        upcomingAppointments: todayAppointments
          .filter(apt => new Date(apt.scheduledAt) > new Date())
          .slice(0, 5)
          .map(apt => ({
            id: apt.id,
            patientName: 'Patient Name', // TODO: Join with patient table
            time: apt.scheduledAt,
            type: apt.type,
            status: apt.status
          }))
      };
      
      res.json(dashboardData);
    } catch (error) {
      console.error("Error fetching doctor dashboard:", error);
      res.status(500).json({ error: "Failed to load dashboard data" });
    }
  });

  app.get("/api/mobile/doctor/patients", authMiddleware, requireRole(["doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const patients = await storage.getPatientsByOrganization(req.tenant!.id);
      const formattedPatients = patients.map(patient => ({
        id: patient.id,
        name: `${patient.firstName} ${patient.lastName}`,
        patientId: patient.patientId,
        email: patient.email,
        phone: patient.phone,
        dateOfBirth: patient.dateOfBirth,
        // gender: not available in schema,
        // lastVisit: not available in current schema
        riskLevel: patient.riskLevel || 'low'
      }));
      
      res.json(formattedPatients);
    } catch (error) {
      console.error("Error fetching patients for doctor mobile:", error);
      res.status(500).json({ error: "Failed to load patients" });
    }
  });

  app.get("/api/mobile/doctor/appointments", authMiddleware, requireRole(["doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const date = req.query.date ? new Date(req.query.date as string) : new Date();
      const appointments = await storage.getAppointmentsByOrganization(req.tenant!.id, date);
      
      res.json(appointments);
    } catch (error) {
      console.error("Error fetching doctor appointments:", error);
      res.status(500).json({ error: "Failed to load appointments" });
    }
  });

  app.post("/api/mobile/doctor/appointments/:id/accept", authMiddleware, requireRole(["doctor"]), async (req: TenantRequest, res) => {
    try {
      const appointmentId = parseInt(req.params.id);
      const updatedAppointment = await storage.updateAppointment(appointmentId, req.tenant!.id, { status: 'confirmed' });
      
      if (!updatedAppointment) {
        return res.status(404).json({ error: "Appointment not found" });
      }
      
      res.json(updatedAppointment);
    } catch (error) {
      console.error("Error accepting appointment:", error);
      res.status(500).json({ error: "Failed to accept appointment" });
    }
  });

  app.post("/api/mobile/doctor/appointments/:id/reject", authMiddleware, requireRole(["doctor"]), async (req: TenantRequest, res) => {
    try {
      const appointmentId = parseInt(req.params.id);
      const { reason } = req.body;
      
      const updatedAppointment = await storage.updateAppointment(appointmentId, req.tenant!.id, { 
        status: 'cancelled',
        description: `Cancelled: ${reason}`
      });
      
      if (!updatedAppointment) {
        return res.status(404).json({ error: "Appointment not found" });
      }
      
      res.json(updatedAppointment);
    } catch (error) {
      console.error("Error rejecting appointment:", error);
      res.status(500).json({ error: "Failed to reject appointment" });
    }
  });

  app.get("/api/mobile/doctor/prescriptions", authMiddleware, requireRole(["doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const prescriptions = await storage.getPrescriptionsByOrganization(req.tenant!.id);
      res.json(prescriptions);
    } catch (error) {
      console.error("Error fetching doctor prescriptions:", error);
      res.status(500).json({ error: "Failed to load prescriptions" });
    }
  });

  app.post("/api/mobile/doctor/prescriptions", authMiddleware, requireRole(["doctor"]), async (req: TenantRequest, res) => {
    try {
      const prescriptionData = {
        ...req.body,
        organizationId: req.tenant!.id,
        providerId: req.user!.id,
        prescriptionNumber: `RX-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`,
        status: 'active'
      };
      
      const newPrescription = await storage.createPrescription(prescriptionData);
      res.status(201).json(newPrescription);
    } catch (error) {
      console.error("Error creating prescription:", error);
      res.status(500).json({ error: "Failed to create prescription" });
    }
  });

  // Patient Mobile App Endpoints
  app.get("/api/mobile/patient/dashboard", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      const patientId = req.user!.id;
      const appointments = await storage.getAppointmentsByPatient(patientId, req.tenant!.id);
      const prescriptions = await storage.getPrescriptionsByPatient(patientId, req.tenant!.id);
      const medicalRecords = await storage.getMedicalRecordsByPatient(patientId, req.tenant!.id);
      
      const dashboardData = {
        upcomingAppointments: appointments.filter(apt => 
          new Date(apt.scheduledAt) > new Date() && apt.status !== 'cancelled'
        ).length,
        activePrescriptions: prescriptions.filter(p => p.status === 'active').length,
        medicalRecords: medicalRecords.length,
        nextAppointment: appointments
          .filter(apt => new Date(apt.scheduledAt) > new Date() && apt.status !== 'cancelled')
          .sort((a, b) => new Date(a.scheduledAt).getTime() - new Date(b.scheduledAt).getTime())[0] || null
      };
      
      res.json(dashboardData);
    } catch (error) {
      console.error("Error fetching patient dashboard:", error);
      res.status(500).json({ error: "Failed to load dashboard data" });
    }
  });

  app.get("/api/mobile/patient/appointments", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      // Find the patient record by the authenticated user's email
      const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
      const patient = patients.find(p => p.email === req.user!.email);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient record not found for authenticated user" });
      }
      
      const appointments = await storage.getAppointmentsByPatient(patient.id, req.tenant!.id);
      res.json(appointments);
    } catch (error) {
      console.error("Error fetching patient appointments:", error);
      res.status(500).json({ error: "Failed to load appointments" });
    }
  });

  app.post("/api/mobile/patient/appointments", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      // Find the patient record by the authenticated user's email
      const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
      const patient = patients.find(p => p.email === req.user!.email);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient record not found for authenticated user" });
      }
      
      const appointmentData = {
        ...req.body,
        patientId: patient.id, // Use the patient's database ID, not the user ID
        organizationId: req.tenant!.id,
        status: 'scheduled'
      };
      
      const newAppointment = await storage.createAppointment(appointmentData);
      res.status(201).json(newAppointment);
    } catch (error) {
      console.error("Error booking appointment:", error);
      res.status(500).json({ error: "Failed to book appointment" });
    }
  });

  app.delete("/api/mobile/patient/appointments/:id", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      const appointmentId = parseInt(req.params.id);
      
      // Find the patient record by the authenticated user's email
      const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
      const patient = patients.find(p => p.email === req.user!.email);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient record not found for authenticated user" });
      }
      
      // Verify the appointment belongs to the patient
      const appointment = await storage.getAppointment(appointmentId, req.tenant!.id);
      if (!appointment || appointment.patientId !== patient.id) {
        return res.status(404).json({ error: "Appointment not found" });
      }
      
      const updatedAppointment = await storage.updateAppointment(appointmentId, req.tenant!.id, { 
        status: 'cancelled'
      });
      
      res.json(updatedAppointment);
    } catch (error) {
      console.error("Error cancelling appointment:", error);
      res.status(500).json({ error: "Failed to cancel appointment" });
    }
  });

  app.get("/api/mobile/patient/prescriptions", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      const patientId = req.user!.id;
      const prescriptions = await storage.getPrescriptionsByPatient(patientId, req.tenant!.id);
      res.json(prescriptions);
    } catch (error) {
      console.error("Error fetching patient prescriptions:", error);
      res.status(500).json({ error: "Failed to load prescriptions" });
    }
  });

  // Patient Dashboard endpoints
  app.get("/api/patients/my-appointments", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      // Find the patient record by the authenticated user's email
      const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
      const patient = patients.find(p => p.email === req.user!.email);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient record not found for authenticated user" });
      }
      
      const appointments = await storage.getAppointmentsByPatient(patient.id, req.tenant!.id);
      
      // Filter to future appointments and sort by date
      const now = new Date();
      const futureAppointments = appointments
        .filter(apt => new Date(apt.scheduledAt) > now)
        .sort((a, b) => new Date(a.scheduledAt).getTime() - new Date(b.scheduledAt).getTime());
      
      // Get provider information for appointments
      const users = await storage.getUsersByOrganization(req.tenant!.id);
      const appointmentsWithProviders = futureAppointments.map(apt => {
        const provider = users.find(u => u.id === apt.providerId);
        return {
          ...apt,
          provider: provider ? `Dr. ${provider.firstName} ${provider.lastName}` : 'Unknown Provider'
        };
      });
      
      res.json({
        appointments: appointmentsWithProviders,
        nextAppointment: appointmentsWithProviders[0] || null,
        patientId: patient.id
      });
    } catch (error) {
      console.error("Error fetching patient appointments:", error);
      res.status(500).json({ error: "Failed to load appointments" });
    }
  });

  app.get("/api/patients/my-prescriptions", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      console.log("üè• MY-PRESCRIPTIONS DEBUG: Starting request for user:", req.user?.email);
      
      // Find the patient record by the authenticated user's email
      const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
      console.log("üè• MY-PRESCRIPTIONS DEBUG: Found patients count:", patients.length);
      
      const patient = patients.find(p => p.email === req.user!.email);
      console.log("üè• MY-PRESCRIPTIONS DEBUG: Found matching patient:", patient ? { id: patient.id, email: patient.email } : null);
      
      if (!patient) {
        console.log("üè• MY-PRESCRIPTIONS DEBUG: No patient found for email:", req.user!.email);
        return res.status(404).json({ error: "Patient record not found for authenticated user" });
      }
      
      console.log("üè• MY-PRESCRIPTIONS DEBUG: Getting prescriptions for patient ID:", patient.id);
      const prescriptions = await storage.getPrescriptionsByPatient(patient.id, req.tenant!.id);
      console.log("üè• MY-PRESCRIPTIONS DEBUG: Found prescriptions count:", prescriptions.length);
      
      res.json({
        prescriptions,
        totalCount: prescriptions.length,
        patientId: patient.id
      });
    } catch (error) {
      console.error("Error fetching patient prescriptions:", error);
      res.status(500).json({ error: "Failed to load prescriptions" });
    }
  });

  app.get("/api/mobile/patient/medical-records", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      const patientId = req.user!.id;
      const medicalRecords = await storage.getMedicalRecordsByPatient(patientId, req.tenant!.id);
      res.json(medicalRecords);
    } catch (error) {
      console.error("Error fetching patient medical records:", error);
      res.status(500).json({ error: "Failed to load medical records" });
    }
  });

  app.get("/api/mobile/patient/doctors", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      const doctors = await storage.getUsersByRole('doctor', req.tenant!.id);
      const formattedDoctors = doctors.map(doctor => ({
        id: doctor.id,
        name: `Dr. ${doctor.firstName} ${doctor.lastName}`,
        department: doctor.department || 'General Medicine',
        specialization: doctor.medicalSpecialtyCategory || doctor.subSpecialty || 'General Practice',
        email: doctor.email,
        workingHours: doctor.workingHours || 'Monday-Friday, 09:00-17:00'
      }));
      
      res.json(formattedDoctors);
    } catch (error) {
      console.error("Error fetching doctors:", error);
      res.status(500).json({ error: "Failed to load doctors" });
    }
  });

  app.get("/api/mobile/patient/available-slots", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      const { doctorId, date } = req.query;
      
      // Generate sample available slots (in a real app, this would check actual availability)
      const slots = [
        { time: '09:00', available: true },
        { time: '09:30', available: true },
        { time: '10:00', available: false },
        { time: '10:30', available: true },
        { time: '11:00', available: true },
        { time: '11:30', available: false },
        { time: '14:00', available: true },
        { time: '14:30', available: true },
        { time: '15:00', available: true },
        { time: '15:30', available: false },
        { time: '16:00', available: true },
        { time: '16:30', available: true }
      ].filter(slot => slot.available);
      
      res.json(slots);
    } catch (error) {
      console.error("Error fetching available slots:", error);
      res.status(500).json({ error: "Failed to load available slots" });
    }
  });

  app.get("/api/mobile/patient/profile", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      const patientId = req.user!.id;
      const patient = await storage.getPatient(patientId, req.tenant!.id);
      
      if (!patient) {
        return res.status(404).json({ error: "Patient profile not found" });
      }
      
      res.json(patient);
    } catch (error) {
      console.error("Error fetching patient profile:", error);
      res.status(500).json({ error: "Failed to load profile" });
    }
  });

  app.put("/api/mobile/patient/profile", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      const patientId = req.user!.id;
      const updatedPatient = await storage.updatePatient(patientId, req.tenant!.id, req.body);
      
      if (!updatedPatient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      
      res.json(updatedPatient);
    } catch (error) {
      console.error("Error updating patient profile:", error);
      res.status(500).json({ error: "Failed to update profile" });
    }
  });

  app.get("/api/mobile/patient/lab-results", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      console.log("üè• MOBILE LAB RESULTS DEBUG: Starting request for user:", req.user?.email);
      
      // Find the patient record by the authenticated user's email
      const patients = await storage.getPatientsByOrganization(req.tenant!.id, 100);
      console.log("üè• MOBILE LAB RESULTS DEBUG: Found patients count:", patients.length);
      
      const patient = patients.find(p => p.email === req.user!.email);
      console.log("üè• MOBILE LAB RESULTS DEBUG: Found matching patient:", patient ? { id: patient.id, email: patient.email } : null);
      
      if (!patient) {
        console.log("üè• MOBILE LAB RESULTS DEBUG: No patient found for email:", req.user!.email);
        return res.status(404).json({ error: "Patient record not found for authenticated user" });
      }
      
      console.log("üè• MOBILE LAB RESULTS DEBUG: Getting lab results for patient ID:", patient.id);
      const labResults = await storage.getLabResultsByPatient(patient.id, req.tenant!.id);
      console.log("üè• MOBILE LAB RESULTS DEBUG: Found lab results count:", labResults.length);
      
      res.json(labResults);
    } catch (error) {
      console.error("Error fetching patient lab results:", error);
      res.status(500).json({ error: "Failed to load lab results" });
    }
  });

  // Video consultation endpoints
  app.post("/api/mobile/video/start-consultation", authMiddleware, requireRole(["doctor"]), async (req: TenantRequest, res) => {
    try {
      const { appointmentId } = req.body;
      
      // Generate BigBlueButton meeting URL (simplified)
      const meetingData = {
        meetingId: `consultation-${appointmentId}-${Date.now()}`,
        meetingUrl: `https://vid2.averox.com/join?meeting=consultation-${appointmentId}`,
        moderatorPassword: `mod-${appointmentId}`,
        attendeePassword: `att-${appointmentId}`
      };
      
      res.json(meetingData);
    } catch (error) {
      console.error("Error starting video consultation:", error);
      res.status(500).json({ error: "Failed to start video consultation" });
    }
  });

  app.post("/api/mobile/video/join-consultation", authMiddleware, requireRole(["patient"]), async (req: TenantRequest, res) => {
    try {
      const { appointmentId } = req.body;
      
      // Generate BigBlueButton join URL for patient
      const joinData = {
        meetingUrl: `https://vid2.averox.com/join?meeting=consultation-${appointmentId}&role=attendee`,
        patientPassword: `att-${appointmentId}`
      };
      
      res.json(joinData);
    } catch (error) {
      console.error("Error joining video consultation:", error);
      res.status(500).json({ error: "Failed to join video consultation" });
    }
  });

  // AI Chatbot for Appointment Booking Routes
  app.post("/api/chatbot/chat", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { messages } = req.body;
      
      if (!messages || !Array.isArray(messages)) {
        return res.status(400).json({ error: "Messages array is required" });
      }

      // Get available doctors and time slots for context
      const doctors = await storage.getUsersByOrganization(req.tenant!.id);
      const availableDoctors = doctors
        .filter(doctor => isDoctorLike(doctor.role) && doctor.isActive)
        .map(doctor => ({
          id: doctor.id,
          name: `${doctor.firstName} ${doctor.lastName}`,
          specialty: doctor.department || 'General Medicine'
        }));

      // Get available appointments (future slots)
      const allAppointments = await storage.getAppointmentsByOrganization(req.tenant!.id);
      const now = new Date();
      const availableTimeSlots = [
        // Generate some sample available slots for the next 7 days
        ...Array.from({ length: 7 }, (_, dayOffset) => {
          const date = new Date(now);
          date.setDate(date.getDate() + dayOffset + 1);
          const dateStr = date.toISOString().split('T')[0];
          
          return availableDoctors.flatMap(doctor => [
            { date: dateStr, time: '09:00', doctorId: doctor.id },
            { date: dateStr, time: '10:00', doctorId: doctor.id },
            { date: dateStr, time: '11:00', doctorId: doctor.id },
            { date: dateStr, time: '14:00', doctorId: doctor.id },
            { date: dateStr, time: '15:00', doctorId: doctor.id },
            { date: dateStr, time: '16:00', doctorId: doctor.id }
          ]);
        }).flat()
      ];

      // Create enhanced conversation context for NLP processing
      const conversationContext = {
        conversationId: `conv_${req.user.id}_${Date.now()}`,
        userId: req.user.id,
        organizationId: req.tenant!.id,
        sessionStartTime: new Date(),
        conversationHistory: messages.map(msg => ({
          role: msg.type === 'user' ? 'user' as const : 'assistant' as const,
          content: msg.content,
          timestamp: new Date(msg.timestamp || Date.now()),
          intent: msg.intent,
          entities: msg.entities
        })),
        userProfile: {
          medicalHistory: [], // Could be fetched from patient records if available
          preferences: {},
          language: 'en',
          complexityLevel: 'intermediate' as const
        },
        contextualKnowledge: {
          recentTopics: [],
          extractedEntities: {},
          sentimentAnalysis: {
            overall: 'neutral' as const,
            confidence: 0.8
          }
        }
      };

      // Use local NLP processing directly
      const lastMessage = messages[messages.length - 1];
      
      // Process with local NLP fallback (call private method through a workaround)
      const nlpResult = await (aiService as any).processWithLocalNLP(lastMessage.content, conversationContext);
      
      // Use the response from local NLP directly
      let finalResponse = nlpResult.response;

      // Simple response structure compatible with the frontend
      const enhancedResponse = {
        response: finalResponse,
        intent: nlpResult.intent,
        entities: nlpResult.entities,
        confidence: nlpResult.confidence,
        medicalAdviceLevel: 'informational',
        disclaimers: ['This is an AI assistant and should not replace professional medical advice.'],
        followUpQuestions: ['How else can I help you today?'],
        educationalContent: [],
        urgencyLevel: 'low',
        recommendedSpecialty: null,
        nextActions: nlpResult.nextActions
      };

      res.json(enhancedResponse);
    } catch (error) {
      console.error("Chatbot error:", error);
      res.status(500).json({ error: "Failed to process chat message" });
    }
  });

  // Get chatbot context data
  app.get("/api/chatbot/context", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const doctors = await storage.getUsersByOrganization(req.tenant!.id);
      const availableDoctors = doctors
        .filter(doctor => isDoctorLike(doctor.role) && doctor.isActive)
        .map(doctor => ({
          id: doctor.id,
          name: `${doctor.firstName} ${doctor.lastName}`,
          specialty: doctor.department || 'General Medicine'
        }));

      // Get full user data for patient info
      const fullUser = await storage.getUser(req.user.id, req.tenant!.id);
      
      res.json({
        availableDoctors,
        patientInfo: {
          id: req.user.id,
          name: fullUser ? `${fullUser.firstName} ${fullUser.lastName}` : req.user.email,
          email: req.user.email
        }
      });
    } catch (error) {
      console.error("Error fetching chatbot context:", error);
      res.status(500).json({ error: "Failed to fetch chatbot context" });
    }
  });

  // Chatbot appointment booking endpoint
  app.post("/api/chatbot/book-appointment", async (req: TenantRequest, res) => {
    try {
      const { email, name, phone, appointmentType, preferredDate, preferredTime, reason } = req.body;

      // Get organization by subdomain
      const organization = await storage.getOrganizationBySubdomain('cura');
      if (!organization) {
        return res.status(404).json({ error: "Organization not found" });
      }

      // Find or create patient by email
      let patient = await storage.getPatientByEmail(email, organization.id);
      
      if (!patient) {
        // Create new patient
        const patientData = {
          organizationId: organization.id,
          firstName: name.split(' ')[0] || '',
          lastName: name.split(' ').slice(1).join(' ') || '',
          email: email,
          phone: phone,
          patientId: `P${Date.now()}`,
          isActive: true
        };
        patient = await storage.createPatient(patientData);
      }

      // Get available doctors
      const doctors = await storage.getUsersByRole('doctor', organization.id);
      const assignedDoctor = doctors.find(d => d.isActive) || doctors[0];

      if (!assignedDoctor) {
        return res.status(400).json({ error: "No doctors available" });
      }

      // Create appointment
      const appointmentData = {
        organizationId: organization.id,
        patientId: patient.id,
        providerId: assignedDoctor.id,
        appointmentType: appointmentType || 'consultation',
        status: 'pending',
        notes: reason || '',
        scheduledFor: new Date(`${preferredDate} ${preferredTime}`),
        duration: 30
      };

      const appointment = await storage.createAppointment(appointmentData);

      // Send confirmation email
      await emailService.sendAppointmentConfirmation({
        patientEmail: email,
        patientName: name,
        appointmentDate: preferredDate,
        appointmentTime: preferredTime,
        doctorName: `${assignedDoctor.firstName} ${assignedDoctor.lastName}`,
        appointmentType: appointmentType || 'consultation'
      });

      res.json({
        success: true,
        message: "Appointment booked successfully! You'll receive a confirmation email shortly.",
        appointmentId: appointment.id,
        doctorName: `${assignedDoctor.firstName} ${assignedDoctor.lastName}`,
        scheduledFor: appointmentData.scheduledFor
      });

    } catch (error) {
      console.error("Error booking appointment through chatbot:", error);
      res.status(500).json({ error: "Failed to book appointment" });
    }
  });

  // Chatbot prescription request endpoint
  app.post("/api/chatbot/request-prescription", async (req: TenantRequest, res) => {
    try {
      const { email, name, phone, medication, reason, medicalHistory } = req.body;

      // Get organization by subdomain
      const organization = await storage.getOrganizationBySubdomain('cura');
      if (!organization) {
        return res.status(404).json({ error: "Organization not found" });
      }

      // Find or create patient by email
      let patient = await storage.getPatientByEmail(email, organization.id);
      
      if (!patient) {
        // Create new patient
        const patientData = {
          organizationId: organization.id,
          firstName: name.split(' ')[0] || '',
          lastName: name.split(' ').slice(1).join(' ') || '',
          email: email,
          phone: phone,
          patientId: `P${Date.now()}`,
          isActive: true
        };
        patient = await storage.createPatient(patientData);
      }

      // Get available doctors
      const doctors = await storage.getUsersByRole('doctor', organization.id);
      const reviewingDoctor = doctors.find(d => d.isActive) || doctors[0];

      if (!reviewingDoctor) {
        return res.status(400).json({ error: "No doctors available" });
      }

      // Create prescription request (pending status)
      const prescriptionData = {
        organizationId: organization.id,
        patientId: patient.id,
        providerId: reviewingDoctor.id,
        prescriptionNumber: `RX${Date.now()}`,
        status: 'pending',
        medications: [{
          name: medication,
          dosage: '',
          frequency: '',
          duration: '',
          quantity: 0,
          refills: 0,
          instructions: reason,
          genericAllowed: true
        }]
      };

      const prescription = await storage.createPrescription(prescriptionData);

      // Send confirmation email
      await emailService.sendPrescriptionRequestConfirmation({
        patientEmail: email,
        patientName: name,
        medication: medication,
        doctorName: `${reviewingDoctor.firstName} ${reviewingDoctor.lastName}`,
        requestReason: reason
      });

      res.json({
        success: true,
        message: "Prescription request submitted successfully! Our medical team will review it within 24 hours.",
        requestId: prescription.id,
        reviewingDoctor: `${reviewingDoctor.firstName} ${reviewingDoctor.lastName}`,
        status: 'pending_review'
      });

    } catch (error) {
      console.error("Error requesting prescription through chatbot:", error);
      res.status(500).json({ error: "Failed to request prescription" });
    }
  });

  // ====== INVENTORY MANAGEMENT ROUTES ======
  
  // Categories
  app.get("/api/inventory/categories", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist", "pharmacist"]), async (req: TenantRequest, res) => {
    try {
      const categories = await inventoryService.getCategories(req.tenant!.id);
      res.json(categories);
    } catch (error) {
      console.error("Error fetching inventory categories:", error);
      res.status(500).json({ error: "Failed to fetch categories" });
    }
  });

  app.post("/api/inventory/categories", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const categoryData = z.object({
        name: z.string().min(1),
        description: z.string().optional(),
        parentCategoryId: z.number().optional()
      }).parse(req.body);

      const category = await inventoryService.createCategory({
        ...categoryData,
        organizationId: req.tenant!.id
      });

      res.status(201).json(category);
    } catch (error) {
      console.error("Error creating inventory category:", error);
      res.status(500).json({ error: "Failed to create category" });
    }
  });

  // Items
  app.get("/api/inventory/items", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist", "pharmacist"]), async (req: TenantRequest, res) => {
    try {
      const filters = {
        categoryId: req.query.categoryId ? parseInt(req.query.categoryId as string) : undefined,
        lowStock: req.query.lowStock === 'true',
        search: req.query.search as string,
        limit: req.query.limit ? parseInt(req.query.limit as string) : undefined
      };

      const items = await inventoryService.getItems(req.tenant!.id, filters);
      res.json(items);
    } catch (error) {
      console.error("Error fetching inventory items:", error);
      res.status(500).json({ error: "Failed to fetch items" });
    }
  });

  app.get("/api/inventory/items/:id", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist", "pharmacist"]), async (req: TenantRequest, res) => {
    try {
      const itemId = parseInt(req.params.id);
      const item = await inventoryService.getItem(itemId, req.tenant!.id);
      
      if (!item) {
        return res.status(404).json({ error: "Item not found" });
      }

      res.json(item);
    } catch (error) {
      console.error("Error fetching inventory item:", error);
      res.status(500).json({ error: "Failed to fetch item" });
    }
  });

  app.post("/api/inventory/items", authMiddleware, requireModulePermission('inventory', 'create'), async (req: TenantRequest, res) => {
    try {
      const itemData = z.object({
        categoryId: z.number(),
        name: z.string().min(1),
        description: z.string().optional(),
        sku: z.string().optional(),
        barcode: z.string().optional(),
        genericName: z.string().optional(),
        brandName: z.string().optional(),
        manufacturer: z.string().optional(),
        unitOfMeasurement: z.string().default("pieces"),
        packSize: z.number().default(1),
        purchasePrice: z.string().transform(val => val),
        salePrice: z.string().transform(val => val),
        mrp: z.string().optional().transform(val => val || null),
        taxRate: z.string().default("0.00"),
        currentStock: z.number().default(0),
        minimumStock: z.number().default(10),
        maximumStock: z.number().default(1000),
        reorderPoint: z.number().default(20),
        expiryTracking: z.boolean().default(false),
        batchTracking: z.boolean().default(false),
        prescriptionRequired: z.boolean().default(false),
        storageConditions: z.string().optional(),
        sideEffects: z.string().optional(),
        contraindications: z.string().optional(),
        dosageInstructions: z.string().optional()
      }).parse(req.body);

      // Generate SKU and barcode if not provided
      if (!itemData.sku) {
        itemData.sku = inventoryService.generateSKU("ITEM", itemData.name);
      }
      if (!itemData.barcode) {
        itemData.barcode = inventoryService.generateBarcode();
      }

      const item = await inventoryService.createItem({
        ...itemData,
        organizationId: req.tenant!.id
      });

      res.status(201).json(item);
    } catch (error) {
      console.error("Error creating inventory item:", error);
      res.status(500).json({ error: "Failed to create item" });
    }
  });

  app.patch("/api/inventory/items/:id", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const itemId = parseInt(req.params.id);
      const updates = req.body;

      const item = await inventoryService.updateItem(itemId, req.tenant!.id, updates);
      
      if (!item) {
        return res.status(404).json({ error: "Item not found" });
      }

      res.json(item);
    } catch (error) {
      console.error("Error updating inventory item:", error);
      res.status(500).json({ error: "Failed to update item" });
    }
  });

  // Delete Inventory Item
  app.delete("/api/inventory/items/:id", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const itemId = parseInt(req.params.id);
      console.log(`Deleting inventory item ${itemId} for organization ${req.tenant!.id}`);

      if (isNaN(itemId)) {
        return res.status(400).json({ error: "Invalid item ID" });
      }

      const deleted = await inventoryService.deleteItem(itemId, req.tenant!.id);
      
      if (!deleted) {
        console.log(`Item ${itemId} not found or already deleted`);
        return res.status(404).json({ error: "Item not found" });
      }

      console.log(`Item ${itemId} deleted successfully`);
      res.json({ 
        success: true, 
        message: "Item deleted successfully",
        id: itemId 
      });
    } catch (error) {
      console.error("Error deleting inventory item:", error);
      res.status(500).json({ error: "Failed to delete item" });
    }
  });

  // Stock Management
  app.post("/api/inventory/items/:id/stock", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const itemId = parseInt(req.params.id);
      const { quantity, movementType, notes } = z.object({
        quantity: z.number(),
        movementType: z.enum(["purchase", "sale", "adjustment", "transfer", "expired"]),
        notes: z.string().optional()
      }).parse(req.body);

      const result = await inventoryService.updateStock(
        itemId, 
        req.tenant!.id, 
        quantity, 
        movementType, 
        notes, 
        req.user!.id
      );

      res.json(result);
    } catch (error) {
      console.error("Error updating stock:", error);
      res.status(500).json({ error: "Failed to update stock" });
    }
  });

  // Suppliers
  app.get("/api/inventory/suppliers", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const suppliers = await inventoryService.getSuppliers(req.tenant!.id);
      res.json(suppliers);
    } catch (error) {
      console.error("Error fetching suppliers:", error);
      res.status(500).json({ error: "Failed to fetch suppliers" });
    }
  });

  app.post("/api/inventory/suppliers", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const supplierData = z.object({
        name: z.string().min(1),
        contactPerson: z.string().optional(),
        email: z.string().email().optional(),
        phone: z.string().optional(),
        address: z.string().optional(),
        city: z.string().optional(),
        country: z.string().default("UK"),
        taxId: z.string().optional(),
        paymentTerms: z.string().default("Net 30")
      }).parse(req.body);

      const supplier = await inventoryService.createSupplier({
        ...supplierData,
        organizationId: req.tenant!.id
      });

      res.status(201).json(supplier);
    } catch (error) {
      console.error("Error creating supplier:", error);
      res.status(500).json({ error: "Failed to create supplier" });
    }
  });

  // Purchase Orders
  app.get("/api/inventory/purchase-orders", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const status = req.query.status as string;
      const purchaseOrders = await inventoryService.getPurchaseOrders(req.tenant!.id, status);
      res.json(purchaseOrders);
    } catch (error) {
      console.error("Error fetching purchase orders:", error);
      res.status(500).json({ error: "Failed to fetch purchase orders" });
    }
  });

  app.get("/api/inventory/purchase-orders/:id", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const purchaseOrderId = parseInt(req.params.id);
      if (isNaN(purchaseOrderId)) {
        return res.status(400).json({ error: "Invalid purchase order ID" });
      }
      const purchaseOrder = await inventoryService.getPurchaseOrderById(purchaseOrderId, req.tenant!.id);
      if (!purchaseOrder) {
        return res.status(404).json({ error: "Purchase order not found" });
      }
      res.json(purchaseOrder);
    } catch (error) {
      console.error("Error fetching purchase order detail:", error);
      res.status(500).json({ error: "Failed to fetch purchase order detail" });
    }
  });

  app.post("/api/inventory/purchase-orders", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const orderData = z.object({
        supplierId: z.number(),
        expectedDeliveryDate: z.string().optional().transform(val => val ? new Date(val) : undefined),
        totalAmount: z.string().transform(val => val),
        taxAmount: z.string().default("0.00"),
        discountAmount: z.string().default("0.00"),
        notes: z.string().optional(),
        items: z.array(z.object({
          itemId: z.number(),
          quantity: z.number(),
          unitPrice: z.string().transform(val => val),
          totalPrice: z.string().transform(val => val)
        }))
      }).parse(req.body);

      // Generate PO number
      const poCount = (await inventoryService.getPurchaseOrders(req.tenant!.id)).length;
      const poNumber = `PO-${Date.now()}-${(poCount + 1).toString().padStart(4, '0')}`;

      const result = await inventoryService.createPurchaseOrder({
        ...orderData,
        organizationId: req.tenant!.id,
        poNumber,
        createdBy: req.user!.id
      }, orderData.items);

      res.status(201).json(result);
    } catch (error) {
      console.error("Error creating purchase order:", error);
      res.status(500).json({ error: "Failed to create purchase order" });
    }
  });

  // Send Purchase Order Email to Halo Pharmacy
  app.post("/api/inventory/purchase-orders/:id/send-email", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const purchaseOrderId = parseInt(req.params.id);
      
      await inventoryService.sendPurchaseOrderEmail(purchaseOrderId, req.tenant!.id);
      
      res.json({ 
        success: true, 
        message: "Purchase order sent to Halo Pharmacy successfully" 
      });
    } catch (error) {
      console.error("Error sending purchase order email:", error);
      res.status(500).json({ error: "Failed to send purchase order email" });
    }
  });

  // Delete Purchase Order
  app.delete("/api/inventory/purchase-orders/:id", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const purchaseOrderId = parseInt(req.params.id);
      
      if (isNaN(purchaseOrderId)) {
        return res.status(400).json({ error: "Invalid purchase order ID" });
      }

      await inventoryService.deletePurchaseOrder(purchaseOrderId, req.tenant!.id);
      
      res.json({ 
        success: true, 
        message: "Purchase order deleted successfully" 
      });
    } catch (error) {
      console.error("Error deleting purchase order:", error);
      res.status(500).json({ error: "Failed to delete purchase order" });
    }
  });

  // Stock Alerts
  app.get("/api/inventory/alerts", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const unreadOnly = req.query.unreadOnly === 'true';
      const alerts = await inventoryService.getStockAlerts(req.tenant!.id, unreadOnly);
      res.json(alerts);
    } catch (error) {
      console.error("Error fetching stock alerts:", error);
      res.status(500).json({ error: "Failed to fetch alerts" });
    }
  });

  // Inventory Reports
  app.get("/api/inventory/reports/value", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const inventoryValue = await inventoryService.getInventoryValue(req.tenant!.id);
      res.json(inventoryValue);
    } catch (error) {
      console.error("Error fetching inventory value:", error);
      res.status(500).json({ error: "Failed to fetch inventory value" });
    }
  });

  app.get("/api/inventory/reports/low-stock", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const lowStockItems = await inventoryService.getLowStockItems(req.tenant!.id);
      res.json(lowStockItems);
    } catch (error) {
      console.error("Error fetching low stock items:", error);
      res.status(500).json({ error: "Failed to fetch low stock items" });
    }
  });

  app.get("/api/inventory/reports/stock-movements", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const itemId = req.query.itemId ? parseInt(req.query.itemId as string) : undefined;
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 50;
      
      const movements = await inventoryService.getStockMovements(req.tenant!.id, itemId, limit);
      res.json(movements);
    } catch (error) {
      console.error("Error fetching stock movements:", error);
      res.status(500).json({ error: "Failed to fetch stock movements" });
    }
  });

  // Goods Receipts
  app.get("/api/inventory/goods-receipts", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const goodsReceipts = await inventoryService.getGoodsReceipts(req.tenant!.id);
      res.json(goodsReceipts);
    } catch (error) {
      console.error("Error fetching goods receipts:", error);
      res.status(500).json({ error: "Failed to fetch goods receipts" });
    }
  });

  app.get("/api/inventory/goods-receipts/:id", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const receiptId = parseInt(req.params.id);
      const receipt = await inventoryService.getGoodsReceiptById(receiptId, req.tenant!.id);
      if (!receipt) {
        return res.status(404).json({ error: "Goods receipt not found" });
      }
      res.json(receipt);
    } catch (error) {
      console.error("Error fetching goods receipt detail:", error);
      res.status(500).json({ error: "Failed to fetch goods receipt detail" });
    }
  });

  app.post("/api/inventory/goods-receipts", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const receiptData = z.object({
        purchaseOrderId: z.number(),
        receivedDate: z.string(),
        items: z.array(z.object({
          itemId: z.number(),
          quantityReceived: z.number(),
          batchNumber: z.string().optional(),
          expiryDate: z.string().optional()
        })),
        notes: z.string().optional()
      }).parse(req.body);

      const receipt = await inventoryService.createGoodsReceipt({
        ...receiptData,
        organizationId: req.tenant!.id
      });
      res.status(201).json(receipt);
    } catch (error) {
      console.error("Error creating goods receipt:", error);
      res.status(500).json({ error: "Failed to create goods receipt" });
    }
  });

  // Batches  
  app.get("/api/inventory/batches", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const batches = await inventoryService.getBatches(req.tenant!.id);
      res.json(batches);
    } catch (error) {
      console.error("Error fetching batches:", error);
      res.status(500).json({ error: "Failed to fetch batches" });
    }
  });

  // ====== PHARMACY SALES MODULE ROUTES ======

  // Get available batches for an item using FEFO
  app.get("/api/inventory/items/:itemId/batches-fefo", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist", "pharmacist"]), async (req: TenantRequest, res) => {
    try {
      const itemId = parseInt(req.params.itemId);
      const batches = await inventoryService.getAvailableBatchesFEFO(itemId, req.tenant!.id);
      res.json(batches);
    } catch (error) {
      console.error("Error fetching FEFO batches:", error);
      res.status(500).json({ error: "Failed to fetch available batches" });
    }
  });

  // Create a new sale (POS endpoint)
  app.post("/api/inventory/sales", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist", "pharmacist"]), async (req: TenantRequest, res) => {
    try {
      const saleData = z.object({
        patientId: z.number().optional(),
        saleType: z.enum(['walk_in', 'prescription']),
        customerName: z.string().optional(),
        customerPhone: z.string().optional(),
        prescriptionId: z.number().optional(),
        items: z.array(z.object({
          itemId: z.number(),
          quantity: z.number().min(1),
          discountPercent: z.number().min(0).max(100).optional()
        })),
        payments: z.array(z.object({
          method: z.enum(['cash', 'card', 'insurance', 'credit_note']),
          amount: z.number().min(0),
          cardLast4: z.string().optional(),
          cardType: z.string().optional(),
          authorizationCode: z.string().optional(),
          insuranceProviderId: z.number().optional(),
          claimNumber: z.string().optional()
        })),
        discountType: z.enum(['percentage', 'fixed']).optional(),
        discountAmount: z.number().optional(),
        notes: z.string().optional()
      }).parse(req.body);

      const sale = await inventoryService.createSale({
        ...saleData,
        organizationId: req.tenant!.id,
        soldBy: req.user!.id
      });

      res.status(201).json(sale);
    } catch (error: any) {
      console.error("Error creating sale:", error);
      res.status(400).json({ error: error.message || "Failed to create sale" });
    }
  });

  // Get all sales
  app.get("/api/inventory/sales", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist", "pharmacist"]), async (req: TenantRequest, res) => {
    try {
      const filters = {
        startDate: req.query.startDate ? new Date(req.query.startDate as string) : undefined,
        endDate: req.query.endDate ? new Date(req.query.endDate as string) : undefined,
        patientId: req.query.patientId ? parseInt(req.query.patientId as string) : undefined,
        status: req.query.status as string | undefined,
        limit: req.query.limit ? parseInt(req.query.limit as string) : 100
      };

      const sales = await inventoryService.getSales(req.tenant!.id, filters);
      res.json(sales);
    } catch (error) {
      console.error("Error fetching sales:", error);
      res.status(500).json({ error: "Failed to fetch sales" });
    }
  });

  // Get sale by ID with items and payments
  app.get("/api/inventory/sales/:id", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist", "pharmacist"]), async (req: TenantRequest, res) => {
    try {
      const saleId = parseInt(req.params.id);
      const sale = await inventoryService.getSaleById(saleId, req.tenant!.id);
      
      if (!sale) {
        return res.status(404).json({ error: "Sale not found" });
      }
      
      res.json(sale);
    } catch (error) {
      console.error("Error fetching sale:", error);
      res.status(500).json({ error: "Failed to fetch sale" });
    }
  });

  // Void a sale
  app.post("/api/inventory/sales/:id/void", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const saleId = parseInt(req.params.id);
      const { reason } = z.object({
        reason: z.string().min(5, "Void reason must be at least 5 characters")
      }).parse(req.body);

      const voidedSale = await inventoryService.voidSale(saleId, req.tenant!.id, reason, req.user!.id);
      res.json(voidedSale);
    } catch (error: any) {
      console.error("Error voiding sale:", error);
      res.status(400).json({ error: error.message || "Failed to void sale" });
    }
  });

  // Tax Rates
  app.get("/api/inventory/tax-rates", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const taxRates = await inventoryService.getTaxRates(req.tenant!.id);
      res.json(taxRates);
    } catch (error) {
      console.error("Error fetching tax rates:", error);
      res.status(500).json({ error: "Failed to fetch tax rates" });
    }
  });

  app.post("/api/inventory/tax-rates", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const taxData = z.object({
        name: z.string().min(1),
        code: z.string().min(1),
        rate: z.string(),
        description: z.string().optional(),
        isDefault: z.boolean().optional(),
        appliesTo: z.string().optional()
      }).parse(req.body);

      const taxRate = await inventoryService.createTaxRate({
        ...taxData,
        organizationId: req.tenant!.id
      });

      res.status(201).json(taxRate);
    } catch (error) {
      console.error("Error creating tax rate:", error);
      res.status(500).json({ error: "Failed to create tax rate" });
    }
  });

  // Insurance Providers
  app.get("/api/inventory/insurance-providers", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const providers = await inventoryService.getInsuranceProviders(req.tenant!.id);
      res.json(providers);
    } catch (error) {
      console.error("Error fetching insurance providers:", error);
      res.status(500).json({ error: "Failed to fetch insurance providers" });
    }
  });

  app.post("/api/inventory/insurance-providers", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const providerData = z.object({
        name: z.string().min(1),
        code: z.string().min(1),
        contactPerson: z.string().optional(),
        phone: z.string().optional(),
        email: z.string().email().optional(),
        address: z.string().optional(),
        defaultCoveragePercent: z.string().optional(),
        maxCoverageAmount: z.string().optional()
      }).parse(req.body);

      const provider = await inventoryService.createInsuranceProvider({
        ...providerData,
        organizationId: req.tenant!.id
      });

      res.status(201).json(provider);
    } catch (error) {
      console.error("Error creating insurance provider:", error);
      res.status(500).json({ error: "Failed to create insurance provider" });
    }
  });

  // ====== RETURNS MANAGEMENT MODULE ROUTES ======

  // Create a sales return
  app.post("/api/inventory/returns/sales", authMiddleware, requireNonPatientRole(), async (req: TenantRequest, res) => {
    try {
      const returnData = z.object({
        originalSaleId: z.number(),
        patientId: z.number().optional(),
        customerName: z.string().optional(),
        customerPhone: z.string().optional(),
        items: z.array(z.object({
          originalSaleItemId: z.number(),
          itemId: z.number(),
          batchId: z.number(),
          returnedQuantity: z.number().min(1),
          conditionOnReturn: z.enum(['sealed', 'opened', 'damaged', 'expired']),
          isRestockable: z.boolean()
        })),
        returnReason: z.string().min(1),
        returnReasonDetails: z.string().optional(),
        settlementType: z.enum(['refund', 'credit_note', 'exchange']),
        restockingFeePercent: z.number().min(0).max(100).optional(),
        internalNotes: z.string().optional()
      }).parse(req.body);

      const result = await inventoryService.createSalesReturn({
        ...returnData,
        organizationId: req.tenant!.id,
        initiatedBy: req.user!.id
      });

      res.status(201).json(result);
    } catch (error: any) {
      console.error("Error creating sales return:", error);
      res.status(400).json({ error: error.message || "Failed to create sales return" });
    }
  });

  // Get all returns
  app.get("/api/inventory/returns", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist", "pharmacist"]), async (req: TenantRequest, res) => {
    try {
      const filters = {
        returnType: req.query.returnType as 'sales_return' | 'purchase_return' | undefined,
        status: req.query.status as string | undefined,
        startDate: req.query.startDate ? new Date(req.query.startDate as string) : undefined,
        endDate: req.query.endDate ? new Date(req.query.endDate as string) : undefined,
        limit: req.query.limit ? parseInt(req.query.limit as string) : 100
      };

      const returns = await inventoryService.getReturns(req.tenant!.id, filters);
      res.json(returns);
    } catch (error) {
      console.error("Error fetching returns:", error);
      res.status(500).json({ error: "Failed to fetch returns" });
    }
  });

  // Get return by ID
  app.get("/api/inventory/returns/:id", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const returnId = parseInt(req.params.id);
      const returnRecord = await inventoryService.getReturnById(returnId, req.tenant!.id);
      
      if (!returnRecord) {
        return res.status(404).json({ error: "Return not found" });
      }
      
      res.json(returnRecord);
    } catch (error) {
      console.error("Error fetching return:", error);
      res.status(500).json({ error: "Failed to fetch return" });
    }
  });

  app.get("/api/inventory/purchase-orders/:id/items", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const purchaseOrderId = parseInt(req.params.id);
      const items = await inventoryService.getPurchaseOrderItems(purchaseOrderId, req.tenant!.id);
      res.json(items);
    } catch (error) {
      console.error("Error fetching purchase order items:", error);
      res.status(500).json({ error: "Failed to fetch purchase order items" });
    }
  });

  // Approve or reject a return
  app.post("/api/inventory/returns/:id/approval", authMiddleware, requireRole(["admin"]), async (req: TenantRequest, res) => {
    try {
      const returnId = parseInt(req.params.id);
      const { decision, notes } = z.object({
        decision: z.enum(['approved', 'rejected']),
        notes: z.string().optional()
      }).parse(req.body);

      const result = await inventoryService.processReturnApproval(
        returnId,
        req.tenant!.id,
        req.user!.id,
        decision,
        notes
      );

      res.json(result);
    } catch (error: any) {
      console.error("Error processing return approval:", error);
      res.status(400).json({ error: error.message || "Failed to process return approval" });
    }
  });

  // Credit Notes
  app.get("/api/inventory/credit-notes", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const filters = {
        patientId: req.query.patientId ? parseInt(req.query.patientId as string) : undefined,
        status: req.query.status as string | undefined,
        limit: req.query.limit ? parseInt(req.query.limit as string) : 100
      };

      const creditNotes = await inventoryService.getCreditNotes(req.tenant!.id, filters);
      res.json(creditNotes);
    } catch (error) {
      console.error("Error fetching credit notes:", error);
      res.status(500).json({ error: "Failed to fetch credit notes" });
    }
  });

  // Apply credit note to a sale
  app.post("/api/inventory/credit-notes/:id/apply", authMiddleware, requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const creditNoteId = parseInt(req.params.id);
      const { amount } = z.object({
        amount: z.number().min(0.01)
      }).parse(req.body);

      const result = await inventoryService.applyCreditNote(creditNoteId, req.tenant!.id, amount);
      res.json(result);
    } catch (error: any) {
      console.error("Error applying credit note:", error);
      res.status(400).json({ error: error.message || "Failed to apply credit note" });
    }
  });

  // Stock Adjustments
  app.get("/api/inventory/stock-adjustments", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const filters = {
        adjustmentType: req.query.adjustmentType as string | undefined,
        itemId: req.query.itemId ? parseInt(req.query.itemId as string) : undefined,
        startDate: req.query.startDate ? new Date(req.query.startDate as string) : undefined,
        endDate: req.query.endDate ? new Date(req.query.endDate as string) : undefined,
        limit: req.query.limit ? parseInt(req.query.limit as string) : 100
      };

      const adjustments = await inventoryService.getStockAdjustments(req.tenant!.id, filters);
      res.json(adjustments);
    } catch (error) {
      console.error("Error fetching stock adjustments:", error);
      res.status(500).json({ error: "Failed to fetch stock adjustments" });
    }
  });

  // Chatbot API Routes
  // Get chatbot configuration for organization
  app.get("/api/chatbot/config", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const config = await storage.getChatbotConfig(req.tenant!.id);
      res.json(config || null);
    } catch (error) {
      console.error("Error fetching chatbot config:", error);
      res.status(500).json({ error: "Failed to fetch chatbot configuration" });
    }
  });

  // Create or update chatbot configuration
  app.post("/api/chatbot/config", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const existingConfig = await storage.getChatbotConfig(req.tenant!.id);
      
      if (existingConfig) {
        // Update existing config
        const updated = await storage.updateChatbotConfig(req.tenant!.id, req.body);
        res.json(updated);
      } else {
        // Create new config
        const configData = {
          organizationId: req.tenant!.id,
          apiKey: crypto.randomUUID(),
          ...req.body
        };
        const created = await storage.createChatbotConfig(configData);
        res.json(created);
      }
    } catch (error) {
      console.error("Error saving chatbot config:", error);
      res.status(500).json({ error: "Failed to save chatbot configuration" });
    }
  });

  // Public chatbot endpoint (no auth required - for embedded widgets)
  app.post("/api/chatbot/message", async (req, res) => {
    try {
      const { sessionId, message, organizationId, apiKey } = req.body;

      // Validate API key
      const config = await storage.getChatbotConfig(organizationId);
      if (!config || config.apiKey !== apiKey || !config.isActive) {
        return res.status(401).json({ error: "Invalid API key or chatbot not active" });
      }

      // Get or create session
      let session = await storage.getChatbotSession(sessionId, organizationId);
      if (!session) {
        const sessionData = {
          organizationId,
          configId: config.id,
          sessionId,
          visitorId: crypto.randomUUID(),
          status: "active" as const
        };
        session = await storage.createChatbotSession(sessionData);
      }

      // Get conversation history for AI context
      const history = await storage.getChatbotMessagesBySession(session.id, organizationId);
      const sessionHistory = history.map(msg => ({
        sender: msg.sender,
        content: msg.content
      }));

      // Save user message
      const userMessage = {
        organizationId,
        sessionId: session.id,
        messageId: crypto.randomUUID(),
        sender: "user" as const,
        content: message,
        messageType: "text" as const
      };
      await storage.createChatbotMessage(userMessage);

      // Process message with AI
      const { chatbotAIService } = await import('./services/chatbot-ai.js');
      const aiResponse = await chatbotAIService.processMessage(message, sessionHistory);
      
      // Update session with extracted data
      if (aiResponse.intent.extractedData) {
        const updateData: any = {};
        if (aiResponse.intent.extractedData.patientName) {
          updateData.extractedPatientName = aiResponse.intent.extractedData.patientName;
        }
        if (aiResponse.intent.extractedData.phone) {
          updateData.extractedPhone = aiResponse.intent.extractedData.phone;
        }
        if (aiResponse.intent.extractedData.email) {
          updateData.extractedEmail = aiResponse.intent.extractedData.email;
        }
        updateData.currentIntent = aiResponse.intent.intent;
        
        if (Object.keys(updateData).length > 0) {
          await storage.updateChatbotSession(session.id, organizationId, updateData);
        }
      }
      
      // Save bot message with AI processing data
      const botMessage = {
        organizationId,
        sessionId: session.id,
        messageId: crypto.randomUUID(),
        sender: "bot" as const,
        content: aiResponse.response,
        messageType: "text" as const,
        intent: aiResponse.intent.intent,
        confidence: aiResponse.intent.confidence,
        aiProcessed: true
      };
      const savedBotMessage = await storage.createChatbotMessage(botMessage);

      res.json({
        sessionId: session.sessionId,
        response: aiResponse.response,
        messageId: savedBotMessage.messageId,
        intent: aiResponse.intent.intent,
        confidence: aiResponse.intent.confidence,
        requiresFollowUp: aiResponse.requiresFollowUp,
        nextAction: aiResponse.nextAction
      });
    } catch (error) {
      console.error("Error processing chatbot message:", error);
      res.status(500).json({ error: "Failed to process message" });
    }
  });

  // Get chat history for a session
  app.get("/api/chatbot/session/:sessionId/messages", async (req, res) => {
    try {
      const { sessionId } = req.params;
      const { organizationId, apiKey } = req.query;

      // Validate API key
      const config = await storage.getChatbotConfig(Number(organizationId));
      if (!config || config.apiKey !== apiKey) {
        return res.status(401).json({ error: "Invalid API key" });
      }

      const session = await storage.getChatbotSession(sessionId, Number(organizationId));
      if (!session) {
        return res.status(404).json({ error: "Session not found" });
      }

      const messages = await storage.getChatbotMessagesBySession(session.id, Number(organizationId));
      res.json(messages);
    } catch (error) {
      console.error("Error fetching chat history:", error);
      res.status(500).json({ error: "Failed to fetch chat history" });
    }
  });

  // Admin: Get chatbot analytics
  app.get("/api/chatbot/analytics", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const date = req.query.date ? new Date(req.query.date as string) : undefined;
      const analytics = await storage.getChatbotAnalytics(req.tenant!.id, date);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching chatbot analytics:", error);
      res.status(500).json({ error: "Failed to fetch analytics" });
    }
  });

  // Admin: Get chatbot sessions
  app.get("/api/chatbot/sessions", authMiddleware, requireRole(["admin", "doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 50;
      const sessions = await storage.getChatbotSessionsByOrganization(req.tenant!.id, limit);
      res.json(sessions);
    } catch (error) {
      console.error("Error fetching chatbot sessions:", error);
      res.status(500).json({ error: "Failed to fetch sessions" });
    }
  });

  // Billing & Invoice routes
  app.get("/api/billing/invoices", requireRole(["admin", "doctor", "nurse", "receptionist", "patient"]), async (req: TenantRequest, res) => {
    try {
      const { status } = req.query;
      
      console.log("üìã Fetching invoices for organization:", req.tenant!.id, "Status filter:", status);
      
      let invoices = await storage.getInvoicesByOrganization(
        req.tenant!.id,
        status as string | undefined
      );
      
      // Filter invoices for patient users - only show their own invoices
      if (req.user?.role === "patient") {
        // Find the patient record for this user to get their patientId string
        const patients = await storage.getPatientsByOrganization(req.tenant!.id);
        const userPatient = patients.find(p => p.email?.toLowerCase() === req.user!.email.toLowerCase());
        
        if (userPatient) {
          // Filter by patient's text patientId field (e.g., "P000007")
          invoices = invoices.filter(invoice => invoice.patientId === userPatient.patientId);
          console.log(`üîí Patient user ${req.user!.email} - filtered to ${invoices.length} invoices for patientId: ${userPatient.patientId}`);
        } else {
          invoices = [];
          console.log(`‚ö†Ô∏è No patient record found for user ${req.user!.email}`);
        }
      }
      
      console.log(`‚úÖ Found ${invoices.length} invoices`);
      res.json(invoices);
    } catch (error) {
      console.error("Invoices fetch error:", error);
      res.status(500).json({ error: "Failed to fetch invoices" });
    }
  });

  // Get doctor-specific invoices with table joins
  app.get("/api/billing/doctor-invoices", requireRole(["doctor"]), async (req: TenantRequest, res) => {
    try {
      const doctorUserId = req.user!.id;
      const organizationId = req.tenant!.id;
      
      console.log(`ü©∫ Fetching doctor-specific invoices for doctor ID: ${doctorUserId}, organization: ${organizationId}`);
      
      // Get the doctor's full name
      const doctor = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.id, doctorUserId))
        .limit(1);
      
      const doctorFullName = doctor[0] ? `${doctor[0].firstName} ${doctor[0].lastName}` : '';
      
      // Fetch all lab results for this doctor
      const doctorLabResults = await db
        .select()
        .from(schema.labResults)
        .where(
          and(
            eq(schema.labResults.organizationId, organizationId),
            eq(schema.labResults.orderedBy, doctorUserId)
          )
        );
      
      // Fetch all medical images for this doctor (uploaded by OR radiologist)
      const allOrgImages = await db
        .select()
        .from(schema.medicalImages)
        .where(eq(schema.medicalImages.organizationId, organizationId));
      
      const doctorImages = allOrgImages.filter(img => 
        img.uploadedBy === doctorUserId || img.radiologist === doctorFullName
      );
      
      // Fetch all appointments for this doctor
      const doctorAppointments = await db
        .select()
        .from(schema.appointments)
        .where(
          and(
            eq(schema.appointments.organizationId, organizationId),
            eq(schema.appointments.providerId, doctorUserId)
          )
        );
      
      // Get all invoices for the organization
      const allInvoices = await storage.getInvoicesByOrganization(organizationId);
      
      // Match invoices by service_id with the respective tables
      const labInvoices = allInvoices.filter(invoice => 
        invoice.serviceId && doctorLabResults.some(lr => lr.testId === invoice.serviceId)
      );
      
      const imagingInvoices = allInvoices.filter(invoice => {
        // Match by serviceId with image IDs
        const matchesImageId = invoice.serviceId && doctorImages.some(img => img.imageId === invoice.serviceId);
        // Also include any invoice with serviceType = 'medical_images' if doctor has imaging capability
        const isImagingInvoice = invoice.serviceType === 'medical_images' && doctorImages.length > 0;
        return matchesImageId || isImagingInvoice;
      });
      
      const appointmentInvoices = allInvoices.filter(invoice => 
        invoice.serviceId && doctorAppointments.some(apt => apt.appointmentId === invoice.serviceId)
      );
      
      // Overall: All unique invoices that match this doctor
      const allMatchingIds = new Set([
        ...labInvoices.map(i => i.id),
        ...imagingInvoices.map(i => i.id),
        ...appointmentInvoices.map(i => i.id)
      ]);
      
      const overallInvoices = allInvoices.filter(invoice => allMatchingIds.has(invoice.id));
      
      console.log(`‚úÖ Doctor invoices found - Overall: ${overallInvoices.length}, Appointments: ${appointmentInvoices.length}, Lab: ${labInvoices.length}, Imaging: ${imagingInvoices.length}`);
      
      res.json({
        overall: overallInvoices,
        appointments: appointmentInvoices,
        labResults: labInvoices,
        imaging: imagingInvoices
      });
    } catch (error) {
      console.error("Doctor invoices fetch error:", error);
      res.status(500).json({ error: "Failed to fetch doctor invoices" });
    }
  });

  app.post("/api/billing/invoices", requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const invoiceData = z.object({
        patientId: z.string().min(1, "Patient is required"),
        serviceDate: z.string().min(1, "Service date is required"),
        invoiceDate: z.string().min(1, "Invoice date is required"), 
        dueDate: z.string().min(1, "Due date is required"),
        totalAmount: z.string().min(1, "Total amount is required").refine(val => {
          const num = parseFloat(val);
          return !isNaN(num) && num > 0;
        }, "Total amount must be a valid number greater than 0"),
        firstServiceCode: z.string().min(1, "Service code is required"),
        firstServiceDesc: z.string().min(1, "Service description is required"),
        firstServiceQty: z.string().min(1, "Service quantity is required").refine(val => {
          const num = parseInt(val);
          return !isNaN(num) && num > 0;
        }, "Service quantity must be a valid number greater than 0"),
        firstServiceAmount: z.string().min(1, "Service amount is required").refine(val => {
          const num = parseFloat(val);
          return !isNaN(num) && num > 0;
        }, "Service amount must be a valid number greater than 0"),
        insuranceProvider: z.string().optional(),
        nhsNumber: z.string().optional(),
        notes: z.string().optional(),
        serviceId: z.union([z.number(), z.string()]).optional(),
        serviceType: z.string().optional(),
        paymentMethod: z.string().optional()
      }).parse(req.body);

      // Get patient name for the invoice
      const patient = await storage.getPatientByPatientId(invoiceData.patientId, req.tenant!.id);
      if (!patient) {
        return res.status(400).json({ error: "Patient not found" });
      }

      // Generate unique invoice number
      const invoiceNumber = `INV-${Date.now().toString().slice(-6)}`;

      // Detect invoice type based on insurance provider
      const invoiceType = invoiceData.insuranceProvider && invoiceData.insuranceProvider !== '' && invoiceData.insuranceProvider !== 'none' 
        ? 'insurance_claim' 
        : 'payment';

      // Generate insurance claim data if invoice type is insurance_claim
      const insuranceData = invoiceType === 'insurance_claim' ? {
        provider: invoiceData.insuranceProvider || 'NHS',
        claimNumber: `CLM${Date.now().toString().slice(-6)}`,
        status: 'approved',
        paidAmount: 0
      } : null;

      // Prepare invoice for database (with enforced created_by)
      const totalAmt = parseFloat(invoiceData.totalAmount);
      const invoiceToCreate = enforceCreatedBy(req, {
        organizationId: req.tenant!.id,
        patientId: invoiceData.patientId,
        patientName: `${patient.firstName} ${patient.lastName}`,
        nhsNumber: invoiceData.nhsNumber ? invoiceData.nhsNumber.replace(/\s+/g, '') : (patient.nhsNumber ? patient.nhsNumber.replace(/\s+/g, '') : null),
        invoiceNumber: invoiceNumber,
        invoiceDate: new Date(invoiceData.invoiceDate),
        dueDate: new Date(invoiceData.dueDate),
        dateOfService: new Date(invoiceData.serviceDate),
        status: "draft" as const,
        invoiceType: invoiceType,
        paymentMethod: invoiceData.paymentMethod || null,
        subtotal: totalAmt,
        tax: 0,
        discount: 0,
        totalAmount: totalAmt,
        paidAmount: 0,
        items: [
          {
            code: invoiceData.firstServiceCode,
            description: invoiceData.firstServiceDesc,
            quantity: parseInt(invoiceData.firstServiceQty) || 1,
            unitPrice: parseFloat(invoiceData.firstServiceAmount),
            total: parseFloat(invoiceData.firstServiceAmount)
          }
        ],
        notes: invoiceData.notes || null,
        insurance: insuranceData,
        payments: [],
        serviceId: invoiceData.serviceId || null,
        serviceType: invoiceData.serviceType || null
      });

      console.log("üìù Creating patient invoice in database:", invoiceNumber);
      const createdInvoice = await storage.createPatientInvoice(invoiceToCreate);
      console.log("‚úÖ Patient invoice created successfully:", createdInvoice.id);
      
      res.status(201).json(createdInvoice);
    } catch (error) {
      console.error("Invoice creation error:", error);
      res.status(500).json({ error: "Failed to create invoice" });
    }
  });

  // Update invoice status (patient role allowed for payment status updates)
  app.patch("/api/billing/invoices/:id", requireRole(["admin", "doctor", "nurse", "receptionist", "patient"]), async (req: TenantRequest, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;

      if (!status) {
        return res.status(400).json({ error: "Status is required" });
      }

      await storage.updateInvoice(parseInt(id), req.tenant!.id, { status });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to update invoice status:", error);
      res.status(500).json({ error: "Failed to update invoice status" });
    }
  });

  // Delete invoice
  app.delete("/api/billing/invoices/:id", requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const { id } = req.params;
      const invoiceId = parseInt(id);

      if (isNaN(invoiceId)) {
        return res.status(400).json({ error: "Invalid invoice ID" });
      }

      const deleted = await storage.deleteInvoice(invoiceId, req.tenant!.id);
      
      if (!deleted) {
        return res.status(404).json({ error: "Invoice not found" });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete invoice:", error);
      res.status(500).json({ error: "Failed to delete invoice" });
    }
  });

  // Get all payments for the organization
  app.get("/api/billing/payments", requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const payments = await storage.getPaymentsByOrganization(req.tenant!.id);
      console.log(`üí≥ Fetched ${payments.length} payments for organization ${req.tenant!.id}`);
      console.log("üí≥ Payment data:", JSON.stringify(payments, null, 2));
      res.json(payments);
    } catch (error) {
      console.error("Failed to fetch payments:", error);
      res.status(500).json({ error: "Failed to fetch payments" });
    }
  });

  // Create payment record
  app.post("/api/billing/payments", (req, res, next) => {
    console.log("üîµüîµüîµ PAYMENT ROUTE HIT - Body:", req.body);
    next();
  }, requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    console.log("üîµ Payment endpoint handler executing - req.body:", req.body);
    try {
      const validatedData = z.object({
        organizationId: z.number(),
        invoiceId: z.number(),
        patientId: z.string(),
        transactionId: z.string(),
        amount: z.number(),
        currency: z.string().default('GBP'),
        paymentMethod: z.string(),
        paymentProvider: z.string().optional(),
        paymentStatus: z.string().default('completed'),
        paymentDate: z.string(),
        reference: z.string().optional(),
        notes: z.string().optional(),
      }).parse(req.body);

      // Convert paymentDate string to Date object for Drizzle
      const paymentData = {
        ...validatedData,
        paymentDate: new Date(validatedData.paymentDate),
      };

      console.log("üí∞ Creating payment record:", paymentData);
      const createdPayment = await storage.createPayment(paymentData);
      console.log("‚úÖ Payment record created successfully:", createdPayment.id);
      
      res.status(201).json(createdPayment);
    } catch (error) {
      console.error("‚ùå Payment creation error:", error);
      res.status(500).json({ error: "Failed to create payment" });
    }
  });

  // Lab Test Cash Payment - Create invoice and payment record immediately
  app.post("/api/payments/cash", authMiddleware, multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      console.log('[CASH PAYMENT] Request received, body:', JSON.stringify(req.body, null, 2));
      const organizationId = requireOrgId(req);
      const { patient_id, patientName, items, totalAmount, insuranceProvider, serviceDate, invoiceDate, dueDate, serviceType, serviceId } = req.body;

      // Fetch patient record to get formatted patientId (e.g., P000001)
      const patientRecord = await storage.getPatient(patient_id, organizationId);
      if (!patientRecord) {
        return res.status(404).json({ error: "Patient not found" });
      }
      const formattedPatientId = patientRecord.patientId;

      // Generate unique invoice number
      const invoiceNumber = `INV-${Date.now()}-${Math.random().toString(36).substring(7).toUpperCase()}`;
      console.log('[CASH PAYMENT] Generated invoice number:', invoiceNumber);
      
      // Create invoice
      const invoiceData: any = {
        organizationId,
        invoiceNumber,
        patientId: formattedPatientId,
        patientName,
        dateOfService: new Date(serviceDate),
        invoiceDate: new Date(invoiceDate),
        dueDate: new Date(dueDate),
        status: 'paid',
        invoiceType: 'payment',
        subtotal: totalAmount,
        tax: 0,
        discount: 0,
        totalAmount: totalAmount,
        paidAmount: totalAmount,
        items: items.map((item: any) => ({
          code: item.code,
          description: item.description,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          total: item.total
        })),
        payments: [{
          id: `PAY-${Date.now()}`,
          amount: totalAmount,
          method: 'cash',
          date: new Date().toISOString(),
          reference: invoiceNumber
        }],
        notes: insuranceProvider ? `Insurance Provider: ${insuranceProvider}` : undefined,
        createdBy: req.user?.id
      };
      
      // Add polymorphic association fields if provided
      if (serviceType && serviceId) {
        invoiceData.serviceType = serviceType;
        invoiceData.serviceId = serviceId;
      }

      console.log('[CASH PAYMENT] Creating invoice...');
      const invoice = await storage.createPatientInvoice(invoiceData);
      console.log('[CASH PAYMENT] Invoice created:', invoice.id, invoice.invoiceNumber);

      // Create payment record
      const paymentData = {
        organizationId,
        invoiceId: invoice.id,
        patientId: formattedPatientId,
        transactionId: `CASH-${Date.now()}-${Math.random().toString(36).substring(7).toUpperCase()}`,
        amount: totalAmount,
        currency: 'GBP',
        paymentMethod: 'cash',
        paymentProvider: 'manual',
        paymentStatus: 'completed',
        paymentDate: new Date(),
        reference: invoiceNumber,
        metadata: {
          patientName: patientName
        },
        notes: `Cash payment for lab test invoice ${invoiceNumber}`
      };

      console.log('[CASH PAYMENT] Creating payment record...');
      const payment = await storage.createPayment(paymentData);
      console.log('[CASH PAYMENT] Payment created:', payment.id);

      const responseData = { 
        success: true, 
        invoice: {
          id: invoice.id,
          invoiceNumber: invoice.invoiceNumber
        },
        payment: {
          id: payment.id,
          transactionId: payment.transactionId
        }
      };
      
      console.log('[CASH PAYMENT] Sending response:', JSON.stringify(responseData, null, 2));
      res.setHeader('Content-Type', 'application/json');
      res.json(responseData);
    } catch (error) {
      console.error("[CASH PAYMENT] Error:", error);
      res.status(500).json({ error: "Failed to process cash payment" });
    }
  });

  // Lab Test Stripe Payment - Create payment intent
  app.post("/api/payments/stripe", authMiddleware, multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const { patient_id, patientName, amount, items, insuranceProvider, serviceDate, invoiceDate, dueDate, serviceType, serviceId } = req.body;

      // Fetch patient record to get formatted patientId (e.g., P000001)
      const patientRecord = await storage.getPatient(patient_id, organizationId);
      if (!patientRecord) {
        return res.status(404).json({ error: "Patient not found" });
      }
      const formattedPatientId = patientRecord.patientId;

      if (!stripe) {
        return res.status(503).json({ error: "Stripe is not configured" });
      }

      // Create payment intent
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amount * 100), // Convert to cents
        currency: 'gbp',
        metadata: {
          organizationId: organizationId.toString(),
          patientId: formattedPatientId,
          patientName,
          serviceDate,
          invoiceDate,
          dueDate,
          items: JSON.stringify(items),
          insuranceProvider: insuranceProvider || '',
          serviceType: serviceType || '',
          serviceId: serviceId || ''
        }
      });

      res.json({ 
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id
      });
    } catch (error) {
      console.error("Stripe payment intent error:", error);
      res.status(500).json({ error: "Failed to create payment intent" });
    }
  });

  // Lab Test Stripe Payment Confirmation - Create invoice and payment after successful charge
  app.post("/api/payments/stripe/confirm", authMiddleware, multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const { paymentIntentId } = req.body;

      if (!stripe) {
        return res.status(503).json({ error: "Stripe is not configured" });
      }

      // Retrieve payment intent to get metadata
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ error: "Payment not successful" });
      }

      const metadata = paymentIntent.metadata;
      const items = JSON.parse(metadata.items || '[]');
      const amount = paymentIntent.amount / 100; // Convert from cents

      // Generate unique invoice number
      const invoiceNumber = `INV-${Date.now()}-${Math.random().toString(36).substring(7).toUpperCase()}`;
      
      // Create invoice
      const invoiceData: any = {
        organizationId,
        invoiceNumber,
        patientId: metadata.patientId,
        patientName: metadata.patientName,
        dateOfService: new Date(metadata.serviceDate),
        invoiceDate: new Date(metadata.invoiceDate),
        dueDate: new Date(metadata.dueDate),
        status: 'paid',
        invoiceType: 'payment',
        subtotal: amount,
        tax: 0,
        discount: 0,
        totalAmount: amount,
        paidAmount: amount,
        balanceDue: 0,
        lineItems: items.map((item: any) => ({
          serviceCode: item.code,
          description: item.description,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          amount: item.total,
          billingType: 'lab_test'
        })),
        payments: [{
          id: paymentIntentId,
          amount: amount,
          method: 'card',
          date: new Date().toISOString(),
          reference: invoiceNumber
        }],
        notes: metadata.insuranceProvider ? `Insurance Provider: ${metadata.insuranceProvider}` : undefined,
        createdBy: req.user?.id
      };
      
      // Add polymorphic association fields if provided in metadata
      if (metadata.serviceType && metadata.serviceId) {
        invoiceData.serviceType = metadata.serviceType;
        invoiceData.serviceId = metadata.serviceId;
      }

      const invoice = await storage.createInvoice(invoiceData);

      // Send invoice creation notification to patient
      if (metadata.patientId) {
        const patient = await storage.getPatient(metadata.patientId, req.tenant!.id);
        
        if (patient && patient.userId) {
          await createNotification({
            organizationId: req.tenant!.id,
            userId: patient.userId,
            title: "Payment Received",
            message: `Invoice ${invoiceNumber} for ¬£${amount} has been paid successfully.`,
            type: "payment_due",
            priority: "normal",
            actionUrl: `/billing`,
            metadata: {
              patientId: patient.id,
              patientName: metadata.patientName || `${patient.firstName} ${patient.lastName}`,
              department: "Billing",
            }
          });
        }
      }

      // Create payment record
      const paymentData = {
        organizationId,
        invoiceId: invoice.id,
        patientId: metadata.patientId,
        transactionId: paymentIntentId,
        amount: amount,
        currency: 'gbp',
        paymentMethod: 'debit_card',
        paymentProvider: 'stripe',
        paymentStatus: 'completed',
        paymentDate: new Date(),
        reference: invoiceNumber,
        metadata: {
          patientName: metadata.patientName,
          stripePaymentIntentId: paymentIntentId,
          cardLast4: paymentIntent.charges.data[0]?.payment_method_details?.card?.last4
        },
        notes: `Stripe payment for lab test invoice ${invoiceNumber}`
      };

      const payment = await storage.createPayment(paymentData);

      res.json({ 
        success: true, 
        invoice: {
          id: invoice.id,
          invoiceNumber: invoice.invoiceNumber
        },
        payment: {
          id: payment.id,
          transactionId: payment.transactionId
        }
      });
    } catch (error) {
      console.error("Stripe payment confirmation error:", error);
      res.status(500).json({ error: "Failed to confirm payment" });
    }
  });

  // Create Stripe Payment Intent for invoice payment
  app.post("/api/billing/create-payment-intent", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { invoiceId } = req.body;

      if (!invoiceId) {
        return res.status(400).json({ error: "Invoice ID is required" });
      }

      // Get invoice details
      const invoices = await storage.getInvoicesByOrganization(req.tenant!.id);
      const invoice = invoices.find(inv => inv.id === Number(invoiceId));

      if (!invoice) {
        return res.status(404).json({ error: "Invoice not found" });
      }

      // Check if invoice is already paid
      if (invoice.status === 'paid') {
        return res.status(400).json({ error: "Invoice is already paid" });
      }

      // Calculate amount to pay (total - already paid)
      const totalAmount = typeof invoice.totalAmount === 'string' ? parseFloat(invoice.totalAmount) : invoice.totalAmount;
      const paidAmount = typeof invoice.paidAmount === 'string' ? parseFloat(invoice.paidAmount) : invoice.paidAmount;
      const amountToPay = totalAmount - paidAmount;

      if (amountToPay <= 0) {
        return res.status(400).json({ error: "Invoice is already fully paid" });
      }

      // Check if Stripe is configured
      if (!stripe) {
        return res.status(503).json({ error: "Payment processing is not configured. Please contact support." });
      }

      // Create Stripe payment intent
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amountToPay * 100), // Convert to pence/cents
        currency: "gbp",
        metadata: {
          invoiceId: invoice.id.toString(),
          patientId: invoice.patientId,
          organizationId: req.tenant!.id.toString(),
        },
        description: `Payment for Invoice ${invoice.invoiceNumber} - ${invoice.patientName}`,
      });

      res.json({ 
        clientSecret: paymentIntent.client_secret,
        amount: amountToPay,
        invoiceNumber: invoice.invoiceNumber,
        patientName: invoice.patientName
      });
    } catch (error: any) {
      console.error("Payment intent creation error:", error);
      
      // Handle Stripe-specific errors with user-friendly messages
      if (error.type === 'StripeAuthenticationError') {
        return res.status(500).json({ 
          error: "Payment system configuration error. Please contact support." 
        });
      }
      
      if (error.type === 'StripeInvalidRequestError') {
        return res.status(400).json({ 
          error: "Invalid payment request. Please try again." 
        });
      }
      
      // Generic error for other cases
      res.status(500).json({ 
        error: "Unable to process payment. Please try again or contact support." 
      });
    }
  });

  // Process successful payment and update invoice
  app.post("/api/billing/process-payment", authMiddleware, async (req: TenantRequest, res) => {
    try {
      const { paymentIntentId, invoiceId } = req.body;

      if (!paymentIntentId || !invoiceId) {
        return res.status(400).json({ error: "Payment intent ID and invoice ID are required" });
      }

      // Check if Stripe is configured
      if (!stripe) {
        return res.status(503).json({ error: "Payment processing is not configured. Please contact support." });
      }

      // Retrieve payment intent from Stripe to verify payment
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ error: "Payment not successful" });
      }

      // Get invoice details
      const invoices = await storage.getInvoicesByOrganization(req.tenant!.id);
      const invoice = invoices.find(inv => inv.id === Number(invoiceId));

      if (!invoice) {
        return res.status(404).json({ error: "Invoice not found" });
      }

      const paidAmount = paymentIntent.amount / 100; // Convert from pence/cents to pounds

      // Record payment in payments table
      const paymentData = {
        organizationId: req.tenant!.id,
        invoiceId: Number(invoiceId),
        patientId: invoice.patientId,
        transactionId: paymentIntentId,
        amount: paidAmount.toString(),
        currency: (paymentIntent.currency || 'gbp').toUpperCase(),
        paymentMethod: 'online',
        paymentProvider: 'stripe',
        paymentStatus: 'completed',
        paymentDate: new Date(),
        metadata: {
          stripePaymentIntentId: paymentIntentId,
          cardLast4: paymentIntent.charges?.data[0]?.payment_method_details?.card?.last4,
          cardBrand: paymentIntent.charges?.data[0]?.payment_method_details?.card?.brand,
          receiptUrl: paymentIntent.charges?.data[0]?.receipt_url,
        }
      };

      await storage.createPayment(paymentData);

      // Update invoice status to paid
      const currentPaidAmount = typeof invoice.paidAmount === 'string' ? parseFloat(invoice.paidAmount) : invoice.paidAmount;
      const totalAmount = typeof invoice.totalAmount === 'string' ? parseFloat(invoice.totalAmount) : invoice.totalAmount;
      const newPaidAmount = currentPaidAmount + paidAmount;

      await storage.updateInvoice(Number(invoiceId), req.tenant!.id, {
        status: 'paid',
        paidAmount: newPaidAmount.toString(),
        updatedAt: new Date(),
      });

      res.json({ 
        success: true, 
        message: "Payment processed successfully",
        receiptUrl: paymentIntent.charges?.data[0]?.receipt_url
      });
    } catch (error: any) {
      console.error("Payment processing error:", error);
      res.status(500).json({ error: error.message || "Failed to process payment" });
    }
  });

  // Send invoice via email
  app.post("/api/billing/send-invoice", requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const { invoiceId, sendMethod, recipientEmail, customMessage } = req.body;

      if (!invoiceId) {
        return res.status(400).json({ error: "Invoice ID is required" });
      }

      if (sendMethod === 'email' && !recipientEmail) {
        return res.status(400).json({ error: "Recipient email is required" });
      }

      // Get invoice details - convert invoiceId to number for comparison
      const id = Number(invoiceId);
      if (isNaN(id)) {
        return res.status(400).json({ error: "Invalid invoice ID" });
      }

      const invoices = await storage.getInvoicesByOrganization(req.tenant!.id);
      const invoice = invoices.find(inv => inv.id === id);

      if (!invoice) {
        return res.status(404).json({ error: "Invoice not found" });
      }

      if (sendMethod === 'email') {
        // Format dates
        const formatDate = (date: Date | string) => {
          const d = new Date(date);
          return d.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
        };

        // Parse total amount
        const totalAmount = typeof invoice.totalAmount === 'string' 
          ? parseFloat(invoice.totalAmount) 
          : invoice.totalAmount;

        // Build services table HTML
        const servicesTableRows = invoice.items.map((item: any) => `
          <tr>
            <td style="padding: 10px; border-bottom: 1px solid #e5e7eb;">${item.code || 'N/A'}</td>
            <td style="padding: 10px; border-bottom: 1px solid #e5e7eb;">${item.description}</td>
            <td style="padding: 10px; border-bottom: 1px solid #e5e7eb; text-align: center;">${item.quantity}</td>
            <td style="padding: 10px; border-bottom: 1px solid #e5e7eb; text-align: right;">¬£${parseFloat(item.unitPrice || 0).toFixed(2)}</td>
            <td style="padding: 10px; border-bottom: 1px solid #e5e7eb; text-align: right; font-weight: 600;">¬£${parseFloat(item.total || 0).toFixed(2)}</td>
          </tr>
        `).join('');

        // Build payment history HTML
        const paymentHistoryRows = invoice.payments && invoice.payments.length > 0 
          ? invoice.payments.map((payment: any) => `
            <div style="padding: 12px; background-color: #f0fdf4; border-left: 4px solid #4ade80; margin-bottom: 10px; border-radius: 4px;">
              Payment of ¬£${parseFloat(payment.amount || 0).toFixed(2)} received on ${formatDate(payment.date)}
            </div>
          `).join('')
          : '<div style="padding: 12px; background-color: #fef2f2; border-left: 4px solid #f87171; border-radius: 4px;">No payments recorded</div>';

        // Generate invoice email template
        const subject = `Invoice ${invoice.invoiceNumber} - ${invoice.patientName}`;
        const html = `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; background-color: #f3f4f6; margin: 0; padding: 0; }
              .container { max-width: 700px; margin: 20px auto; background-color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
              .header { background: linear-gradient(135deg, #4A7DFF 0%, #7279FB 100%); color: white; padding: 30px; text-align: center; }
              .header h1 { margin: 0; font-size: 28px; }
              .header h2 { margin: 10px 0 0 0; font-size: 18px; font-weight: 400; opacity: 0.95; }
              .content { padding: 30px; }
              .section { margin-bottom: 30px; }
              .section-title { font-size: 18px; font-weight: 600; color: #1f2937; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #4A7DFF; }
              .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
              .info-box { background-color: #f9fafb; padding: 15px; border-radius: 8px; }
              .info-box h3 { margin: 0 0 12px 0; font-size: 14px; color: #6b7280; font-weight: 500; }
              .info-box p { margin: 6px 0; font-size: 14px; }
              .info-box strong { color: #1f2937; }
              .status-badge { display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 600; text-transform: uppercase; }
              .status-paid { background-color: #d1fae5; color: #065f46; }
              .status-pending { background-color: #fef3c7; color: #92400e; }
              .status-partial { background-color: #dbeafe; color: #1e40af; }
              table { width: 100%; border-collapse: collapse; margin-top: 10px; }
              th { background-color: #f3f4f6; padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #4b5563; border-bottom: 2px solid #e5e7eb; }
              td { font-size: 14px; }
              .total-row { background-color: #f9fafb; font-weight: 600; }
              .footer { background-color: #f9fafb; padding: 20px; text-align: center; font-size: 12px; color: #6b7280; border-top: 1px solid #e5e7eb; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>Cura EMR</h1>
                <h2>Invoice Details - ${invoice.id}</h2>
              </div>
              <div class="content">
                <div class="section">
                  <p style="font-size: 16px; color: #374151;">Dear ${invoice.patientName},</p>
                  ${customMessage ? `<p style="font-size: 14px; color: #6b7280;">${customMessage}</p>` : '<p style="font-size: 14px; color: #6b7280;">Please find below your invoice details for services rendered. A PDF copy is attached for your records.</p>'}
                </div>

                <div class="info-grid">
                  <div class="info-box">
                    <h3>Patient Information</h3>
                    <p><strong>Name:</strong> ${invoice.patientName}</p>
                    <p><strong>Patient ID:</strong> ${invoice.patientId}</p>
                    <p><strong>Service Date:</strong> ${formatDate(invoice.dateOfService)}</p>
                    <p><strong>Invoice Date:</strong> ${formatDate(invoice.invoiceDate)}</p>
                    <p><strong>Due Date:</strong> ${formatDate(invoice.dueDate)}</p>
                  </div>
                  
                  <div class="info-box">
                    <h3>Billing Summary</h3>
                    <p><strong>Invoice ID:</strong> ${invoice.invoiceNumber}</p>
                    <p><strong>Status:</strong> <span class="status-badge status-${invoice.status}">${invoice.status}</span></p>
                    <p><strong>Total Amount:</strong> ¬£${totalAmount.toFixed(2)}</p>
                    <p><strong>Paid Amount:</strong> ¬£${parseFloat(invoice.paidAmount || 0).toFixed(2)}</p>
                    <p><strong>Outstanding:</strong> ¬£${(totalAmount - parseFloat(invoice.paidAmount || 0)).toFixed(2)}</p>
                  </div>
                </div>

                <div class="section">
                  <div class="section-title">Services & Procedures</div>
                  <table>
                    <thead>
                      <tr>
                        <th>Code</th>
                        <th>Description</th>
                        <th style="text-align: center;">Qty</th>
                        <th style="text-align: right;">Unit Price</th>
                        <th style="text-align: right;">Total</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${servicesTableRows}
                      <tr class="total-row">
                        <td colspan="4" style="padding: 12px; text-align: right;">Total Amount:</td>
                        <td style="padding: 12px; text-align: right; color: #4A7DFF; font-size: 16px;">¬£${totalAmount.toFixed(2)}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>

                <div class="section">
                  <div class="section-title">Payment History</div>
                  ${paymentHistoryRows}
                </div>

                <div style="margin-top: 30px; padding: 20px; background-color: #f0f9ff; border-left: 4px solid #4A7DFF; border-radius: 4px;">
                  <p style="margin: 0; font-size: 14px; color: #374151;">Thank you for choosing our healthcare services. If you have any questions about this invoice, please don't hesitate to contact us.</p>
                </div>

                <p style="margin-top: 30px; font-size: 14px; color: #374151;">Best regards,<br><strong>Cura EMR Team</strong></p>
              </div>
              <div class="footer">
                <p style="margin: 0;">¬© 2025 Cura EMR by Cura Software Limited. All rights reserved.</p>
              </div>
            </div>
          </body>
          </html>
        `;

        const text = `
Dear ${invoice.patientName},

${customMessage || 'Please find attached your invoice for services rendered.'}

Invoice Details:
Invoice Number: ${invoice.invoiceNumber}
Date: ${formatDate(invoice.invoiceDate)}
Due Date: ${formatDate(invoice.dueDate)}
Total Amount: ¬£${totalAmount.toFixed(2)}

Thank you for choosing our healthcare services.

Best regards,
Cura EMR Team
        `;

        // Check if PDF file exists for this invoice
        const fileName = `${invoice.invoiceNumber}.pdf`;
        const filePath = path.join(process.cwd(), 'uploads', 'Invoices', req.tenant!.id.toString(), invoice.patientId, fileName);
        
        console.log(`üìé Checking for PDF file at: ${filePath}`);
        console.log(`üìã Invoice details - Number: ${invoice.invoiceNumber}, Patient: ${invoice.patientId}, Org: ${req.tenant!.id}`);
        
        let attachments: any[] = [];
        try {
          // Check if file exists using fs.promises.access
          await access(filePath, fs.constants.F_OK);
          console.log('‚úÖ PDF file found! Reading file...');
          
          // Read the PDF file using fs/promises as a raw buffer
          const pdfBuffer = await readFile(filePath);
          console.log(`üìÑ PDF file size: ${pdfBuffer.length} bytes`);
          
          // Attach the PDF using the raw buffer (nodemailer will handle encoding)
          attachments.push({
            filename: `invoice-${invoice.invoiceNumber}.pdf`,
            content: pdfBuffer,
            contentType: 'application/pdf'
          });
          console.log('üìß PDF attachment prepared successfully');
        } catch (error: any) {
          // File doesn't exist - send email without attachment
          console.log('‚ùå No saved PDF found for invoice, sending email without attachment');
          console.log(`Error details: ${error.message}`);
        }
        
        // Send email using the email service
        const emailSent = await emailService.sendEmail({
          to: recipientEmail,
          subject,
          html,
          text,
          attachments
        });

        if (emailSent) {
          res.json({ success: true, message: "Invoice sent successfully" });
        } else {
          res.status(500).json({ error: "Failed to send invoice email" });
        }
      } else {
        // For SMS and print methods, just return success for now
        res.json({ success: true, message: "Invoice sent successfully" });
      }
    } catch (error) {
      console.error("Failed to send invoice:", error);
      res.status(500).json({ error: "Failed to send invoice" });
    }
  });

  // Save invoice PDF to server
  app.post("/api/billing/save-invoice-pdf", requireRole(["admin", "doctor", "nurse", "receptionist"]), async (req: TenantRequest, res) => {
    try {
      const { invoiceNumber, patientId, pdfData } = req.body;
      
      if (!invoiceNumber || !patientId || !pdfData) {
        return res.status(400).json({ error: "Invoice number, patient ID, and PDF data are required" });
      }

      const organizationId = req.tenant!.id;
      
      // Create file path: uploads/Invoices/{organization_id}/{patient_id}/{invoice_number}.pdf
      const fileName = `${invoiceNumber}.pdf`;
      const filePath = path.join(process.cwd(), 'uploads', 'Invoices', organizationId.toString(), patientId, fileName);
      
      // Convert base64 to buffer and save (outputFile creates directories automatically)
      const buffer = Buffer.from(pdfData, 'base64');
      await fse.outputFile(filePath, buffer);
      
      res.json({ 
        success: true, 
        message: "Invoice saved successfully",
        filePath: `uploads/Invoices/${organizationId}/${patientId}/${fileName}`
      });
    } catch (error) {
      console.error("Failed to save invoice PDF:", error);
      res.status(500).json({ error: "Failed to save invoice PDF" });
    }
  });

  // SaaS routes already registered above before tenant middleware

  const httpServer = createServer(app);
  
  console.log('[Socket.IO] Initializing Socket.IO server...');
  // Initialize Socket.IO server for real-time communication
  const io = new SocketIOServer(httpServer, {
    cors: {
      origin: "*", // In production, configure with specific origins
      methods: ["GET", "POST"],
      credentials: true
    },
    transports: ['websocket', 'polling'],
    pingTimeout: 60000,
    pingInterval: 25000
  });
  console.log('[Socket.IO] Socket.IO server initialized successfully');

  // Socket.IO connection handling
  const onlineUsers = new Map<string, Set<string>>(); // userId -> Set of socketIds

  io.on('connection', (socket) => {
    console.log('[Socket.IO] Client connected:', socket.id);

    // Handle user registration
    socket.on('add_user', (data: { userId: string; deviceId?: string }) => {
      const { userId, deviceId } = data;
      console.log('[Socket.IO] User registered:', userId, 'Socket:', socket.id);
      
      // Add user to online users map
      if (!onlineUsers.has(userId)) {
        onlineUsers.set(userId, new Set());
      }
      onlineUsers.get(userId)!.add(socket.id);
      
      // Store userId on socket for easy lookup
      socket.data.userId = userId;
      socket.data.deviceId = deviceId;
      
      // Broadcast updated online users list
      const onlineUserIds = Array.from(onlineUsers.keys());
      io.emit('online_users_update', { onlineUsers: onlineUserIds });
      console.log('[Socket.IO] Online users:', onlineUserIds.length);
    });

    // Handle call signaling
    socket.on('call-signal', (signal: any) => {
      console.log('[Socket.IO] Call signal:', signal.type, 'from', signal.from, 'to', signal.to);
      // Forward signal to the recipient
      io.emit('call-signal', signal);
    });

    // Handle incoming call
    socket.on('incoming-call', (callData: any) => {
      console.log('[Socket.IO] Incoming call from', callData.from, 'to', callData.to);
      io.emit('incoming-call', callData);
    });

    // Handle call end
    socket.on('call-ended', (data: any) => {
      console.log('[Socket.IO] Call ended:', data);
      io.emit('call-ended', data);
    });

    // Handle user registration (Averox-style)
    socket.on('register-user', (data: { userId: string; userName: string }) => {
      const { userId, userName } = data;
      console.log('[Socket.IO] User registered (Averox-style):', userId, userName);
      
      socket.data.userId = userId;
      socket.data.userName = userName;
      
      // Add to online users
      if (!onlineUsers.has(userId)) {
        onlineUsers.set(userId, new Set());
      }
      onlineUsers.get(userId)!.add(socket.id);
      
      // Broadcast updated online users
      const onlineUserIds = Array.from(onlineUsers.keys());
      io.emit('online_users_update', { onlineUsers: onlineUserIds });
    });

    // Handle disconnect
    socket.on('disconnect', () => {
      const userId = socket.data.userId;
      console.log('[Socket.IO] Client disconnected:', socket.id, 'User:', userId);
      
      if (userId && onlineUsers.has(userId)) {
        onlineUsers.get(userId)!.delete(socket.id);
        if (onlineUsers.get(userId)!.size === 0) {
          onlineUsers.delete(userId);
        }
        
        // Broadcast updated online users list
        const onlineUserIds = Array.from(onlineUsers.keys());
        io.emit('online_users_update', { onlineUsers: onlineUserIds });
      }
    });
  });

  // Store Socket.IO instance on app for use in routes
  app.set('io', io);
  
  // Start appointment reminder scheduler
  startAppointmentReminderScheduler();
  
  // HTML Generator for PDF Reports
  function generateReportHTML(study: any, reportFormData: any = {}) {
    const currentDate = new Date().toLocaleDateString('en-GB');
    const currentDateTime = new Date().toLocaleString('en-GB');
    
    return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Radiology Report</title>
    <style>
        @page { 
            margin: 0.5in; 
            size: A4;
        }
        body { 
            font-family: 'Helvetica', 'Arial', sans-serif; 
            font-size: 8pt; 
            line-height: 1.3; 
            margin: 0; 
            color: #000;
        }
        .header { 
            padding: 8px; 
            text-align: center; 
            margin-bottom: 15px;
        }
        .header h1 { 
            font-size: 16pt; 
            font-weight: bold; 
            color: #1e3a8a; 
            margin: 5px 0;
        }
        .header h2 { 
            font-size: 10pt; 
            color: #666; 
            margin: 3px 0;
        }
        .info-section { 
            padding: 8px; 
            margin-bottom: 12px;
        }
        .info-header { 
            font-size: 9pt; 
            font-weight: bold; 
            margin-bottom: 5px;
        }
        .info-row { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 3px;
        }
        .info-label { 
            font-weight: bold; 
            margin-right: 10px;
        }
        .section-title { 
            font-size: 9pt; 
            font-weight: bold; 
            margin: 15px 0 5px 0; 
            color: #1e3a8a;
        }
        .content { 
            margin-left: 5px; 
            margin-bottom: 8px;
        }
        .image-placeholder {
            width: 100px;
            height: 70px;
            margin: 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        .image-text {
            font-size: 8pt;
            color: #1e3a8a;
            font-weight: bold;
        }
        .footer { 
            color: #1e3a8a; 
            padding: 6px 10px; 
            font-size: 7pt; 
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
        }
        .signature-section {
            margin-top: 15px;
            padding-top: 8px;
        }
        .signature-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>CURA MEDICAL CENTER</h1>
        <h2>RADIOLOGY DIAGNOSTIC REPORT</h2>
    </div>
    <div style="border-bottom: 1px solid #9ca3af; margin-bottom: 15px;"></div>

    <div class="info-section">
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
            <div style="flex: 1; margin-right: 30px;">
                <div class="info-header">PATIENT INFORMATION</div>
                <div style="margin-top: 5px;">
                    <div><span class="info-label">Name:</span> ${study.patientName || 'N/A'}</div>
                    <div><span class="info-label">ID:</span> ${study.patientId || 'N/A'}</div>
                    <div><span class="info-label">Date:</span> ${currentDate}</div>
                </div>
            </div>
            <div style="flex: 1;">
                <div class="info-header">STUDY INFORMATION</div>
                <div style="margin-top: 5px;">
                    <div><span class="info-label">Study:</span> ${study.studyType || 'N/A'}</div>
                    <div><span class="info-label">Modality:</span> ${study.modality || 'N/A'}</div>
                    <div><span class="info-label">Body Part:</span> ${study.bodyPart || 'N/A'}</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-title">CLINICAL INDICATION:</div>
    <div class="content">${study.indication || 'Clinical evaluation requested'}</div>

    <div class="section-title">TECHNIQUE:</div>
    <div class="content">${study.modality || 'Imaging'} imaging of the ${study.bodyPart || 'target area'} performed per standard protocol.</div>

    <div class="section-title">FINDINGS:</div>
    <div class="content">${reportFormData.findings || study.findings || 'Normal anatomical structures within imaging field. No acute abnormalities identified. Bone structures intact with no fracture or dislocation. Soft tissues show normal characteristics.'}</div>

    <div class="section-title">IMPRESSION:</div>
    <div class="content">${reportFormData.impression || study.impression || 'Normal study. No acute findings.'}</div>

    <div class="signature-section">
        <div class="signature-row">
            <span><span class="info-label">REPORTED BY:</span> ${reportFormData.radiologist || study.radiologist || "Dr. Sarah Johnson"}</span>
            <span><span class="info-label">Date:</span> ${currentDateTime}</span>
        </div>
        <div class="signature-row">
            <span style="margin-left: 80px;">MD, Diagnostic Radiology</span>
            <span>License #: MD-RAD-2024</span>
        </div>
    </div>

    <div style="margin-top: 25px; padding-top: 15px; border-top: 1px solid #e5e5e5;">
        <div class="section-title">REPRESENTATIVE IMAGES:</div>
        <div class="image-placeholder">
            <div>
                <div class="image-text">MEDICAL IMAGE</div>
                <div style="font-size: 7pt; color: #666; margin-top: 5px;">
                    ${study.images && study.images[0] ? study.images[0].fileName || study.images[0].seriesDescription || 'Imaging Study' : 'Medical Study'}<br>
                    Image Available
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <span>Cura Medical Center | Radiology Department</span>
        <span>Tel: +44-123-456-7890 | Email: radiology@curamedical.com</span>
    </div>
    
    <div style="text-align: center; font-size: 6pt; color: #1e3a8a; padding: 3px; margin-top: -10px;">
        CONFIDENTIAL MEDICAL REPORT - For authorized personnel only
    </div>
</body>
</html>`;
  }

  // PDF Report Generation Endpoint
  app.post("/api/imaging/generate-report", authMiddleware, requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { study, reportFormData, imageData, uploadedImageFileNames } = req.body;
      
      if (!study || !study.patientName) {
        return res.status(400).json({ error: "Study data is required" });
      }

      // Get the actual medical image from database to ensure we use the correct image_id and patient_id
      const imageId = parseInt(study.id);
      const medicalImage = await storage.getMedicalImage(imageId, req.tenant!.id);
      if (!medicalImage) {
        return res.status(404).json({ error: "Medical image not found" });
      }
      
      // Use image_id from database as PDF filename (e.g., IMG1760647135I10NC.pdf)
      const reportId = medicalImage.imageId;
      const patientId = medicalImage.patientId; // Use numeric database patient ID
      const organizationId = req.organizationId || req.tenant!.id;
      
      // Save PDF in organizational structure: uploads/Imaging_Reports/organization_id/patients/patient_id/
      const reportsDir = path.resolve(process.cwd(), 'uploads', 'Imaging_Reports', String(organizationId), 'patients', String(patientId));
      await fse.ensureDir(reportsDir);
      
      // Fetch clinic headers and footers from database
      const clinicHeader = await storage.getActiveClinicHeader(organizationId);
      const clinicFooter = await storage.getActiveClinicFooter(organizationId);
      
      // Import pdf-lib dynamically
      const { PDFDocument, rgb, StandardFonts } = await import('pdf-lib');
      
      // Create a new PDF document
      const pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage([595, 842]); // A4 size in points
      const { width, height } = page.getSize();
      
      // Load fonts
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
      
      // Colors
      const primaryBlue = rgb(0.12, 0.23, 0.54); // #1e3a8a
      const lightGray = rgb(0.95, 0.95, 0.95); // Light background
      const darkGray = rgb(0.3, 0.3, 0.3);
      const blackColor = rgb(0, 0, 0);
      
      // Helper function to draw a section box (borders and background removed)
      const drawSectionBox = (x: number, y: number, width: number, height: number) => {
        // No borders or background - content only
      };
      
      // Position tracker
      let yPosition = height - 40;
      
      // Professional Formal Header with Logo and Clinic Info in a Row
      const headerHeight = 100;
      const logoX = 40;
      const logoWidth = 80;
      const logoHeight = 80;
      
      // Embed logo from clinic_headers if available
      if (clinicHeader?.logoBase64) {
        try {
          // Remove data URL prefix if present
          const base64Data = clinicHeader.logoBase64.includes(',') 
            ? clinicHeader.logoBase64.split(',')[1] 
            : clinicHeader.logoBase64;
          const logoBuffer = Buffer.from(base64Data, 'base64');
          
          // Try to embed logo as PNG or JPEG
          let logoImage;
          try {
            logoImage = await pdfDoc.embedPng(logoBuffer);
          } catch {
            try {
              logoImage = await pdfDoc.embedJpg(logoBuffer);
            } catch (error) {
              console.error('Failed to embed logo:', error);
            }
          }
          
          if (logoImage) {
            // Draw logo with equal height to header info
            page.drawImage(logoImage, {
              x: logoX,
              y: yPosition - logoHeight - 10,
              width: logoWidth,
              height: logoHeight
            });
          }
        } catch (error) {
          console.error('Error processing logo:', error);
        }
      } else {
        // Fallback: Medical cross symbol if no logo
        page.drawText('+', {
          x: logoX + 20,
          y: yPosition - 55,
          size: 32,
          font: boldFont,
          color: primaryBlue
        });
      }
      
      // Header information (clinic name, address, phone) - to the right of logo
      const headerInfoX = logoX + logoWidth + 20;
      let headerY = yPosition - 20;
      
      // Clinic name
      const clinicName = clinicHeader?.clinicName || 'CURA MEDICAL CENTER';
      page.drawText(clinicName, {
        x: headerInfoX,
        y: headerY,
        size: 16,
        font: boldFont,
        color: primaryBlue
      });
      headerY -= 18;
      
      // Department
      page.drawText('DEPARTMENT OF DIAGNOSTIC RADIOLOGY', {
        x: headerInfoX,
        y: headerY,
        size: 11,
        font,
        color: darkGray
      });
      headerY -= 14;
      
      // Address
      const address = clinicHeader?.address || 'Ground Floor Unit 2, Drayton Court, Drayton Road, Solihull, England B90 4NG';
      page.drawText(address, {
        x: headerInfoX,
        y: headerY,
        size: 8,
        font,
        color: darkGray
      });
      headerY -= 13;
      
      // Phone and email
      const phone = clinicHeader?.phone || '+44-123-456-7890';
      const email = clinicHeader?.email || 'info@curamedical.com';
      page.drawText(`Tel: ${phone} | Fax: ${phone}`, {
        x: headerInfoX,
        y: headerY,
        size: 8,
        font,
        color: darkGray
      });
      
      yPosition -= headerHeight;
      
      // Report title in separate row (centered)
      yPosition -= 10;
      page.drawText('DIAGNOSTIC RADIOLOGY REPORT', {
        x: width / 2 - 100,
        y: yPosition,
        size: 14,
        font: boldFont,
        color: primaryBlue
      });
      
      yPosition -= 30;
      
      // Save starting position for both sections (equal alignment)
      const sectionsStartY = yPosition;
      
      // Patient Information Section (Left side)
      drawSectionBox(30, sectionsStartY + 5, (width - 80) / 2, 120);
      page.drawText('PATIENT INFORMATION', {
        x: 40,
        y: sectionsStartY - 10,
        size: 12,
        font: boldFont,
        color: primaryBlue
      });
      
      let leftColumnY = sectionsStartY - 30;
      page.drawText(`Name: ${study.patientName}`, { x: 50, y: leftColumnY, size: 10, font });
      leftColumnY -= 15;
      page.drawText(`ID: ${study.patientId || 'N/A'}`, { x: 50, y: leftColumnY, size: 10, font });
      leftColumnY -= 15;
      page.drawText(`DOB: ${study.patientDOB || 'N/A'}`, { x: 50, y: leftColumnY, size: 10, font });
      leftColumnY -= 15;
      page.drawText(`Study Date: ${new Date().toLocaleDateString()}`, { x: 50, y: leftColumnY, size: 10, font });
      
      // Study Information Section (Right side) - SAME Y POSITION for equal alignment
      const rightColumnX = width / 2 + 10;
      drawSectionBox(rightColumnX, sectionsStartY + 5, (width - 80) / 2, 120);
      page.drawText('STUDY INFORMATION', {
        x: rightColumnX + 10,
        y: sectionsStartY - 10,
        size: 12,
        font: boldFont,
        color: primaryBlue
      });
      
      let rightColumnY = sectionsStartY - 30;
      page.drawText(`Study Type: ${study.studyType}`, { x: rightColumnX + 20, y: rightColumnY, size: 10, font });
      rightColumnY -= 15;
      page.drawText(`Body Part: ${study.bodyPart}`, { x: rightColumnX + 20, y: rightColumnY, size: 10, font });
      rightColumnY -= 15;
      page.drawText(`Modality: ${study.modality}`, { x: rightColumnX + 20, y: rightColumnY, size: 10, font });
      rightColumnY -= 15;
      page.drawText(`Status: ${study.status || 'Complete'}`, { x: rightColumnX + 20, y: rightColumnY, size: 10, font });
      rightColumnY -= 15;
      
      // Add Ordered, Scheduled, and Performed dates
      const orderedDate = study.orderedAt ? new Date(study.orderedAt).toLocaleDateString() : 'N/A';
      page.drawText(`Ordered: ${orderedDate}`, { x: rightColumnX + 20, y: rightColumnY, size: 10, font });
      rightColumnY -= 15;
      
      if (reportFormData?.scheduledAt) {
        const scheduledDate = new Date(reportFormData.scheduledAt).toLocaleDateString();
        page.drawText(`Scheduled: ${scheduledDate}`, { x: rightColumnX + 20, y: rightColumnY, size: 10, font });
        rightColumnY -= 15;
      }
      
      if (reportFormData?.performedAt) {
        const performedDate = new Date(reportFormData.performedAt).toLocaleDateString();
        page.drawText(`Performed: ${performedDate}`, { x: rightColumnX + 20, y: rightColumnY, size: 10, font });
        rightColumnY -= 15;
      }
      
      yPosition = sectionsStartY - 130;
      
      if (reportFormData) {
        yPosition -= 20;
        
        // Clinical sections with professional formatting
        const clinicalSections = [
          { title: 'CLINICAL INDICATION', content: reportFormData.clinicalIndication },
          { title: 'TECHNIQUE', content: reportFormData.technique },
          { title: 'FINDINGS', content: reportFormData.findings },
          { title: 'IMPRESSION', content: reportFormData.impression }
        ];
        
        clinicalSections.forEach(section => {
          if (section.content) {
            // Calculate section height for text wrapping
            const maxLineLength = 70;
            const lines = section.content.match(new RegExp(`.{1,${maxLineLength}}(\\s|$)`, 'g')) || [section.content];
            const sectionHeight = Math.max(60, lines.length * 15 + 40);
            
            // Draw section background
            drawSectionBox(30, yPosition + 10, width - 60, sectionHeight);
            
            page.drawText(section.title, {
              x: 40,
              y: yPosition - 5,
              size: 12,
              font: boldFont,
              color: primaryBlue
            });
            
            // Draw content with text wrapping
            let textY = yPosition - 25;
            lines.forEach((line: string) => {
              page.drawText(line.trim(), { 
                x: 50, 
                y: textY, 
                size: 10, 
                font,
                maxWidth: width - 100
              });
              textY -= 15;
            });
            
            yPosition -= sectionHeight + 10;
          }
        });
      } else {
        // Add indication and findings from study data if no form data
        yPosition -= 20;
        
        if (study.indication) {
          drawSectionBox(30, yPosition + 10, width - 60, 50);
          page.drawText('CLINICAL INDICATION', {
            x: 40,
            y: yPosition - 5,
            size: 12,
            font: boldFont,
            color: primaryBlue
          });
          page.drawText(study.indication, { x: 50, y: yPosition - 25, size: 10, font });
          yPosition -= 70;
        }
        
        if (study.findings) {
          drawSectionBox(30, yPosition + 10, width - 60, 50);
          page.drawText('FINDINGS', {
            x: 40,
            y: yPosition - 5,
            size: 12,
            font: boldFont,
            color: primaryBlue
          });
          page.drawText(study.findings, { x: 50, y: yPosition - 25, size: 10, font });
          yPosition -= 70;
        }
      }
      
      // Professional Signature Section
      yPosition -= 20;
      const signatureHeight = 120;
      drawSectionBox(30, yPosition + 10, width - 60, signatureHeight);
      
      page.drawText('RADIOLOGIST REPORT', {
        x: 40,
        y: yPosition - 5,
        size: 12,
        font: boldFont,
        color: primaryBlue
      });
      
      // Radiologist information
      const radiologistName = reportFormData?.radiologist || study.radiologist || "Dr. Sarah Johnson, MD";
      page.drawText(`Reported by: ${radiologistName}`, { 
        x: 50, 
        y: yPosition - 30, 
        size: 11, 
        font: boldFont,
        color: blackColor
      });
      
      page.drawText('Board Certified Diagnostic Radiologist', { 
        x: 50, 
        y: yPosition - 45, 
        size: 10, 
        font,
        color: darkGray
      });
      
      page.drawText('Medical License: MD-RAD-2024', { 
        x: 50, 
        y: yPosition - 60, 
        size: 10, 
        font,
        color: darkGray
      });
      
      // Report completion info
      const reportDate = new Date().toLocaleDateString('en-GB', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
      page.drawText(`Report Date: ${reportDate}`, { 
        x: width - 250, 
        y: yPosition - 30, 
        size: 10, 
        font,
        color: darkGray
      });
      
      page.drawText(`Report ID: ${reportId}`, { 
        x: width - 250, 
        y: yPosition - 45, 
        size: 9, 
        font,
        color: rgb(0.6, 0.6, 0.6)
      });
      
      // Digital signature placeholder removed
      
      // Ensure proper spacing between radiologist report and medical image sections
      yPosition -= 80; // Increased spacing to prevent overlap
      
      // E-Signature Section (if signature data provided)
      const { signatureData, signatureDate } = req.body;
      if (signatureData) {
        yPosition -= 20;
        
        // Signature section title
        page.drawText('Resident Physician (Signature)', {
          x: 40,
          y: yPosition,
          size: 10,
          font: boldFont,
          color: blackColor
        });
        
        yPosition -= 10;
        
        try {
          // Remove data URL prefix if present
          const base64Data = signatureData.includes(',') 
            ? signatureData.split(',')[1] 
            : signatureData;
          const signatureBuffer = Buffer.from(base64Data, 'base64');
          
          // Try to embed signature as PNG first, then JPEG
          let signatureImage;
          try {
            signatureImage = await pdfDoc.embedPng(signatureBuffer);
          } catch {
            try {
              signatureImage = await pdfDoc.embedJpg(signatureBuffer);
            } catch (error) {
              console.error('Failed to embed signature:', error);
            }
          }
          
          if (signatureImage) {
            // Draw signature box (120√ó50 pixels = smaller compact size)
            const signatureBoxWidth = 120 * 0.75; // Convert px to points (72 DPI = 0.75 factor)
            const signatureBoxHeight = 50 * 0.75;
            
            // Draw border
            page.drawRectangle({
              x: 40,
              y: yPosition - signatureBoxHeight - 5,
              width: signatureBoxWidth,
              height: signatureBoxHeight,
              borderColor: rgb(0.7, 0.7, 0.7),
              borderWidth: 1,
            });
            
            // Draw signature image inside the box
            page.drawImage(signatureImage, {
              x: 42,
              y: yPosition - signatureBoxHeight - 3,
              width: signatureBoxWidth - 4,
              height: signatureBoxHeight - 4,
            });
            
            yPosition -= signatureBoxHeight + 10;
            
            // Add green timestamp
            const signatureDateStr = signatureDate 
              ? new Date(signatureDate).toLocaleDateString('en-US', { 
                  month: 'short',
                  day: 'numeric', 
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                  hour12: false
                })
              : new Date().toLocaleDateString('en-US', { 
                  month: 'short',
                  day: 'numeric', 
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                  hour12: false
                });
            
            page.drawText(`[E-Signed] ${signatureDateStr}`, {
              x: 40,
              y: yPosition,
              size: 9,
              font,
              color: rgb(0, 0.6, 0) // Green color
            });
            
            yPosition -= 20;
          }
        } catch (error) {
          console.error('Error processing signature:', error);
        }
      }
      
      // Medical Image Section (moved after radiologist report)
      let imageHeight = 0;
      
      // Check for image data from uploaded image filenames or database fileName and filesystem
      let imageBuffers: Array<{ buffer: Buffer; mimeType: string }> = [];
      
      // FIRST PRIORITY: Load images from database image_data column (base64)
      console.log("üì∑ SERVER: Checking for images in database image_data column...");
      console.log("üì∑ SERVER: Looking for ORDER row with imageId:", reportId);
      try {
        const dbImages = await db
          .select()
          .from(schema.medicalImages)
          .where(
            and(
              eq(schema.medicalImages.organizationId, organizationId),
              eq(schema.medicalImages.imageId, reportId), // Use specific imageId from current ORDER row
              isNotNull(schema.medicalImages.imageData)
            )
          );
        
        console.log(`üì∑ SERVER: Found ${dbImages.length} image(s) with base64 data for imageId ${reportId}`);
        
        for (const dbImage of dbImages) {
          if (dbImage.imageData) {
            try {
              // Extract base64 data (remove data:image/xxx;base64, prefix if present)
              const base64Data = dbImage.imageData.includes(',') 
                ? dbImage.imageData.split(',')[1] 
                : dbImage.imageData;
              
              // Determine MIME type from data URL prefix or default to jpeg
              let mimeType = 'image/jpeg';
              let fileExtension = '.jpg';
              
              if (dbImage.imageData.includes('image/png')) {
                mimeType = 'image/png';
                fileExtension = '.png';
              } else if (dbImage.imageData.includes('image/webp')) {
                mimeType = 'image/webp';
                fileExtension = '.webp'; // Correct extension for WebP
              } else if (dbImage.imageData.includes('image/jpg') || dbImage.imageData.includes('image/jpeg')) {
                mimeType = 'image/jpeg';
                fileExtension = '.jpg';
              } else if (dbImage.imageData.includes('image/gif')) {
                mimeType = 'image/gif';
                fileExtension = '.gif';
              } else if (dbImage.imageData.includes('image/bmp')) {
                mimeType = 'image/bmp';
                fileExtension = '.bmp';
              }
              
              console.log(`üì∑ SERVER: Detected image format - MIME: ${mimeType}, Extension: ${fileExtension}`);
              
              const imageBuffer = Buffer.from(base64Data, 'base64');
              
              // Convert to supported format if needed (WebP, GIF, BMP ‚Üí JPEG)
              const { buffer: convertedBuffer, mimeType: convertedMimeType } = await convertImageToSupportedFormat(imageBuffer, fileExtension);
              
              imageBuffers.push({ buffer: convertedBuffer, mimeType: convertedMimeType });
              console.log(`üì∑ SERVER: Successfully loaded image from database (ID: ${dbImage.id}), mimeType: ${convertedMimeType}`);
            } catch (error) {
              console.error(`üì∑ SERVER: Error processing database image (ID: ${dbImage.id}):`, error);
            }
          }
        }
      } catch (error) {
        console.error("üì∑ SERVER: Error querying database for images:", error);
      }
      
      console.log(`üì∑ SERVER: Total images loaded from database: ${imageBuffers.length}`);
      
      // Embed all images in the PDF
      if (imageBuffers.length > 0) {
        console.log(`üì∑ SERVER: Embedding ${imageBuffers.length} image(s) in PDF`);
        
        for (let imgIndex = 0; imgIndex < imageBuffers.length; imgIndex++) {
          const { buffer: currentBuffer, mimeType: currentMimeType } = imageBuffers[imgIndex];
          
          try {
            console.log(`üì∑ SERVER: Processing image ${imgIndex + 1}/${imageBuffers.length} for PDF, mimeType:`, currentMimeType);
            
            // Embed image based on MIME type with robust error handling
            let image;
            let embedSuccess = false;
            let primaryError: any = null;
            
            // Try primary format first
            try {
              if (currentMimeType.includes('jpeg') || currentMimeType.includes('jpg')) {
                image = await pdfDoc.embedJpg(currentBuffer);
                embedSuccess = true;
                console.log("üì∑ SERVER: Successfully embedded as JPEG");
              } else if (currentMimeType.includes('png')) {
                image = await pdfDoc.embedPng(currentBuffer);
                embedSuccess = true;
                console.log("üì∑ SERVER: Successfully embedded as PNG");
              }
            } catch (error) {
              primaryError = error;
              console.log("üì∑ SERVER: Primary embedding failed, trying fallback:", error.message);
            }
            
            // If primary failed, try fallback format
            if (!embedSuccess) {
              try {
                if (currentMimeType.includes('png')) {
                  // Try JPEG if PNG failed
                  image = await pdfDoc.embedJpg(currentBuffer);
                  embedSuccess = true;
                  console.log("üì∑ SERVER: ‚úÖ Successfully embedded PNG file as JPEG (fallback)");
                } else {
                  // Try PNG if JPEG failed  
                  image = await pdfDoc.embedPng(currentBuffer);
                  embedSuccess = true;
                  console.log("üì∑ SERVER: ‚úÖ Successfully embedded JPEG file as PNG (fallback)");
                }
              } catch (fallbackError) {
                console.error("üì∑ SERVER: ‚ùå Both embedding methods failed - PNG and JPEG");
                console.error("üì∑ SERVER: Primary error:", primaryError?.message);
                console.error("üì∑ SERVER: Fallback error:", fallbackError.message);
              }
            }
            
            if (image) {
              // Calculate image dimensions to fit nicely in the PDF
              const maxImageWidth = 200;
              const maxImageHeight = 150;
              const imageAspectRatio = image.width / image.height;
              
              let drawWidth = maxImageWidth;
              let drawHeight = maxImageWidth / imageAspectRatio;
              
              if (drawHeight > maxImageHeight) {
                drawHeight = maxImageHeight;
                drawWidth = maxImageHeight * imageAspectRatio;
              }
              
              imageHeight = drawHeight + 60;
              
              // Image Section with border
              drawSectionBox(30, yPosition + 10, width - 60, imageHeight);
              const imageTitle = imageBuffers.length > 1 ? `MEDICAL IMAGE ${imgIndex + 1}/${imageBuffers.length}` : 'MEDICAL IMAGE';
              page.drawText(imageTitle, {
                x: 40,
                y: yPosition - 5,
                size: 12,
                font: boldFont,
                color: primaryBlue
              });
              
              // Draw the medical image on the right side
              page.drawImage(image, {
                x: width - drawWidth - 40, // Right-aligned with 40pt margin
                y: yPosition - drawHeight - 40,
                width: drawWidth,
                height: drawHeight
              });
              
              // Image Series information
              const fileSize = study.images && study.images[0] && study.images[0].fileSize ? (study.images[0].fileSize / (1024 * 1024)).toFixed(2) : '0.00';
              const imageSeries = `${study.modality || 'X-Ray'} ‚Ä¢ ${fileSize} MB ‚Ä¢ ${currentMimeType.includes('jpeg') ? 'JPEG' : 'PNG'}`;
              
              page.drawText(`Image Info: ${imageSeries}`, {
                x: 50,
                y: yPosition - imageHeight + 25,
                size: 9,
                font,
                color: darkGray
              });
              
              page.drawText(`Series: ${study.images && study.images[0] ? (study.images[0].seriesDescription || study.studyType || 'N/A') : study.studyType || 'N/A'}`, {
                x: 50,
                y: yPosition - imageHeight + 10,
                size: 9,
                font,
                color: darkGray
              });
              
              yPosition -= imageHeight + 10; // Add spacing between images
            }
          } catch (imageError) {
            console.error(`üì∑ SERVER: ‚ùå Failed to add image ${imgIndex + 1} to PDF after all attempts:`, imageError.message);
            // Continue with next image if there's an error
          }
        }
      }
      
      // Professional Footer using clinic_footers data
      const footerY = 60;
      drawSectionBox(30, footerY + 5, width - 60, 40);
      
      if (clinicFooter?.footerText) {
        // Use footer text from clinic_footers
        const footerText = clinicFooter.footerText;
        const footerTextWidth = font.widthOfTextAtSize(footerText, 9);
        page.drawText(footerText, {
          x: width / 2 - footerTextWidth / 2,
          y: footerY - 15,
          size: 9,
          font,
          color: darkGray
        });
      } else {
        // Fallback footer
        page.drawText('CURA MEDICAL CENTER - DEPARTMENT OF RADIOLOGY', {
          x: width / 2 - 120,
          y: footerY - 8,
          size: 10,
          font: boldFont,
          color: primaryBlue
        });
        
        page.drawText('Tel: +44-123-456-7890  |  Email: radiology@curamedical.com  |  Web: www.curamedical.com', {
          x: width / 2 - 140,
          y: footerY - 22,
          size: 8,
          font,
          color: darkGray
        });
      }
      
      // Confidentiality notice
      page.drawText('WARNING: CONFIDENTIAL MEDICAL REPORT - Authorized Personnel Only', {
        x: width / 2 - 130,
        y: 15,
        size: 8,
        font: boldFont,
        color: rgb(0.8, 0, 0)
      });
      
      // Generate PDF bytes
      let pdfBytes = await pdfDoc.save();
      
      // Save PDF to disk
      const outputPath = path.join(reportsDir, `${reportId}.pdf`);
      await fse.outputFile(outputPath, pdfBytes);
      
      console.log(`PDF report generated and saved: ${outputPath}`);
      
      // Save report file information to database
      const reportFileName = `${reportId}.pdf`;
      const reportFilePath = outputPath;
      
      if (req.organizationId && study.id) {
        try {
          await storage.updateMedicalImageReport(study.id, req.tenant!.id, {
            reportFileName,
            reportFilePath,
            findings: reportFormData?.findings || null,
            impression: reportFormData?.impression || null,
            radiologist: reportFormData?.radiologist || null,
            scheduledAt: reportFormData?.scheduledAt || null,
            performedAt: reportFormData?.performedAt || null
          });
          console.log(`Report file information saved to database for study ID: ${study.id}`);
        } catch (dbError) {
          console.error("Failed to save report info to database:", dbError);
          // Continue without failing the response since PDF was generated successfully
        }
      }
      
      res.json({
        success: true,
        reportId: reportId,
        fileName: reportFileName,
        filePath: reportFilePath,
        message: "PDF report generated successfully"
      });

    } catch (error) {
      console.error("PDF generation error:", error);
      res.status(500).json({ error: "Failed to generate PDF report" });
    }
  });

  // Generate Image Prescription PDF Endpoint
  app.post("/api/imaging/generate-image-prescription", authMiddleware, requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      console.log("IMAGE PRESCRIPTION: Starting generation...");
      
      if (!req.user) {
        console.log("IMAGE PRESCRIPTION: User not authenticated");
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { imageId } = req.body;
      console.log("IMAGE PRESCRIPTION: Received imageId:", imageId);
      
      if (!imageId) {
        console.log("IMAGE PRESCRIPTION: Image ID is required");
        return res.status(400).json({ error: "Image ID is required" });
      }

      const organizationId = req.organizationId || req.tenant!.id;
      console.log("IMAGE PRESCRIPTION: Organization ID:", organizationId);

      // Fetch medical image data by imageId
      console.log("IMAGE PRESCRIPTION: Fetching medical images...");
      const medicalImages = await storage.getMedicalImagesByOrganization(req.tenant!.id);
      console.log("IMAGE PRESCRIPTION: Found medical images:", medicalImages.length);
      
      const medicalImage = medicalImages.find(img => img.imageId === imageId);
      console.log("IMAGE PRESCRIPTION: Found medical image:", medicalImage ? "YES" : "NO");
      console.log("IMAGE PRESCRIPTION: Has signature from DB:", !!(medicalImage?.signatureData));
      if (medicalImage?.signatureData) {
        console.log("IMAGE PRESCRIPTION: Signature data length:", medicalImage.signatureData.length);
        console.log("IMAGE PRESCRIPTION: Signature data preview:", medicalImage.signatureData.substring(0, 50) + "...");
      }
      
      if (!medicalImage) {
        console.log("IMAGE PRESCRIPTION: Medical image not found for imageId:", imageId);
        console.log("Available imageIds:", medicalImages.map(img => img.imageId));
        return res.status(404).json({ error: "Medical image not found" });
      }

      // Fetch clinic headers
      const clinicHeaders = await db
        .select()
        .from(schema.clinicHeaders)
        .where(eq(schema.clinicHeaders.organizationId, organizationId))
        .limit(1);
      
      const headerData = clinicHeaders[0] || null;

      // Fetch clinic footers
      const clinicFooters = await db
        .select()
        .from(schema.clinicFooters)
        .where(eq(schema.clinicFooters.organizationId, organizationId))
        .limit(1);
      
      const footerData = clinicFooters[0] || null;

      // Fetch patient data
      const patient = await storage.getPatient(medicalImage.patientId, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      // Save PDF in organizational structure: uploads/Image_Prescriptions/organization_id/patients/patient_id/
      const prescriptionsDir = path.resolve(process.cwd(), 'uploads', 'Image_Prescriptions', String(organizationId), 'patients', String(medicalImage.patientId));
      await fse.ensureDir(prescriptionsDir);
      
      // Import pdf-lib dynamically
      const { PDFDocument, rgb, StandardFonts } = await import('pdf-lib');
      
      // Helper function to sanitize text for WinAnsi encoding (PDF standard fonts)
      const sanitizeText = (text: string | null | undefined): string => {
        if (!text) return '';
        return text
          .replace(/\u2011/g, '-')  // Non-breaking hyphen to regular hyphen
          .replace(/\u2010/g, '-')  // Hyphen to regular hyphen
          .replace(/\u2012/g, '-')  // Figure dash to hyphen
          .replace(/\u2013/g, '-')  // En dash to hyphen
          .replace(/\u2014/g, '-')  // Em dash to hyphen
          .replace(/\u2015/g, '-')  // Horizontal bar to hyphen
          .replace(/\u2018/g, "'")  // Left single quote
          .replace(/\u2019/g, "'")  // Right single quote
          .replace(/\u201C/g, '"')  // Left double quote
          .replace(/\u201D/g, '"')  // Right double quote
          .replace(/\u2026/g, '...') // Ellipsis
          .replace(/\u00A0/g, ' ')  // Non-breaking space
          .replace(/[^\x00-\xFF]/g, ''); // Remove any other non-Latin1 chars
      };
      
      // Create a new PDF document
      const pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage([595, 842]); // A4 size in points
      const { width, height } = page.getSize();
      
      // Load fonts
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
      
      // Colors
      const primaryBlue = rgb(0.27, 0.51, 0.71); // #4583B6
      const darkText = rgb(0.2, 0.2, 0.2);
      const lightGray = rgb(0.9, 0.9, 0.9);
      const yellowBg = rgb(1, 0.98, 0.8); // Light yellow for clinical notes
      const redBg = rgb(1, 0.95, 0.95); // Light red for critical alert
      const greenText = rgb(0.2, 0.6, 0.2); // Green for COMPLETED
      const redText = rgb(0.8, 0.2, 0.2); // Red for ABNORMAL
      const orangeText = rgb(1, 0.5, 0); // Orange for warnings
      
      // Position tracker
      let yPosition = height - 40;
      
      // TOP ROW: Date/Time | Logo (center) | ACTIVE
      const currentDate = new Date();
      
      // TOP LEFT: Date and time
      page.drawText(`${currentDate.toLocaleDateString()}, ${currentDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true })}`, {
        x: 40,
        y: yPosition,
        size: 8,
        font,
        color: darkText
      });
      
      // Prescription number moved to center
      page.drawText(`Prescription #: RX-${medicalImage.imageId}ORDER`, {
        x: width / 2 - 60,
        y: yPosition,
        size: 7,
        font,
        color: darkText
      });
      
      // TOP RIGHT: ACTIVE status
      page.drawText('ACTIVE', {
        x: width - 80,
        y: yPosition,
        size: 9,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 70;
      
      // CURA HEALTH EMR header (left side, below logo row)
      page.drawText('CURA HEALTH EMR', {
        x: 40,
        y: yPosition,
        size: 11,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 12;
      
      page.drawText(`Prescription #: RX-${medicalImage.imageId}ORDER`, {
        x: 40,
        y: yPosition,
        size: 8,
        font,
        color: rgb(0.5, 0.5, 0.5)
      });
      
      yPosition -= 30;
      
      // TWO COLUMNS: Left column (logo), Right column (clinic info)
      const leftColX = 50;
      const rightColX = 180;
      let leftColY = yPosition;
      let rightColY = yPosition;
      
      // Calculate header section height first to match logo
      const headerHeight = 16 + 14 + 10 + 10 + 10; // clinic name + address + phone + email + website spacing
      
      // LEFT COLUMN: Small Logo (sized to match header height)
      if (headerData?.logoBase64) {
        try {
          const logoData = headerData.logoBase64.replace(/^data:image\/\w+;base64,/, '');
          const logoBytes = Buffer.from(logoData, 'base64');
          
          let logoImage;
          if (headerData.logoBase64.includes('image/png')) {
            logoImage = await pdfDoc.embedPng(logoBytes);
          } else {
            logoImage = await pdfDoc.embedJpg(logoBytes);
          }
          
          // Scale logo to match header height (approximately 60 points)
          const targetLogoHeight = 60;
          const logoAspectRatio = logoImage.width / logoImage.height;
          const logoWidth = targetLogoHeight * logoAspectRatio;
          
          leftColY = yPosition - targetLogoHeight;
          
          page.drawImage(logoImage, {
            x: leftColX,
            y: leftColY,
            width: logoWidth,
            height: targetLogoHeight
          });
        } catch (logoError) {
          console.error('Failed to embed logo:', logoError);
        }
      }
      
      // RIGHT COLUMN: Clinic Information
      const clinicName = sanitizeText(headerData?.clinicName) || 'Clinical Care Hospital';
      page.drawText(clinicName, {
        x: rightColX,
        y: rightColY,
        size: 16,
        font: boldFont,
        color: darkText
      });
      
      rightColY -= 14;
      
      const clinicAddress = sanitizeText(headerData?.address) || 'house 33';
      page.drawText(clinicAddress, {
        x: rightColX,
        y: rightColY,
        size: 8,
        font,
        color: darkText
      });
      
      rightColY -= 10;
      
      const clinicPhone = sanitizeText(headerData?.phone) || '+923213213213';
      page.drawText(clinicPhone, {
        x: rightColX,
        y: rightColY,
        size: 8,
        font,
        color: darkText
      });
      
      rightColY -= 10;
      
      const clinicEmail = sanitizeText(headerData?.email) || 'averox71@gmail.com';
      page.drawText(clinicEmail, {
        x: rightColX,
        y: rightColY,
        size: 8,
        font,
        color: darkText
      });
      
      rightColY -= 10;
      
      const clinicWebsite = sanitizeText(headerData?.website) || 'website: www.clinicalcare.com';
      page.drawText(clinicWebsite, {
        x: rightColX,
        y: rightColY,
        size: 8,
        font,
        color: darkText
      });
      
      // Use the lower of left column (logo) or right column (clinic info) bottom to ensure no overlap
      yPosition = Math.min(leftColY, rightColY) - 30;
      
      // PATIENT INFORMATION SECTION (TWO COLUMNS)
      const leftColumnX = 60;
      const rightColumnX = 310;
      
      // Left Column
      page.drawText(`Name: ${sanitizeText(patient.firstName)} ${sanitizeText(patient.lastName)}`, {
        x: leftColumnX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      // Right Column
      const age = patient.dateOfBirth 
        ? Math.floor((new Date().getTime() - new Date(patient.dateOfBirth).getTime()) / (1000 * 60 * 60 * 24 * 365))
        : 0;
      
      page.drawText(`DOB: ${patient.dateOfBirth ? new Date(patient.dateOfBirth).toLocaleDateString() : '11th Sept 2015'}`, {
        x: rightColumnX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 14;
      
      // Address on left
      page.drawText(sanitizeText(`Address: ${patient.address || 'House 33, Birmingham, West Midlands, B33 8TH, United Kingdom'}`).substring(0, 50), {
        x: leftColumnX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      // Age on right
      page.drawText(`Age: ${age}`, {
        x: rightColumnX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 14;
      
      // Gender on left
      page.drawText(`Gender: ${sanitizeText(patient.gender) || 'N/A'}`, {
        x: leftColumnX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      // Sex on right
      page.drawText(`Sex: No: ${sanitizeText(patient.nhsNumber) || 'N/A'}`, {
        x: rightColumnX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 14;
      
      // Weight on left
      page.drawText(`Weight: ${sanitizeText(patient.weight) || '-'}`, {
        x: leftColumnX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      // Date on right
      page.drawText(`Date: ${currentDate.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' }).replace(/ /g, ' ')}`, {
        x: rightColumnX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 35;
      
      // PROVIDER SECTION (Blue left border)
      page.drawLine({
        start: { x: 60, y: yPosition + 5 },
        end: { x: 60, y: yPosition - 20 },
        thickness: 3,
        color: primaryBlue
      });
      
      page.drawText('Provider: N/A', {
        x: 70,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 40;
      
      // IMAGING STUDY DETAILS SECTION
      page.drawText('IMAGING STUDY DETAILS', {
        x: 60,
        y: yPosition,
        size: 12,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 20;
      
      // Study Type
      page.drawText(`Study Type: ${sanitizeText(medicalImage.studyType) || 'N/A'}`, {
        x: 60,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 14;
      
      // Modality
      page.drawText(`Modality: ${sanitizeText(medicalImage.modality) || 'N/A'}`, {
        x: 60,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 14;
      
      // Body Part
      page.drawText(`Body Part: ${sanitizeText(medicalImage.bodyPart) || 'N/A'}`, {
        x: 60,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 14;
      
      // Image ID
      page.drawText(`Image ID: ${sanitizeText(medicalImage.imageId) || 'N/A'}`, {
        x: 60,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 14;
      
      // Status
      page.drawText(`Status: ${sanitizeText(medicalImage.status)?.toUpperCase() || 'PENDING'}`, {
        x: 60,
        y: yPosition,
        size: 9,
        font,
        color: medicalImage.status?.toLowerCase() === 'completed' ? greenText : darkText
      });
      
      yPosition -= 20;
      
      // Clinical Indication
      if (medicalImage.indication) {
        page.drawText('Clinical Indication:', {
          x: 60,
          y: yPosition,
          size: 9,
          font: boldFont,
          color: darkText
        });
        
        yPosition -= 14;
        
        const indicationLines = sanitizeText(medicalImage.indication).substring(0, 150).match(/.{1,80}/g) || [];
        indicationLines.forEach((line: string) => {
          page.drawText(line, {
            x: 60,
            y: yPosition,
            size: 9,
            font,
            color: darkText
          });
          yPosition -= 12;
        });
        
        yPosition -= 8;
      }
      
      // Findings
      if (medicalImage.findings) {
        page.drawText('Findings:', {
          x: 60,
          y: yPosition,
          size: 9,
          font: boldFont,
          color: darkText
        });
        
        yPosition -= 14;
        
        const findingsLines = sanitizeText(medicalImage.findings).substring(0, 150).match(/.{1,80}/g) || [];
        findingsLines.forEach((line: string) => {
          page.drawText(line, {
            x: 60,
            y: yPosition,
            size: 9,
            font,
            color: darkText
          });
          yPosition -= 12;
        });
        
        yPosition -= 8;
      }
      
      yPosition -= 15;
      
      // Resident Physician (Signature) section
      page.drawText('Resident Physician', {
        x: 60,
        y: yPosition,
        size: 8,
        font,
        color: darkText
      });
      
      yPosition -= 10;
      
      page.drawText('(Signature)', {
        x: 60,
        y: yPosition,
        size: 8,
        font,
        color: darkText
      });
      
      yPosition -= 15;
      
      // Add e-signature image if available (from database)
      if (medicalImage.signatureData) {
        try {
          console.log("IMAGE PRESCRIPTION: Adding e-signature to PDF...");
          // Extract base64 data from data URL (format: data:image/png;base64,...)
          const base64Data = medicalImage.signatureData.replace(/^data:image\/\w+;base64,/, '');
          const signatureBuffer = Buffer.from(base64Data, 'base64');
          
          // Embed PNG image
          const signatureImage = await pdfDoc.embedPng(signatureBuffer);
          
          // Calculate dimensions (keep signature reasonably sized)
          const maxWidth = 160;
          const maxHeight = 60;
          const aspectRatio = signatureImage.width / signatureImage.height;
          
          let imgWidth = maxWidth;
          let imgHeight = maxWidth / aspectRatio;
          
          if (imgHeight > maxHeight) {
            imgHeight = maxHeight;
            imgWidth = maxHeight * aspectRatio;
          }
          
          // Define signature box dimensions (compact size like UI)
          const boxWidth = 170;
          const boxHeight = 70;
          const boxX = 60;
          const boxY = yPosition - boxHeight;
          
          // Draw signature box border
          page.drawRectangle({
            x: boxX,
            y: boxY,
            width: boxWidth,
            height: boxHeight,
            borderColor: rgb(0.3, 0.3, 0.3),
            borderWidth: 1,
          });
          
          // Draw signature image centered inside the box with padding
          const paddingX = (boxWidth - imgWidth) / 2;
          const paddingY = (boxHeight - imgHeight) / 2;
          
          page.drawImage(signatureImage, {
            x: boxX + paddingX,
            y: boxY + paddingY,
            width: imgWidth,
            height: imgHeight,
          });
          
          // Add timestamp below signature box if signatureDate exists
          if (medicalImage.signatureDate) {
            const signDate = new Date(medicalImage.signatureDate);
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const formattedDate = `${months[signDate.getMonth()]} ${signDate.getDate()}, ${signDate.getFullYear()} ${signDate.getHours().toString().padStart(2, '0')}:${signDate.getMinutes().toString().padStart(2, '0')}`;
            const timestampText = `[E-Signed] ${formattedDate}`;
            
            // Draw timestamp in green below the signature box
            page.drawText(timestampText, {
              x: boxX,
              y: boxY - 15,
              size: 8,
              font,
              color: rgb(0, 0.5, 0), // Green color
            });
          }
          
          console.log("IMAGE PRESCRIPTION: E-signature added successfully");
          yPosition -= (boxHeight + 20); // Adjust position after signature box and timestamp
        } catch (signatureError) {
          console.error("IMAGE PRESCRIPTION: Error adding e-signature:", signatureError);
          // Continue without signature if there's an error
        }
      } else {
        yPosition -= 20;
      }
      
      if (req.user?.firstName && req.user?.lastName) {
        page.drawText(`${req.user.firstName} ${req.user.lastName}`, {
          x: width - 180,
          y: yPosition + 35,
          size: 8,
          font,
          color: darkText
        });
      }
      
      // FOOTER SECTION
      const footerY = 30;
      
      // Bottom center: Copyright notice
      const copyrightText = `¬© 2025 ${headerData?.clinicName || 'CuraCare Hospital'} ‚Äî All Rights Reserved`;
      const copyrightWidth = copyrightText.length * 3.5;
      page.drawText(copyrightText, {
        x: width / 2 - copyrightWidth / 2,
        y: footerY,
        size: 7,
        font,
        color: rgb(0.4, 0.4, 0.4)
      });
      
      // Bottom left: about:blank
      page.drawText('about:blank', {
        x: 40,
        y: 15,
        size: 7,
        font,
        color: rgb(0.4, 0.4, 0.4)
      });
      
      // Bottom right: Page number
      page.drawText('1/2', {
        x: width - 60,
        y: 15,
        size: 7,
        font,
        color: rgb(0.4, 0.4, 0.4)
      });
      
      // Generate PDF bytes
      let pdfBytes = await pdfDoc.save();
      
      // Save PDF to disk
      const fileName = `prescription-${imageId}.pdf`;
      const outputPath = path.join(prescriptionsDir, fileName);
      await fse.outputFile(outputPath, pdfBytes);
      
      console.log(`Image prescription PDF generated and saved: ${outputPath}`);
      
      // Update the medical_images table with prescription file path and mark as ready to generate
      const prescriptionPath = `/uploads/Image_Prescriptions/${organizationId}/patients/${medicalImage.patientId}/${fileName}`;
      console.log(`DATABASE UPDATE: Setting prescriptionFilePath to: ${prescriptionPath}`);
      console.log(`DATABASE UPDATE: Setting orderStudyReadyToGenerate to: true`);
      console.log(`DATABASE UPDATE: Setting status to: in_progress`);
      console.log(`DATABASE UPDATE: For medical image ID: ${medicalImage.id}`);
      
      await db
        .update(schema.medicalImages)
        .set({
          prescriptionFilePath: prescriptionPath,
          orderStudyReadyToGenerate: true,
          status: 'in_progress'
        })
        .where(eq(schema.medicalImages.id, medicalImage.id));
      
      console.log(`DATABASE UPDATE: Successfully updated medical_images table for ID ${medicalImage.id}`);
      
      // Generate signed token for secure access
      const fileSecret = process.env.FILE_SECRET;
      if (!fileSecret) {
        console.error("FILE_SECRET not configured");
        return res.status(500).json({ error: "Server configuration error" });
      }
      
      const accessToken = jwt.sign(
        {
          organizationId: organizationId,
          patientId: medicalImage.patientId,
          fileName: fileName,
          type: 'prescription'
        },
        fileSecret,
        { expiresIn: '7d' }
      );
      
      // Create view URL for the prescription with token
      const viewUrl = `/api/imaging/view-prescription/${organizationId}/${medicalImage.patientId}/${fileName}?token=${accessToken}`;
      
      res.json({
        success: true,
        fileName: fileName,
        viewUrl: viewUrl,
        message: "Image prescription generated successfully"
      });

    } catch (error) {
      console.error("IMAGE PRESCRIPTION ERROR:", error);
      console.error("Error details:", {
        name: (error as Error).name,
        message: (error as Error).message,
        stack: (error as Error).stack
      });
      res.status(500).json({ 
        error: "Failed to generate image prescription",
        details: (error as Error).message 
      });
    }
  });

  // Generate Prescription Token Endpoint
  app.post("/api/imaging/generate-prescription-token", authMiddleware, requireRole(["doctor", "nurse", "patient", "admin"]), async (req: TenantRequest, res) => {
    try {
      const { organizationId, patientId, fileName } = req.body;
      
      if (!organizationId || !patientId || !fileName) {
        return res.status(400).json({ error: "Missing required parameters" });
      }

      const fileSecret = process.env.FILE_SECRET;
      if (!fileSecret) {
        console.error("FILE_SECRET not configured");
        return res.status(500).json({ error: "Server configuration error" });
      }
      
      // Generate signed token for secure access
      const accessToken = jwt.sign(
        {
          organizationId: organizationId,
          patientId: patientId,
          fileName: fileName,
          type: 'prescription'
        },
        fileSecret,
        { expiresIn: '7d' }
      );
      
      res.json({
        success: true,
        token: accessToken
      });

    } catch (error) {
      console.error("PRESCRIPTION TOKEN ERROR:", error);
      res.status(500).json({ 
        error: "Failed to generate prescription token",
        details: (error as Error).message 
      });
    }
  });

  // View Image Prescription PDF using temporary signed URL (no authentication required - token validated)
  app.get("/api/imaging/view-prescription/:organizationId/:patientId/:fileName", async (req: Request, res: Response) => {
    try {
      const { token } = req.query;
      if (!token || typeof token !== 'string') {
        return res.status(403).json({ error: "Missing or invalid token" });
      }

      const fileSecret = process.env.FILE_SECRET;
      if (!fileSecret) {
        console.error("FILE_SECRET not configured");
        return res.status(500).json({ error: "Server configuration error" });
      }

      // Verify and decode token
      let payload: any;
      try {
        payload = jwt.verify(token, fileSecret);
      } catch (err) {
        console.log("[PRESCRIPTION-VIEW] Token verification failed:", err);
        return res.status(403).json({ error: "Invalid or expired token" });
      }

      const { organizationId, patientId, fileName } = payload;
      
      // Construct file path
      const relativePath = `uploads/Image_Prescriptions/${organizationId}/patients/${patientId}/${fileName}`;
      const fullPath = path.join(process.cwd(), relativePath);

      // Check if file exists
      const fileExists = await fse.pathExists(fullPath);
      if (!fileExists) {
        console.log(`[PRESCRIPTION-VIEW] File not found: ${fullPath}`);
        return res.status(404).json({ error: "Prescription not found" });
      }

      console.log(`[PRESCRIPTION-VIEW] Serving file: ${fullPath}`);
      
      // Set headers for PDF viewing
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', 'inline; filename="' + fileName + '"');
      
      // Stream the file
      res.sendFile(fullPath);

    } catch (error) {
      console.error("[PRESCRIPTION-VIEW] Error viewing prescription:", error);
      res.status(500).json({ error: "Failed to view prescription" });
    }
  });

  // Save Lab Result Prescription Endpoint
  app.post("/api/imaging/save-prescription", authMiddleware, requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      console.log("SAVE PRESCRIPTION: Starting...");
      
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { studyId, prescriptionData } = req.body;
      console.log("SAVE PRESCRIPTION: Study ID:", studyId);
      
      if (!studyId || !prescriptionData) {
        return res.status(400).json({ error: "Study ID and prescription data are required" });
      }

      const organizationId = req.tenant!.id;
      console.log("SAVE PRESCRIPTION: Organization ID:", organizationId);

      // Fetch the study
      const study = await storage.getMedicalImage(studyId, req.tenant!.id);
      if (!study) {
        return res.status(404).json({ error: "Study not found" });
      }

      // Save PDF in: uploads/Image_Prescriptions/
      const prescriptionsDir = path.resolve(process.cwd(), 'uploads', 'Image_Prescriptions');
      await fse.ensureDir(prescriptionsDir);
      
      // Import pdf-lib dynamically
      const { PDFDocument, rgb, StandardFonts } = await import('pdf-lib');
      
      // Create a new PDF document
      const pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage([595, 842]); // A4 size
      const { width, height } = page.getSize();
      
      // Load fonts
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
      
      // Colors
      const primaryBlue = rgb(0.29, 0.49, 1); // #4A7DFF
      const darkText = rgb(0.2, 0.2, 0.2);
      const lightBlueBg = rgb(0.93, 0.95, 1); // Light blue background
      const yellowBg = rgb(1, 0.98, 0.8);
      const redBg = rgb(1, 0.95, 0.95);
      const greenText = rgb(0.2, 0.6, 0.2);
      const grayText = rgb(0.4, 0.4, 0.4);
      
      let yPosition = height - 50;
      
      // Red Cross Logo (circular)
      page.drawCircle({
        x: width / 2,
        y: yPosition - 10,
        size: 20,
        color: rgb(0.93, 0.11, 0.14),
        borderWidth: 0
      });
      
      // White cross inside
      const crossSize = 12;
      const centerX = width / 2;
      const centerY = yPosition - 10;
      
      // Horizontal bar
      page.drawRectangle({
        x: centerX - crossSize / 2,
        y: centerY - 2,
        width: crossSize,
        height: 4,
        color: rgb(1, 1, 1)
      });
      
      // Vertical bar
      page.drawRectangle({
        x: centerX - 2,
        y: centerY - crossSize / 2,
        width: 4,
        height: crossSize,
        color: rgb(1, 1, 1)
      });
      
      yPosition -= 45;
      
      // Hospital Name
      page.drawText(prescriptionData.hospitalName || 'Clinical Care Hospital', {
        x: width / 2 - 85,
        y: yPosition,
        size: 18,
        font: boldFont,
        color: primaryBlue
      });
      
      yPosition -= 18;
      
      // Laboratory Test Prescription
      page.drawText('Laboratory Test Prescription', {
        x: width / 2 - 75,
        y: yPosition,
        size: 10,
        font,
        color: grayText
      });
      
      yPosition -= 12;
      
      // Hospital details
      const hospitalDetails = [
        prescriptionData.hospitalAddress || 'house 33',
        prescriptionData.hospitalPhone || '+923213213213',
        prescriptionData.hospitalEmail || 'averox71@gmail.com',
        prescriptionData.hospitalWebsite || 'www.clinicalcare.com'
      ];
      
      for (const detail of hospitalDetails) {
        page.drawText(detail, {
          x: width / 2 - (detail.length * 2.5),
          y: yPosition,
          size: 8,
          font,
          color: grayText
        });
        yPosition -= 12;
      }
      
      yPosition -= 10;
      
      // Horizontal line
      page.drawLine({
        start: { x: 40, y: yPosition },
        end: { x: width - 40, y: yPosition },
        thickness: 1,
        color: grayText
      });
      
      yPosition -= 25;
      
      // Physician and Patient Information (two columns)
      const leftColX = 50;
      const rightColX = width / 2 + 20;
      
      // Physician Information
      page.drawText('Physician Information', {
        x: leftColX,
        y: yPosition,
        size: 11,
        font: boldFont,
        color: darkText
      });
      
      // Patient Information
      page.drawText('Patient Information', {
        x: rightColX,
        y: yPosition,
        size: 11,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 18;
      
      // Physician details
      page.drawText(`Name: ${prescriptionData.physicianName}`, {
        x: leftColX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      // Patient details
      page.drawText(`Name: ${prescriptionData.patientName}`, {
        x: rightColX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 15;
      
      page.drawText(`Priority: ${prescriptionData.priority}`, {
        x: leftColX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      page.drawText(`Patient ID: ${prescriptionData.patientId}`, {
        x: rightColX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 15;
      
      page.drawText(`Date: ${prescriptionData.date}`, {
        x: rightColX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 15;
      
      page.drawText(`Time: ${prescriptionData.time}`, {
        x: rightColX,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 30;
      
      // Laboratory Test Prescription Section
      page.drawRectangle({
        x: 40,
        y: yPosition - 150,
        width: width - 80,
        height: 165,
        color: lightBlueBg,
        borderColor: grayText,
        borderWidth: 1
      });
      
      page.drawText('IMAGING STUDY PRESCRIPTION', {
        x: 50,
        y: yPosition,
        size: 11,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 25;
      
      // Test details grid (2x2)
      const boxWidth = (width - 120) / 2;
      const boxHeight = 35;
      const boxStartY = yPosition;
      
      // Row 1
      // Test ID box
      page.drawRectangle({
        x: 50,
        y: boxStartY - boxHeight,
        width: boxWidth,
        height: boxHeight,
        color: rgb(1, 1, 1),
        borderColor: grayText,
        borderWidth: 0.5
      });
      
      page.drawText('Test ID:', {
        x: 60,
        y: boxStartY - 15,
        size: 8,
        font,
        color: grayText
      });
      
      page.drawText(prescriptionData.testId, {
        x: 60,
        y: boxStartY - 28,
        size: 9,
        font: boldFont,
        color: darkText
      });
      
      // Test Type box
      page.drawRectangle({
        x: 60 + boxWidth,
        y: boxStartY - boxHeight,
        width: boxWidth,
        height: boxHeight,
        color: rgb(1, 1, 1),
        borderColor: grayText,
        borderWidth: 0.5
      });
      
      page.drawText('Test Type:', {
        x: 70 + boxWidth,
        y: boxStartY - 15,
        size: 8,
        font,
        color: grayText
      });
      
      page.drawText(prescriptionData.testType, {
        x: 70 + boxWidth,
        y: boxStartY - 28,
        size: 9,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= boxHeight;
      
      // Row 2
      // Ordered Date box
      page.drawRectangle({
        x: 50,
        y: yPosition - boxHeight,
        width: boxWidth,
        height: boxHeight,
        color: rgb(1, 1, 1),
        borderColor: grayText,
        borderWidth: 0.5
      });
      
      page.drawText('Ordered Date:', {
        x: 60,
        y: yPosition - 15,
        size: 8,
        font,
        color: grayText
      });
      
      page.drawText(prescriptionData.orderedDate, {
        x: 60,
        y: yPosition - 28,
        size: 8,
        font: boldFont,
        color: darkText
      });
      
      // Status box
      page.drawRectangle({
        x: 60 + boxWidth,
        y: yPosition - boxHeight,
        width: boxWidth,
        height: boxHeight,
        color: rgb(1, 1, 1),
        borderColor: grayText,
        borderWidth: 0.5
      });
      
      page.drawText('Status:', {
        x: 70 + boxWidth,
        y: yPosition - 15,
        size: 8,
        font,
        color: grayText
      });
      
      const statusColor = prescriptionData.status === 'COMPLETED' ? greenText : rgb(0.8, 0.6, 0);
      page.drawText(prescriptionData.status, {
        x: 70 + boxWidth,
        y: yPosition - 28,
        size: 9,
        font: boldFont,
        color: statusColor
      });
      
      yPosition -= boxHeight + 10;
      
      // Test Results section
      page.drawRectangle({
        x: 50,
        y: yPosition - 50,
        width: width - 100,
        height: 55,
        color: rgb(1, 1, 1),
        borderColor: grayText,
        borderWidth: 0.5
      });
      
      page.drawText('Test Results:', {
        x: 60,
        y: yPosition - 12,
        size: 9,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 25;
      
      page.drawText(prescriptionData.testType, {
        x: 60,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 12;
      
      page.drawText(`Modality: ${prescriptionData.modality}`, {
        x: 60,
        y: yPosition,
        size: 8,
        font,
        color: grayText
      });
      
      yPosition -= 12;
      
      page.drawText(`Body Part: ${prescriptionData.bodyPart}`, {
        x: 60,
        y: yPosition,
        size: 8,
        font,
        color: grayText
      });
      
      if (prescriptionData.priority === 'urgent' || prescriptionData.priority === 'stat') {
        page.drawText('Flag: HIGH', {
          x: width - 150,
          y: yPosition + 12,
          size: 9,
          font: boldFont,
          color: rgb(0.8, 0.2, 0.2)
        });
      }
      
      yPosition -= 25;
      
      // Clinical Notes
      page.drawRectangle({
        x: 50,
        y: yPosition - 40,
        width: width - 100,
        height: 45,
        color: yellowBg,
        borderColor: grayText,
        borderWidth: 0.5
      });
      
      page.drawText('Clinical Notes:', {
        x: 60,
        y: yPosition - 12,
        size: 9,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 25;
      
      const clinicalNotes = prescriptionData.clinicalNotes;
      const maxWidth = width - 120;
      const words = clinicalNotes.split(' ');
      let line = '';
      let lineY = yPosition;
      
      for (const word of words) {
        const testLine = line + word + ' ';
        const testWidth = testLine.length * 4.5;
        
        if (testWidth > maxWidth && line !== '') {
          page.drawText(line.trim(), {
            x: 60,
            y: lineY,
            size: 8,
            font,
            color: darkText
          });
          line = word + ' ';
          lineY -= 12;
        } else {
          line = testLine;
        }
      }
      
      if (line.trim() !== '') {
        page.drawText(line.trim(), {
          x: 60,
          y: lineY,
          size: 8,
          font,
          color: darkText
        });
      }
      
      yPosition -= 50;
      
      // Critical Values Alert
      if (prescriptionData.priority === 'stat' || prescriptionData.priority === 'urgent') {
        page.drawRectangle({
          x: 40,
          y: yPosition - 35,
          width: width - 80,
          height: 40,
          color: redBg,
          borderColor: rgb(0.8, 0.2, 0.2),
          borderWidth: 1
        });
        
        page.drawText('!', {
          x: 50,
          y: yPosition - 15,
          size: 14,
          font: boldFont,
          color: rgb(0.8, 0.2, 0.2)
        });
        
        page.drawText('CRITICAL VALUES DETECTED', {
          x: 65,
          y: yPosition - 12,
          size: 10,
          font: boldFont,
          color: rgb(0.6, 0.1, 0.1)
        });
        
        page.drawText(`This ${prescriptionData.priority === 'stat' ? 'STAT' : 'urgent'} study requires immediate attention.`, {
          x: 70,
          y: yPosition - 25,
          size: 8,
          font,
          color: rgb(0.6, 0.1, 0.1)
        });
        
        yPosition -= 45;
      }
      
      // Footer
      yPosition = 60;
      
      page.drawLine({
        start: { x: 40, y: yPosition },
        end: { x: width - 40, y: yPosition },
        thickness: 0.5,
        color: grayText
      });
      
      yPosition -= 15;
      
      page.drawText('Generated by Cura EMR System', {
        x: 40,
        y: yPosition,
        size: 7,
        font,
        color: grayText
      });
      
      const footerDate = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' });
      page.drawText(`Date: ${footerDate}`, {
        x: width - 150,
        y: yPosition,
        size: 7,
        font,
        color: grayText
      });
      
      // Save the PDF
      let pdfBytes = await pdfDoc.save();
      const fileName = `${study.imageId}.pdf`;
      const filePath = path.join(prescriptionsDir, fileName);
      
      await fse.outputFile(filePath, pdfBytes);
      console.log(`SAVE PRESCRIPTION: PDF saved to ${filePath}`);
      
      // Update the medical_images table with prescription file path and mark as ready to generate
      const prescriptionPath = `/uploads/Image_Prescriptions/${fileName}`;
      await db
        .update(schema.medicalImages)
        .set({ 
          prescriptionFilePath: prescriptionPath,
          orderStudyReadyToGenerate: true,
          updatedAt: new Date()
        })
        .where(eq(schema.medicalImages.id, studyId));
      
      console.log(`SAVE PRESCRIPTION: Database updated with prescription path: ${prescriptionPath}`);
      
      res.json({
        success: true,
        fileName: fileName,
        filePath: filePath,
        message: "Prescription saved successfully"
      });

    } catch (error) {
      console.error("SAVE PRESCRIPTION ERROR:", error);
      res.status(500).json({ error: "Failed to save prescription" });
    }
  });

  // Save Uploaded Images to Imaging_Images Folder and Database (as base64)
  app.post("/api/imaging/save-uploaded-images", authMiddleware, requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      console.log("SAVE UPLOADED IMAGES: Starting...");
      
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { organizationId, patientId, imageUrls } = req.body;
      console.log("SAVE UPLOADED IMAGES: Organization ID:", organizationId, "Patient ID:", patientId);
      
      if (!organizationId || !patientId || !imageUrls || !Array.isArray(imageUrls)) {
        return res.status(400).json({ error: "Organization ID, patient ID, and image URLs are required" });
      }

      // Create directory structure: /uploads/Imaging_Images/{organizationId}/patients/{patientId}/
      const imagingImagesDir = path.resolve(
        process.cwd(), 
        'uploads', 
        'Imaging_Images', 
        String(organizationId), 
        'patients', 
        String(patientId)
      );
      await fse.ensureDir(imagingImagesDir);
      console.log("SAVE UPLOADED IMAGES: Directory created:", imagingImagesDir);

      let savedCount = 0;
      const savedFiles: string[] = [];

      // Process each image URL
      for (const imageUrl of imageUrls) {
        try {
          // Extract filename from URL or generate one
          const urlParts = imageUrl.split('/');
          const originalFileName = urlParts[urlParts.length - 1] || `image_${Date.now()}_${savedCount}.jpg`;
          
          // Generate unique filename with timestamp
          const timestamp = Date.now();
          const fileExtension = originalFileName.split('.').pop() || 'jpg';
          const uniqueFileName = `IMG_${timestamp}_${savedCount}.${fileExtension}`;
          
          // Determine source path - images are typically in /uploads/medical_images/
          let sourcePath: string;
          if (imageUrl.startsWith('/api/medical-images/')) {
            // Extract the filename from the API URL
            const apiFileName = imageUrl.replace('/api/medical-images/', '');
            sourcePath = path.resolve(process.cwd(), 'uploads', 'medical_images', apiFileName);
          } else if (imageUrl.startsWith('/uploads/')) {
            // Direct file path
            sourcePath = path.resolve(process.cwd(), imageUrl.substring(1));
          } else {
            console.log(`SAVE UPLOADED IMAGES: Skipping unsupported URL format: ${imageUrl}`);
            continue;
          }

          // Check if source file exists
          if (await fse.pathExists(sourcePath)) {
            const destPath = path.join(imagingImagesDir, uniqueFileName);
            
            // Copy file to Imaging_Images folder
            await fse.copy(sourcePath, destPath);
            
            // Read image file and convert to base64
            const imageBuffer = await readFile(sourcePath);
            const base64Image = imageBuffer.toString('base64');
            const mimeType = `image/${fileExtension}`;
            const base64WithPrefix = `data:${mimeType};base64,${base64Image}`;
            
            // Find all medical_images records for this patient and organization that need updating
            const medicalImages = await db
              .select()
              .from(schema.medicalImages)
              .where(
                and(
                  eq(schema.medicalImages.organizationId, organizationId),
                  eq(schema.medicalImages.patientId, patientId),
                  isNull(schema.medicalImages.imageData) // Only update records without imageData
                )
              );
            
            // Update the first available record with base64 image data
            if (medicalImages.length > 0) {
              const recordToUpdate = medicalImages[0];
              await db
                .update(schema.medicalImages)
                .set({
                  imageData: base64WithPrefix,
                  updatedAt: new Date()
                })
                .where(eq(schema.medicalImages.id, recordToUpdate.id));
              
              console.log(`SAVE UPLOADED IMAGES: Saved ${uniqueFileName} and updated image_data for medical_images ID: ${recordToUpdate.id}`);
            } else {
              console.log(`SAVE UPLOADED IMAGES: Saved ${uniqueFileName} to filesystem (no available medical_images record to update)`);
            }
            
            savedFiles.push(uniqueFileName);
            savedCount++;
          } else {
            console.log(`SAVE UPLOADED IMAGES: Source file not found: ${sourcePath}`);
          }
        } catch (imageError) {
          console.error(`SAVE UPLOADED IMAGES: Error processing image ${imageUrl}:`, imageError);
        }
      }

      console.log(`SAVE UPLOADED IMAGES: Successfully saved ${savedCount} images`);
      
      res.json({
        success: true,
        savedCount,
        savedFiles,
        directory: imagingImagesDir,
        message: `Successfully saved ${savedCount} image(s) to Imaging_Images folder and database`
      });

    } catch (error) {
      console.error("SAVE UPLOADED IMAGES ERROR:", error);
      res.status(500).json({ error: "Failed to save uploaded images" });
    }
  });

  // Share Imaging Study via Email
  app.post("/api/imaging/share-study", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { studyId, recipientEmail, customMessage, shareSource = 'report' } = req.body;

      if (!studyId || !recipientEmail) {
        return res.status(400).json({ error: "Study ID and recipient email are required" });
      }

      // Get the study details from the database
      const study = await storage.getMedicalImage(studyId, req.tenant!.id);
      if (!study) {
        return res.status(404).json({ error: "Study not found" });
      }

      // Get patient details for the study
      const patient = await storage.getPatient(study.patientId, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }

      const organizationId = req.tenant!.id;
      const imageId = study.imageId;

      // Determine the file path based on shareSource
      let reportPath: string;
      let actualDocType = shareSource; // Track what we're actually sharing
      
      if (shareSource === 'prescription') {
        // For prescriptions, use the stored prescriptionFilePath if available
        if (study.prescriptionFilePath) {
          // Paths starting with /uploads are relative to working directory, not absolute system paths
          if (study.prescriptionFilePath.startsWith('/uploads/') || study.prescriptionFilePath.startsWith('uploads/')) {
            // Convert to absolute path from working directory
            reportPath = path.resolve(process.cwd(), study.prescriptionFilePath.replace(/^\//, ''));
          } else if (path.isAbsolute(study.prescriptionFilePath)) {
            // True absolute system paths (like /home/runner/...)
            reportPath = study.prescriptionFilePath;
          } else {
            // Relative paths
            reportPath = path.resolve(process.cwd(), study.prescriptionFilePath);
          }
          console.log(`[EMAIL-SHARE] Using stored prescriptionFilePath: ${study.prescriptionFilePath}`);
          console.log(`[EMAIL-SHARE] Final path to share prescription from: ${reportPath}`);
        } else {
          // Fallback: Try both filename formats (with and without 'prescription-' prefix)
          const reportsDir = path.resolve(process.cwd(), 'uploads', 'Image_Prescriptions', String(organizationId), 'patients', String(study.patientId));
          
          // First try with 'prescription-' prefix (new format)
          let fileName = `prescription-${imageId}.pdf`;
          reportPath = path.join(reportsDir, fileName);
          console.log(`[EMAIL-SHARE] No stored path found, trying with prefix: ${reportPath}`);
          
          // If not found, try without prefix (old format)
          if (!await fse.pathExists(reportPath)) {
            fileName = `${imageId}.pdf`;
            reportPath = path.join(reportsDir, fileName);
            console.log(`[EMAIL-SHARE] File not found with prefix, trying without prefix: ${reportPath}`);
          }
        }
      } else {
        // For reports, use the stored reportFilePath if available
        if (study.reportFilePath) {
          // Paths starting with /uploads are relative to working directory, not absolute system paths
          if (study.reportFilePath.startsWith('/uploads/') || study.reportFilePath.startsWith('uploads/')) {
            // Convert to absolute path from working directory
            reportPath = path.resolve(process.cwd(), study.reportFilePath.replace(/^\//, ''));
          } else if (path.isAbsolute(study.reportFilePath)) {
            // True absolute system paths (like /home/runner/...)
            reportPath = study.reportFilePath;
          } else {
            // Relative paths
            reportPath = path.resolve(process.cwd(), study.reportFilePath);
          }
          console.log(`[EMAIL-SHARE] Using stored reportFilePath: ${study.reportFilePath}`);
          console.log(`[EMAIL-SHARE] Final path to share report from: ${reportPath}`);
        } else {
          // Fallback: Try to find the imaging report
          const reportsDir = path.resolve(process.cwd(), 'uploads', 'Imaging_Reports', String(organizationId), 'patients', String(study.patientId));
          const fileName = `${imageId}.pdf`;
          reportPath = path.join(reportsDir, fileName);
          console.log(`[EMAIL-SHARE] No stored report path, trying constructed path: ${reportPath}`);
        }
      }
      
      // Check if the PDF exists
      if (!await fse.pathExists(reportPath)) {
        const docType = shareSource === 'prescription' ? 'Image prescription' : 'Imaging report';
        console.error(`[EMAIL-SHARE] ${docType} PDF not found:`, reportPath);
        console.error(`[EMAIL-SHARE] Study details:`, { 
          imageId: study.imageId, 
          prescriptionFilePath: study.prescriptionFilePath,
          reportFilePath: study.reportFilePath,
          shareSource 
        });
        return res.status(404).json({ 
          error: shareSource === 'prescription' 
            ? 'No image prescription found. Please generate one first.' 
            : 'No imaging report found. Please generate one first.'
        });
      }

      console.log('[EMAIL-SHARE] Loading imaging report PDF:', reportPath);
      const buffer = await fs.promises.readFile(reportPath);
      let pdfBytes = new Uint8Array(buffer);
      
      // Extract filename from path for email attachment
      const fileName = path.basename(reportPath);
      
      // Skip the old prescription PDF generation code
      if (false) {
        console.log('[EMAIL-SHARE] Old code - removed');
        
        // Import pdf-lib dynamically
        const { PDFDocument, rgb, StandardFonts } = await import('pdf-lib');
      
      // Fetch clinic footer data
      const clinicFooterRecords = await db
        .select()
        .from(clinicFooters)
        .where(eq(clinicFooters.organizationId, organizationId))
        .limit(1);
      
      const footerData = clinicFooterRecords[0] || null;
      
      // Create PDF with two-column layout matching lab result prescription format
      const pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage([595, 842]); // A4 size
      const { width, height } = page.getSize();
      
      // Load fonts
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
      
      // Color definitions
      const darkText = rgb(0.2, 0.2, 0.2);
      const lightGray = rgb(0.95, 0.95, 0.95);
      const borderGray = rgb(0.85, 0.85, 0.85);
      const greenText = rgb(0, 0.6, 0);
      const yellowBg = rgb(1, 0.98, 0.85);
      const redBg = rgb(1, 0.93, 0.93);
      
      // HEADER - Purple gradient effect
      page.drawRectangle({
        x: 0,
        y: height - 120,
        width,
        height: 120,
        color: rgb(0.31, 0.27, 0.9)
      });
      
      // Organization Name - CURA EMR SYSTEM
      page.drawText(footerData?.organizationName || 'CURA EMR SYSTEM', {
        x: 40,
        y: height - 50,
        size: 22,
        font: boldFont,
        color: rgb(1, 1, 1)
      });
      
      page.drawText('MEDICAL IMAGING PRESCRIPTION', {
        x: 40,
        y: height - 75,
        size: 12,
        font: boldFont,
        color: rgb(1, 1, 1)
      });
      
      // Patient Details Section (Gray Background)
      let yPosition = height - 150;
      
      page.drawRectangle({
        x: 30,
        y: yPosition - 70,
        width: width - 60,
        height: 75,
        color: lightGray,
        borderColor: borderGray,
        borderWidth: 1
      });
      
      page.drawText('Patient Information', {
        x: 40,
        y: yPosition,
        size: 11,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 25;
      
      const col1X = 50;
      const col2X = 310;
      
      page.drawText(`Patient Name:`, {
        x: col1X,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      page.drawText(`${patient.firstName} ${patient.lastName}`, {
        x: col1X + 85,
        y: yPosition,
        size: 9,
        font: boldFont,
        color: darkText
      });
      
      page.drawText(`Patient ID:`, {
        x: col2X,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      page.drawText(String(patient.patientId), {
        x: col2X + 70,
        y: yPosition,
        size: 9,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 18;
      
      page.drawText(`DOB:`, {
        x: col1X,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      page.drawText(patient.dateOfBirth ? new Date(patient.dateOfBirth).toLocaleDateString() : 'N/A', {
        x: col1X + 85,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      page.drawText(`Gender:`, {
        x: col2X,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      page.drawText(patient.gender || 'N/A', {
        x: col2X + 70,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      yPosition -= 35;
      
      // Imaging Study Section
      page.drawText('Imaging Study Prescription', {
        x: 40,
        y: yPosition,
        size: 11,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 25;
      
      page.drawText(`Image ID:`, {
        x: col1X,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      page.drawText(imageId, {
        x: col1X + 70,
        y: yPosition,
        size: 9,
        font: boldFont,
        color: darkText
      });
      
      page.drawText(`Study Type:`, {
        x: col2X,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      page.drawText(study.studyType, {
        x: col2X + 70,
        y: yPosition,
        size: 9,
        font: boldFont,
        color: darkText
      });
      
      yPosition -= 18;
      
      page.drawText(`Modality: ${study.modality}`, {
        x: col1X,
        y: yPosition,
        size: 9,
        font,
        color: darkText
      });
      
      if (study.bodyPart) {
        page.drawText(`Body Part: ${study.bodyPart}`, {
          x: col2X,
          y: yPosition,
          size: 9,
          font,
          color: darkText
        });
      }
      
      yPosition -= 30;
      
      // Clinical Notes Section
      if (study.indication || study.findings) {
        page.drawRectangle({
          x: 30,
          y: yPosition - 50,
          width: width - 60,
          height: 55,
          color: yellowBg,
          borderColor: rgb(0.9, 0.85, 0.3),
          borderWidth: 1
        });
        
        page.drawText('Clinical Notes:', {
          x: 40,
          y: yPosition,
          size: 10,
          font: boldFont,
          color: darkText
        });
        
        yPosition -= 20;
        
        const notesText = study.indication || study.findings || 'No clinical notes available';
        page.drawText(notesText.substring(0, 120), {
          x: 40,
          y: yPosition,
          size: 9,
          font,
          color: darkText
        });
        
        yPosition -= 40;
      }
      
      // Footer
      const footerY = 50;
      page.drawText(footerData?.address || 'Medical Center, Healthcare District', {
        x: 40,
        y: footerY + 40,
        size: 8,
        font,
        color: darkText
      });
      
      page.drawText(
        req.user?.firstName && req.user?.lastName 
          ? `${req.user.firstName} ${req.user.lastName}` 
          : 'Authorized Medical Staff', {
        x: width - 180,
        y: footerY + 30,
        size: 8,
        font,
        color: darkText
      });
      
        // Generate and save PDF
        pdfBytes = await pdfDoc.save();
        await fse.outputFile(outputPath, pdfBytes);
        
        console.log(`[EMAIL-SHARE] Image prescription PDF generated: ${outputPath}`);
      }
      
      // Send the email with PDF attachment
      const patientName = `${patient.firstName} ${patient.lastName}`;
      const studyType = study.studyDescription || study.studyType || 'Medical Imaging Study';
      const sharedBy = req.user.email;
      
      // Customize email content based on shareSource
      const isPrescription = shareSource === 'prescription';
      const emailTitle = isPrescription ? 'Image Prescription' : 'Diagnostic Radiology Report';
      const emailDescription = isPrescription ? 'imaging prescription' : 'diagnostic imaging report';

      const emailSent = await emailService.sendEmail({
        to: recipientEmail,
        subject: `${isPrescription ? 'Image Prescription' : 'Imaging Report'} - ${patientName} - ${studyType}`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <div style="background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%); color: white; padding: 30px; text-align: center;">
              <h1 style="margin: 0;">${emailTitle}</h1>
            </div>
            
            <div style="padding: 30px; background-color: #f8fafc;">
              <p>Dear Colleague,</p>
              
              <p>A ${emailDescription} has been shared with you by <strong>${sharedBy}</strong>:</p>
              
              <div style="background-color: white; padding: 20px; border-left: 4px solid #4F46E5; margin: 20px 0;">
                <p><strong>Patient:</strong> ${patientName}</p>
                <p><strong>Study Type:</strong> ${studyType}</p>
                <p><strong>Image ID:</strong> ${imageId}</p>
                <p><strong>Shared by:</strong> ${sharedBy}</p>
                <p><strong>Date Shared:</strong> ${new Date().toLocaleDateString()}</p>
              </div>
              
              ${customMessage ? `
              <div style="background-color: #fffbeb; padding: 15px; border-left: 4px solid #f59e0b; margin: 20px 0;">
                <p><strong>Message from ${sharedBy}:</strong></p>
                <p style="font-style: italic;">${customMessage}</p>
              </div>
              ` : ''}
              
              <p>The ${emailDescription} is attached to this email as a PDF document.</p>
              
              <p style="color: #dc2626; font-weight: bold;">‚ö†Ô∏è CONFIDENTIAL MEDICAL INFORMATION</p>
              <p style="font-size: 12px; color: #666;">This ${isPrescription ? 'prescription' : 'study'} has been shared for medical consultation purposes. Please ensure appropriate patient confidentiality is maintained.</p>
              
              <p>Best regards,<br>Cura EMR Team</p>
            </div>
            
            <div style="background-color: #1e293b; color: white; padding: 20px; text-align: center; font-size: 12px;">
              <p>¬© 2025 Cura EMR by Halo Group. All rights reserved.</p>
            </div>
          </div>
        `,
        text: `
Dear Colleague,

A ${emailDescription} has been shared with you by ${sharedBy}:

Patient: ${patientName}
Study Type: ${studyType}
Image ID: ${imageId}
Shared by: ${sharedBy}
Date Shared: ${new Date().toLocaleDateString()}

${customMessage ? `Message from ${sharedBy}: ${customMessage}\n` : ''}

The ${emailDescription} is attached to this email.

This ${isPrescription ? 'prescription' : 'study'} has been shared for medical consultation purposes. Please ensure appropriate patient confidentiality is maintained.

Best regards,
Cura EMR Team
        `,
        attachments: [
          {
            filename: fileName,
            content: Buffer.from(pdfBytes),
            contentType: 'application/pdf'
          }
        ]
      });

      if (emailSent) {
        // Update orderStudyShared flag to true
        try {
          await storage.updateMedicalImage(studyId, req.tenant!.id, { orderStudyShared: true });
          console.log(`[EMAIL-SHARE] Updated orderStudyShared flag for study ${studyId}`);
        } catch (dbError) {
          console.error(`[EMAIL-SHARE] Failed to update orderStudyShared flag:`, dbError);
        }
        
        const docType = isPrescription ? 'image prescription' : 'imaging report';
        console.log(`[EMAIL-SHARE] Successfully shared ${docType} ${studyId} with ${recipientEmail}`);
        res.json({
          success: true,
          message: `${isPrescription ? 'Image prescription' : 'Imaging report'} shared successfully with ${recipientEmail}`,
          studyId,
          recipientEmail,
          patientName
        });
      } else {
        const docType = isPrescription ? 'image prescription' : 'imaging report';
        console.error(`[EMAIL-SHARE] Failed to share ${docType} ${studyId} with ${recipientEmail}`);
        res.status(500).json({
          error: "Failed to send email. Please try again or contact support.",
          studyId,
          recipientEmail
        });
      }

    } catch (error) {
      console.error("[EMAIL-SHARE] Share imaging study error:", error);
      res.status(500).json({ error: "Failed to share imaging study" });
    }
  });

  // Check if PDF Report exists
  app.head("/api/imaging/reports/:reportId", authMiddleware, async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { reportId } = req.params;
      
      // Find the study by imageId to get organizationId and patientId
      const studies = await storage.getMedicalImagesByOrganization(req.tenant!.id);
      const study = studies.find(s => s.imageId === reportId);
      
      if (!study) {
        return res.status(404).send();
      }
      
      const organizationId = study.organizationId;
      const patientId = study.patientId;
      
      // PDF files are stored in uploads/Imaging_Reports/{organizationId}/patients/{patientId}/{imageId}.pdf
      const filePath = path.resolve(
        process.cwd(), 
        'uploads', 
        'Imaging_Reports', 
        String(organizationId), 
        'patients', 
        String(patientId), 
        `${reportId}.pdf`
      );
      
      // Check if file exists
      if (!(await fse.pathExists(filePath))) {
        return res.status(404).send();
      }
      
      res.status(200).send();

    } catch (error) {
      console.error("PDF check error:", error);
      res.status(500).send();
    }
  });

  // Serve PDF Reports (supports both header and query param authentication for iframe compatibility)
  app.get("/api/imaging/reports/:reportId", async (req: TenantRequest, res) => {
    try {
      // Support both Authorization header and query parameter token for iframe compatibility
      let token = req.headers.authorization?.replace('Bearer ', '');
      if (!token && req.query.token) {
        token = req.query.token as string;
      }

      console.log('üìÑ PDF ROUTE: Token check:', { 
        hasAuthHeader: !!req.headers.authorization, 
        hasQueryToken: !!req.query.token,
        tokenLength: token?.length 
      });

      if (!token) {
        console.log('üìÑ PDF ROUTE: No token found');
        return res.status(401).json({ error: "Authentication required" });
      }

      // Verify the token using authService
      const payload = authService.verifyToken(token);
      
      if (!payload) {
        console.log('üìÑ PDF ROUTE: Token verification failed - invalid token');
        return res.status(401).json({ error: "Invalid or expired token" });
      }
      
      req.user = { 
        id: payload.userId, 
        email: payload.email, 
        role: payload.role,
        organizationId: payload.organizationId 
      };
      console.log('üìÑ PDF ROUTE: Token verified successfully for user:', req.user.email);

      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { reportId } = req.params;
      
      // Use organizationId from the decoded token if tenant is not set
      const orgId = req.tenant?.id || req.user.organizationId;
      console.log('üìÑ PDF ROUTE: Using organizationId:', orgId);
      
      // Find the study by imageId to get organizationId and patientId
      const studies = await storage.getMedicalImagesByOrganization(orgId);
      const study = studies.find(s => s.imageId === reportId);
      
      if (!study) {
        return res.status(404).json({ error: "Study not found" });
      }
      
      const organizationId = study.organizationId;
      const patientId = study.patientId;
      
      // PDF files are stored in uploads/Imaging_Reports/{organizationId}/patients/{patientId}/{imageId}.pdf
      const filePath = path.resolve(
        process.cwd(), 
        'uploads', 
        'Imaging_Reports', 
        String(organizationId), 
        'patients', 
        String(patientId), 
        `${reportId}.pdf`
      );
      
      console.log('üìÑ PDF ROUTE: Serving file from:', filePath);
      
      // Check if file exists
      if (!(await fse.pathExists(filePath))) {
        return res.status(404).json({ error: "Report not found" });
      }
      
      // Generate a meaningful filename for download (reportId is the image/study ID)
      const downloadFilename = `radiology-report-${reportId}.pdf`;
      
      // Check if this is a download request vs view request
      const isDownload = req.query.download === 'true';
      
      // Serve the PDF file
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `${isDownload ? 'attachment' : 'inline'}; filename="${downloadFilename}"`);
      res.sendFile(filePath);

    } catch (error) {
      console.error("PDF serving error:", error);
      res.status(500).json({ error: "Failed to serve PDF report" });
    }
  });

  // Delete PDF Report
  app.delete("/api/imaging/reports/:reportId", authMiddleware, requireRole(["doctor", "nurse", "admin"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { reportId } = req.params;
      
      // Find the study by imageId to get organizationId and patientId
      console.log(`üìù DELETE: Finding study by imageId: ${reportId}`);
      const studies = await storage.getMedicalImagesByOrganization(req.tenant!.id);
      const study = studies.find(s => s.imageId === reportId);
      
      if (!study) {
        return res.status(404).json({ error: "Study not found" });
      }
      
      const organizationId = study.organizationId;
      const patientId = study.patientId;
      
      // PDF files are stored in uploads/Imaging_Reports/{organizationId}/patients/{patientId}/{imageId}.pdf
      const filename = `${reportId}.pdf`;
      const filePath = path.resolve(
        process.cwd(), 
        'uploads', 
        'Imaging_Reports', 
        String(organizationId), 
        'patients', 
        String(patientId), 
        filename
      );

      // Check if file exists
      if (!(await fse.pathExists(filePath))) {
        return res.status(404).json({ error: "Report file not found" });
      }

      // Delete the file from the filesystem
      await fse.remove(filePath);

      // Clear the reportFileName and reportFilePath from the database
      try {
        if (study && study.id) {
          // Update the database to clear both report fields (use null, not undefined, to actually set DB to NULL)
          console.log(`üìù DELETE: Updating database for studyId: ${study.id}, imageId: ${reportId}, organizationId: ${req.tenant!.id}`);
          await storage.updateMedicalImageReport(
            study.id,
            req.tenant!.id,
            { 
              reportFileName: null as any, 
              reportFilePath: null as any 
            }
          );
          console.log(`üìù DELETE: Database updated - set reportFileName and reportFilePath to NULL for studyId: ${study.id}`);
        }
      } catch (dbError) {
        console.error(`‚ö†Ô∏è DELETE: Database update error:`, dbError);
      }

      console.log(`‚úÖ PDF report deleted successfully: ${filename}`);
      res.json({ 
        success: true, 
        message: "Report deleted successfully",
        reportId: reportId
      });

    } catch (error) {
      console.error("Error deleting PDF report:", error);
      res.status(500).json({ error: "Failed to delete report" });
    }
  });

  // Update Individual Report Field
  app.patch("/api/imaging/studies/:studyId/report-field", authMiddleware, requireRole(["doctor", "nurse"]), async (req: TenantRequest, res) => {
    try {
      if (!req.user || !req.organizationId) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const { studyId } = req.params;
      const { fieldName, value } = req.body;

      // Validate request body
      const validation = updateMedicalImageReportFieldSchema.safeParse({ fieldName, value });
      if (!validation.success) {
        return res.status(400).json({ error: "Invalid field data", details: validation.error.issues });
      }

      // Update the specific field
      const updatedStudy = await storage.updateMedicalImageReportField(
        parseInt(studyId),
        req.organizationId,
        fieldName,
        value
      );

      if (!updatedStudy) {
        return res.status(404).json({ error: "Study not found" });
      }

      res.json({
        success: true,
        studyId: updatedStudy.id,
        updated: {
          [fieldName]: value
        }
      });

    } catch (error) {
      console.error("Error updating report field:", error);
      res.status(500).json({ error: "Failed to update report field" });
    }
  });

  // ========================================
  // QuickBooks Integration API Routes
  // ========================================

  // Get all QuickBooks connections for organization
  app.get("/api/quickbooks/connections", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connections = await storage.getQuickBooksConnections(organizationId);
      res.json(connections);
    } catch (error) {
      console.error("Error fetching QuickBooks connections:", error);
      res.status(500).json({ error: "Failed to fetch connections" });
    }
  });

  // Get active QuickBooks connection
  app.get("/api/quickbooks/connection/active", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connection = await storage.getActiveQuickBooksConnection(organizationId);
      if (!connection) {
        return res.status(404).json({ error: "No active QuickBooks connection found" });
      }
      res.json(connection);
    } catch (error) {
      console.error("Error fetching active QuickBooks connection:", error);
      res.status(500).json({ error: "Failed to fetch active connection" });
    }
  });

  // Disconnect active QuickBooks connection
  app.delete("/api/quickbooks/connection/active", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      
      // Find and deactivate the active connection
      const activeConnection = await db.select()
        .from(quickbooksConnections)
        .where(and(
          eq(quickbooksConnections.organizationId, organizationId),
          eq(quickbooksConnections.isActive, true)
        ))
        .limit(1);

      if (activeConnection.length === 0) {
        return res.status(404).json({ error: "No active QuickBooks connection found" });
      }

      // Deactivate the connection
      await db.update(quickbooksConnections)
        .set({ 
          isActive: false,
          updatedAt: new Date()
        })
        .where(eq(quickbooksConnections.id, activeConnection[0].id));

      res.json({ success: true, message: "QuickBooks connection disconnected" });
    } catch (error) {
      console.error("Error disconnecting QuickBooks:", error);
      res.status(500).json({ error: "Failed to disconnect QuickBooks" });
    }
  });

  // Create QuickBooks connection (OAuth callback handler)
  app.post("/api/quickbooks/connections", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      
      const connectionSchema = z.object({
        companyId: z.string(),
        companyName: z.string(),
        accessToken: z.string(),
        refreshToken: z.string(),
        tokenExpiry: z.string().transform((val) => new Date(val)),
        realmId: z.string(),
        baseUrl: z.string(),
        syncSettings: z.object({
          autoSync: z.boolean().optional(),
          syncIntervalHours: z.number().optional(),
          syncCustomers: z.boolean().optional(),
          syncInvoices: z.boolean().optional(),
          syncPayments: z.boolean().optional(),
          syncItems: z.boolean().optional(),
          syncAccounts: z.boolean().optional(),
        }).optional(),
      });

      const validatedData = connectionSchema.parse(req.body);
      
      // Deactivate existing connections
      const existingConnections = await storage.getQuickBooksConnections(organizationId);
      for (const existing of existingConnections) {
        if (existing.isActive) {
          await storage.updateQuickBooksConnection(existing.id, organizationId, { isActive: false });
        }
      }

      const connection = await storage.createQuickBooksConnection({
        ...validatedData,
        organizationId,
        isActive: true,
      });

      res.status(201).json(connection);
    } catch (error) {
      console.error("Error creating QuickBooks connection:", error);
      res.status(500).json({ error: "Failed to create connection" });
    }
  });

  // Update QuickBooks connection
  app.patch("/api/quickbooks/connections/:id", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connectionId = parseInt(req.params.id);

      const updateSchema = z.object({
        accessToken: z.string().optional(),
        refreshToken: z.string().optional(),
        tokenExpiry: z.string().transform((val) => new Date(val)).optional(),
        isActive: z.boolean().optional(),
        syncSettings: z.object({
          autoSync: z.boolean().optional(),
          syncIntervalHours: z.number().optional(),
          syncCustomers: z.boolean().optional(),
          syncInvoices: z.boolean().optional(),
          syncPayments: z.boolean().optional(),
          syncItems: z.boolean().optional(),
          syncAccounts: z.boolean().optional(),
        }).optional(),
      });

      const validatedData = updateSchema.parse(req.body);
      const updatedConnection = await storage.updateQuickBooksConnection(connectionId, organizationId, validatedData);

      if (!updatedConnection) {
        return res.status(404).json({ error: "Connection not found" });
      }

      res.json(updatedConnection);
    } catch (error) {
      console.error("Error updating QuickBooks connection:", error);
      res.status(500).json({ error: "Failed to update connection" });
    }
  });

  // Delete QuickBooks connection
  app.delete("/api/quickbooks/connections/:id", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connectionId = parseInt(req.params.id);

      const success = await storage.deleteQuickBooksConnection(connectionId, organizationId);
      if (!success) {
        return res.status(404).json({ error: "Connection not found" });
      }

      res.json({ message: "Connection deleted successfully" });
    } catch (error) {
      console.error("Error deleting QuickBooks connection:", error);
      res.status(500).json({ error: "Failed to delete connection" });
    }
  });

  // Get QuickBooks sync logs
  app.get("/api/quickbooks/sync-logs", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connectionId = req.query.connectionId ? parseInt(req.query.connectionId as string) : undefined;
      const syncType = req.query.syncType as string | undefined;

      const logs = await storage.getQuickBooksSyncLogs(organizationId, connectionId, syncType);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching QuickBooks sync logs:", error);
      res.status(500).json({ error: "Failed to fetch sync logs" });
    }
  });

  // Create QuickBooks sync log
  app.post("/api/quickbooks/sync-logs", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);

      const logSchema = z.object({
        connectionId: z.number(),
        syncType: z.string(),
        operation: z.string(),
        status: z.string().default("pending"),
        recordsProcessed: z.number().default(0),
        recordsSuccessful: z.number().default(0),
        recordsFailed: z.number().default(0),
        startTime: z.string().transform((val) => new Date(val)),
        endTime: z.string().transform((val) => new Date(val)).optional(),
        errorMessage: z.string().optional(),
        errorDetails: z.any().optional(),
        metadata: z.any().optional(),
      });

      const validatedData = logSchema.parse(req.body);
      const log = await storage.createQuickBooksSyncLog({
        ...validatedData,
        organizationId,
      });

      res.status(201).json(log);
    } catch (error) {
      console.error("Error creating QuickBooks sync log:", error);
      res.status(500).json({ error: "Failed to create sync log" });
    }
  });

  // Update QuickBooks sync log
  app.patch("/api/quickbooks/sync-logs/:id", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const logId = parseInt(req.params.id);

      const updateSchema = z.object({
        status: z.string().optional(),
        recordsProcessed: z.number().optional(),
        recordsSuccessful: z.number().optional(),
        recordsFailed: z.number().optional(),
        endTime: z.string().transform((val) => new Date(val)).optional(),
        errorMessage: z.string().optional(),
        errorDetails: z.any().optional(),
        metadata: z.any().optional(),
      });

      const validatedData = updateSchema.parse(req.body);
      const updatedLog = await storage.updateQuickBooksSyncLog(logId, validatedData);

      if (!updatedLog) {
        return res.status(404).json({ error: "Sync log not found" });
      }

      res.json(updatedLog);
    } catch (error) {
      console.error("Error updating QuickBooks sync log:", error);
      res.status(500).json({ error: "Failed to update sync log" });
    }
  });

  // Get QuickBooks customer mappings
  app.get("/api/quickbooks/customer-mappings", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connectionId = req.query.connectionId ? parseInt(req.query.connectionId as string) : undefined;

      const mappings = await storage.getQuickBooksCustomerMappings(organizationId, connectionId);
      res.json(mappings);
    } catch (error) {
      console.error("Error fetching QuickBooks customer mappings:", error);
      res.status(500).json({ error: "Failed to fetch customer mappings" });
    }
  });

  // Create QuickBooks customer mapping
  app.post("/api/quickbooks/customer-mappings", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);

      const mappingSchema = z.object({
        connectionId: z.number(),
        patientId: z.number(),
        quickbooksCustomerId: z.string(),
        quickbooksDisplayName: z.string().optional(),
        syncStatus: z.string().default("synced"),
        lastSyncAt: z.string().transform((val) => new Date(val)).optional(),
        errorMessage: z.string().optional(),
        metadata: z.any().optional(),
      });

      const validatedData = mappingSchema.parse(req.body);
      const mapping = await storage.createQuickBooksCustomerMapping({
        ...validatedData,
        organizationId,
      });

      res.status(201).json(mapping);
    } catch (error) {
      console.error("Error creating QuickBooks customer mapping:", error);
      res.status(500).json({ error: "Failed to create customer mapping" });
    }
  });

  // Get QuickBooks invoice mappings
  app.get("/api/quickbooks/invoice-mappings", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connectionId = req.query.connectionId ? parseInt(req.query.connectionId as string) : undefined;

      const mappings = await storage.getQuickBooksInvoiceMappings(organizationId, connectionId);
      res.json(mappings);
    } catch (error) {
      console.error("Error fetching QuickBooks invoice mappings:", error);
      res.status(500).json({ error: "Failed to fetch invoice mappings" });
    }
  });

  // Create QuickBooks invoice mapping
  app.post("/api/quickbooks/invoice-mappings", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);

      const mappingSchema = z.object({
        connectionId: z.number(),
        emrInvoiceId: z.string(),
        quickbooksInvoiceId: z.string(),
        quickbooksInvoiceNumber: z.string().optional(),
        patientId: z.number(),
        customerId: z.number().optional(),
        amount: z.string(),
        status: z.string(),
        syncStatus: z.string().default("synced"),
        lastSyncAt: z.string().transform((val) => new Date(val)).optional(),
        errorMessage: z.string().optional(),
        metadata: z.any().optional(),
      });

      const validatedData = mappingSchema.parse(req.body);
      const mapping = await storage.createQuickBooksInvoiceMapping({
        ...validatedData,
        organizationId,
      });

      res.status(201).json(mapping);
    } catch (error) {
      console.error("Error creating QuickBooks invoice mapping:", error);
      res.status(500).json({ error: "Failed to create invoice mapping" });
    }
  });

  // Get QuickBooks payment mappings
  app.get("/api/quickbooks/payment-mappings", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connectionId = req.query.connectionId ? parseInt(req.query.connectionId as string) : undefined;

      const mappings = await storage.getQuickBooksPaymentMappings(organizationId, connectionId);
      res.json(mappings);
    } catch (error) {
      console.error("Error fetching QuickBooks payment mappings:", error);
      res.status(500).json({ error: "Failed to fetch payment mappings" });
    }
  });

  // Create QuickBooks payment mapping
  app.post("/api/quickbooks/payment-mappings", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);

      const mappingSchema = z.object({
        connectionId: z.number(),
        emrPaymentId: z.string(),
        quickbooksPaymentId: z.string(),
        invoiceMappingId: z.number().optional(),
        amount: z.string(),
        paymentMethod: z.string(),
        paymentDate: z.string().transform((val) => new Date(val)),
        syncStatus: z.string().default("synced"),
        lastSyncAt: z.string().transform((val) => new Date(val)).optional(),
        errorMessage: z.string().optional(),
        metadata: z.any().optional(),
      });

      const validatedData = mappingSchema.parse(req.body);
      const mapping = await storage.createQuickBooksPaymentMapping({
        ...validatedData,
        organizationId,
      });

      res.status(201).json(mapping);
    } catch (error) {
      console.error("Error creating QuickBooks payment mapping:", error);
      res.status(500).json({ error: "Failed to create payment mapping" });
    }
  });

  // Get QuickBooks account mappings
  app.get("/api/quickbooks/account-mappings", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connectionId = req.query.connectionId ? parseInt(req.query.connectionId as string) : undefined;

      const mappings = await storage.getQuickBooksAccountMappings(organizationId, connectionId);
      res.json(mappings);
    } catch (error) {
      console.error("Error fetching QuickBooks account mappings:", error);
      res.status(500).json({ error: "Failed to fetch account mappings" });
    }
  });

  // Create QuickBooks account mapping
  app.post("/api/quickbooks/account-mappings", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);

      const mappingSchema = z.object({
        connectionId: z.number(),
        emrAccountType: z.string(),
        emrAccountName: z.string(),
        quickbooksAccountId: z.string(),
        quickbooksAccountName: z.string(),
        accountType: z.string(),
        accountSubType: z.string().optional(),
        isActive: z.boolean().default(true),
        syncStatus: z.string().default("synced"),
        lastSyncAt: z.string().transform((val) => new Date(val)).optional(),
        errorMessage: z.string().optional(),
        metadata: z.any().optional(),
      });

      const validatedData = mappingSchema.parse(req.body);
      const mapping = await storage.createQuickBooksAccountMapping({
        ...validatedData,
        organizationId,
      });

      res.status(201).json(mapping);
    } catch (error) {
      console.error("Error creating QuickBooks account mapping:", error);
      res.status(500).json({ error: "Failed to create account mapping" });
    }
  });

  // Get QuickBooks item mappings
  app.get("/api/quickbooks/item-mappings", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connectionId = req.query.connectionId ? parseInt(req.query.connectionId as string) : undefined;

      const mappings = await storage.getQuickBooksItemMappings(organizationId, connectionId);
      res.json(mappings);
    } catch (error) {
      console.error("Error fetching QuickBooks item mappings:", error);
      res.status(500).json({ error: "Failed to fetch item mappings" });
    }
  });

  // Create QuickBooks item mapping
  app.post("/api/quickbooks/item-mappings", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);

      const mappingSchema = z.object({
        connectionId: z.number(),
        emrItemType: z.string(),
        emrItemId: z.string(),
        emrItemName: z.string(),
        quickbooksItemId: z.string(),
        quickbooksItemName: z.string(),
        itemType: z.string(),
        unitPrice: z.string().optional(),
        description: z.string().optional(),
        incomeAccountId: z.string().optional(),
        expenseAccountId: z.string().optional(),
        isActive: z.boolean().default(true),
        syncStatus: z.string().default("synced"),
        lastSyncAt: z.string().transform((val) => new Date(val)).optional(),
        errorMessage: z.string().optional(),
        metadata: z.any().optional(),
      });

      const validatedData = mappingSchema.parse(req.body);
      const mapping = await storage.createQuickBooksItemMapping({
        ...validatedData,
        organizationId,
      });

      res.status(201).json(mapping);
    } catch (error) {
      console.error("Error creating QuickBooks item mapping:", error);
      res.status(500).json({ error: "Failed to create item mapping" });
    }
  });

  // Get QuickBooks sync configurations
  app.get("/api/quickbooks/sync-configs", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connectionId = req.query.connectionId ? parseInt(req.query.connectionId as string) : undefined;

      const configs = await storage.getQuickBooksSyncConfigs(organizationId, connectionId);
      res.json(configs);
    } catch (error) {
      console.error("Error fetching QuickBooks sync configurations:", error);
      res.status(500).json({ error: "Failed to fetch sync configurations" });
    }
  });

  // Create QuickBooks sync configuration
  app.post("/api/quickbooks/sync-configs", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const userId = req.user?.id;

      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }

      const configSchema = z.object({
        connectionId: z.number(),
        configType: z.string(),
        configName: z.string(),
        configValue: z.any(),
        isActive: z.boolean().default(true),
        description: z.string().optional(),
      });

      const validatedData = configSchema.parse(req.body);
      const config = await storage.createQuickBooksSyncConfig({
        ...validatedData,
        organizationId,
        createdBy: userId,
      });

      res.status(201).json(config);
    } catch (error) {
      console.error("Error creating QuickBooks sync configuration:", error);
      res.status(500).json({ error: "Failed to create sync configuration" });
    }
  });

  // Manual sync trigger endpoints
  app.post("/api/quickbooks/sync/customers", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connection = await storage.getActiveQuickBooksConnection(organizationId);
      
      if (!connection) {
        return res.status(400).json({ error: "No active QuickBooks connection found" });
      }

      // Create sync log entry
      const syncLog = await storage.createQuickBooksSyncLog({
        organizationId,
        connectionId: connection.id,
        syncType: "customers",
        operation: "sync",
        status: "pending",
        startTime: new Date(),
        recordsProcessed: 0,
        recordsSuccessful: 0,
        recordsFailed: 0,
      });

      // In a real implementation, this would trigger actual QuickBooks API calls
      // For now, we'll just update the log as successful
      await storage.updateQuickBooksSyncLog(syncLog.id, {
        status: "success",
        endTime: new Date(),
        recordsProcessed: 0,
        recordsSuccessful: 0,
        recordsFailed: 0,
      });

      res.json({ message: "Customer sync initiated", syncLogId: syncLog.id });
    } catch (error) {
      console.error("Error initiating customer sync:", error);
      res.status(500).json({ error: "Failed to initiate customer sync" });
    }
  });

  app.post("/api/quickbooks/sync/invoices", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connection = await storage.getActiveQuickBooksConnection(organizationId);
      
      if (!connection) {
        return res.status(400).json({ error: "No active QuickBooks connection found" });
      }

      // Create sync log entry
      const syncLog = await storage.createQuickBooksSyncLog({
        organizationId,
        connectionId: connection.id,
        syncType: "invoices",
        operation: "sync",
        status: "pending",
        startTime: new Date(),
        recordsProcessed: 0,
        recordsSuccessful: 0,
        recordsFailed: 0,
      });

      // In a real implementation, this would trigger actual QuickBooks API calls
      await storage.updateQuickBooksSyncLog(syncLog.id, {
        status: "success",
        endTime: new Date(),
        recordsProcessed: 0,
        recordsSuccessful: 0,
        recordsFailed: 0,
      });

      res.json({ message: "Invoice sync initiated", syncLogId: syncLog.id });
    } catch (error) {
      console.error("Error initiating invoice sync:", error);
      res.status(500).json({ error: "Failed to initiate invoice sync" });
    }
  });

  app.post("/api/quickbooks/sync/payments", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const connection = await storage.getActiveQuickBooksConnection(organizationId);
      
      if (!connection) {
        return res.status(400).json({ error: "No active QuickBooks connection found" });
      }

      // Create sync log entry
      const syncLog = await storage.createQuickBooksSyncLog({
        organizationId,
        connectionId: connection.id,
        syncType: "payments",
        operation: "sync",
        status: "pending",
        startTime: new Date(),
        recordsProcessed: 0,
        recordsSuccessful: 0,
        recordsFailed: 0,
      });

      // In a real implementation, this would trigger actual QuickBooks API calls
      await storage.updateQuickBooksSyncLog(syncLog.id, {
        status: "success",
        endTime: new Date(),
        recordsProcessed: 0,
        recordsSuccessful: 0,
        recordsFailed: 0,
      });

      res.json({ message: "Payment sync initiated", syncLogId: syncLog.id });
    } catch (error) {
      console.error("Error initiating payment sync:", error);
      res.status(500).json({ error: "Failed to initiate payment sync" });
    }
  });

  // QuickBooks OAuth authentication endpoints
  app.get("/api/quickbooks/auth/url", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      console.log("[QUICKBOOKS] OAuth URL endpoint reached!");
      const clientId = process.env.QUICKBOOKS_CLIENT_ID;
      console.log("[QUICKBOOKS] Client ID exists:", !!clientId);
      const redirectUri = process.env.QUICKBOOKS_REDIRECT_URI || `${process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}` : 'http://localhost:5000'}/api/quickbooks/auth/callback`;
      console.log("[QUICKBOOKS] Redirect URI:", redirectUri);
      
      if (!clientId) {
        console.log("[QUICKBOOKS] ERROR: Client ID is missing!");
        return res.status(500).json({ error: "QuickBooks Client ID not configured" });
      }
      
      // Include organization ID in state to preserve tenant context through OAuth flow
      const organizationId = req.tenant?.id;
      const stateData = JSON.stringify({ orgId: organizationId, token: 'security_token' });
      const state = Buffer.from(stateData).toString('base64');
      console.log("[QUICKBOOKS] State with orgId:", organizationId);
      
      const oauthUrl = `https://appcenter.intuit.com/connect/oauth2?client_id=${clientId}&scope=com.intuit.quickbooks.accounting&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&state=${encodeURIComponent(state)}&access_type=offline`;
      console.log("[QUICKBOOKS] Generated OAuth URL, sending response...");
      res.json({ url: oauthUrl });
      console.log("[QUICKBOOKS] Response sent successfully");
    } catch (error) {
      console.error("[QUICKBOOKS] Error generating OAuth URL:", error);
      res.status(500).json({ error: "Failed to generate OAuth URL" });
    }
  });

  // QuickBooks Data Fetching Endpoints
  // Helper function to get QuickBooks connection and make API calls
  const getQuickBooksConnection = async (organizationId: number) => {
    const [connection] = await db.select()
      .from(quickbooksConnections)
      .where(and(
        eq(quickbooksConnections.organizationId, organizationId),
        eq(quickbooksConnections.isActive, true)
      ))
      .limit(1);

    if (!connection) {
      throw new Error('No active QuickBooks connection found');
    }

    return connection;
  };

  // Helper to make QuickBooks API requests using OAuth2
  const makeQuickBooksRequest = async (connection: any, endpoint: string) => {
    const baseUrl = connection.baseUrl || 'https://sandbox-quickbooks.api.intuit.com';
    const url = `${baseUrl}/v3/company/${connection.realmId}/${endpoint}`;
    
    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${connection.accessToken}`,
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`QuickBooks API error: ${response.status} - ${errorText}`);
    }

    return response.json();
  };

  // Fetch QuickBooks Company Info
  app.get("/api/quickbooks/data/company-info", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const connection = await getQuickBooksConnection(organizationId);
      const data = await makeQuickBooksRequest(connection, `companyinfo/${connection.realmId}`);
      res.json(data.CompanyInfo);
    } catch (error: any) {
      console.error("Error:", error);
      res.status(500).json({ error: error.message || "Failed to fetch company info" });
    }
  });

  // Fetch QuickBooks Invoices
  app.get("/api/quickbooks/data/invoices", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const connection = await getQuickBooksConnection(organizationId);
      const data = await makeQuickBooksRequest(connection, `query?query=${encodeURIComponent('SELECT * FROM Invoice MAXRESULTS 100')}`);
      res.json(data.QueryResponse?.Invoice || []);
    } catch (error: any) {
      console.error("Error:", error);
      res.status(500).json({ error: error.message || "Failed to fetch invoices" });
    }
  });

  // Fetch QuickBooks Profit & Loss Report
  app.get("/api/quickbooks/data/profit-loss", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const connection = await getQuickBooksConnection(organizationId);
      const { startDate, endDate } = req.query;
      const start = startDate as string || '2024-01-01';
      const end = endDate as string || '2024-12-31';
      const data = await makeQuickBooksRequest(connection, `reports/ProfitAndLoss?start_date=${start}&end_date=${end}&accounting_method=Accrual`);
      res.json(data);
    } catch (error: any) {
      console.error("Error:", error);
      res.status(500).json({ error: error.message || "Failed to fetch P&L report" });
    }
  });

  // Fetch QuickBooks Expenses/Purchases
  app.get("/api/quickbooks/data/expenses", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const connection = await getQuickBooksConnection(organizationId);
      const data = await makeQuickBooksRequest(connection, `query?query=${encodeURIComponent('SELECT * FROM Purchase MAXRESULTS 100')}`);
      res.json(data.QueryResponse?.Purchase || []);
    } catch (error: any) {
      console.error("Error:", error);
      res.status(500).json({ error: error.message || "Failed to fetch expenses" });
    }
  });

  // Fetch QuickBooks Accounts
  app.get("/api/quickbooks/data/accounts", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const connection = await getQuickBooksConnection(organizationId);
      const data = await makeQuickBooksRequest(connection, `query?query=${encodeURIComponent('SELECT * FROM Account MAXRESULTS 100')}`);
      res.json(data.QueryResponse?.Account || []);
    } catch (error: any) {
      console.error("Error:", error);
      res.status(500).json({ error: error.message || "Failed to fetch accounts" });
    }
  });

  // Fetch QuickBooks Customers
  app.get("/api/quickbooks/data/customers", authMiddleware, requireNonPatientRole(), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const connection = await getQuickBooksConnection(organizationId);
      const data = await makeQuickBooksRequest(connection, `query?query=${encodeURIComponent('SELECT * FROM Customer MAXRESULTS 100')}`);
      res.json(data.QueryResponse?.Customer || []);
    } catch (error: any) {
      console.error("Error:", error);
      res.status(500).json({ error: error.message || "Failed to fetch customers" });
    }
  });


  // Symptom Checker Endpoints
  app.post('/api/symptom-checker/analyze', authMiddleware, multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const { symptoms, symptomDescription, duration, severity, patientId } = req.body;
      
      if (!symptoms || symptoms.length === 0 || !symptomDescription) {
        return res.status(400).json({ error: "Symptoms and description are required" });
      }

      const organizationId = req.tenant!.id;
      const userId = req.user!.id;

      // Look up patient record for this user (if they have one)
      let finalPatientId = patientId || null;
      if (!finalPatientId) {
        const [patientRecord] = await db.select()
          .from(patients)
          .where(and(
            eq(patients.userId, userId),
            eq(patients.organizationId, organizationId)
          ))
          .limit(1);
        
        if (patientRecord) {
          finalPatientId = patientRecord.id;
        }
      }

      // Use AI service to analyze symptoms and provide diagnosis
      const aiAnalysis = await aiService.analyzeSymptoms({
        symptoms,
        symptomDescription,
        duration,
        severity
      });

      // Save symptom check to database
      const [symptomCheck] = await db.insert(symptomChecks).values({
        organizationId,
        patientId: finalPatientId,
        userId,
        symptoms,
        symptomDescription,
        duration: duration || null,
        severity: severity || null,
        aiAnalysis,
        status: 'completed'
      }).returning();

      res.json({
        success: true,
        symptomCheck,
        analysis: aiAnalysis
      });
    } catch (error) {
      console.error("Error analyzing symptoms:", error);
      res.status(500).json({ error: "Failed to analyze symptoms" });
    }
  });

  app.get('/api/symptom-checker/history', authMiddleware, multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.tenant!.id;
      const userId = req.user!.id;
      const userRole = req.user!.role;

      // Patients see only their own history, others see all
      let history;
      if (userRole === 'patient') {
        history = await db.select({
          id: symptomChecks.id,
          organizationId: symptomChecks.organizationId,
          patientId: symptomChecks.patientId,
          userId: symptomChecks.userId,
          symptoms: symptomChecks.symptoms,
          symptomDescription: symptomChecks.symptomDescription,
          duration: symptomChecks.duration,
          severity: symptomChecks.severity,
          aiAnalysis: symptomChecks.aiAnalysis,
          status: symptomChecks.status,
          createdAt: symptomChecks.createdAt,
          updatedAt: symptomChecks.updatedAt,
          patient: {
            id: patients.id,
            patientId: patients.patientId,
            firstName: patients.firstName,
            lastName: patients.lastName,
            dateOfBirth: patients.dateOfBirth,
            phone: patients.phone,
            email: patients.email
          }
        })
          .from(symptomChecks)
          .leftJoin(patients, eq(symptomChecks.patientId, patients.id))
          .where(and(
            eq(symptomChecks.organizationId, organizationId),
            eq(symptomChecks.patientId, userId)
          ))
          .orderBy(desc(symptomChecks.createdAt));
      } else {
        history = await db.select({
          id: symptomChecks.id,
          organizationId: symptomChecks.organizationId,
          patientId: symptomChecks.patientId,
          userId: symptomChecks.userId,
          symptoms: symptomChecks.symptoms,
          symptomDescription: symptomChecks.symptomDescription,
          duration: symptomChecks.duration,
          severity: symptomChecks.severity,
          aiAnalysis: symptomChecks.aiAnalysis,
          status: symptomChecks.status,
          createdAt: symptomChecks.createdAt,
          updatedAt: symptomChecks.updatedAt,
          patient: {
            id: patients.id,
            patientId: patients.patientId,
            firstName: patients.firstName,
            lastName: patients.lastName,
            dateOfBirth: patients.dateOfBirth,
            phone: patients.phone,
            email: patients.email
          }
        })
          .from(symptomChecks)
          .leftJoin(patients, eq(symptomChecks.patientId, patients.id))
          .where(eq(symptomChecks.organizationId, organizationId))
          .orderBy(desc(symptomChecks.createdAt));
      }

      res.json(history);
    } catch (error) {
      console.error("Error fetching symptom check history:", error);
      res.status(500).json({ error: "Failed to fetch history" });
    }
  });

  // ========================================
  // Pricing Management API Routes
  // ========================================

  // Doctors Fee Routes
  app.get("/api/pricing/doctors-fees", authMiddleware, requireRole(['admin', 'doctor', 'nurse', 'patient']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const fees = await storage.getDoctorsFees(organizationId);
      res.json(fees);
    } catch (error) {
      handleRouteError(error, "fetch doctors fees", res);
    }
  });

  app.get("/api/pricing/doctors-fees/:id", authMiddleware, requireRole('admin'), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const fee = await storage.getDoctorsFee(parseInt(req.params.id), organizationId);
      if (!fee) {
        return res.status(404).json({ error: "Doctors fee not found" });
      }
      res.json(fee);
    } catch (error) {
      handleRouteError(error, "fetch doctors fee", res);
    }
  });

  app.post("/api/pricing/doctors-fees", authMiddleware, requireRole('admin'), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const payload = enforceCreatedBy(req, {
        ...req.body,
        organizationId
      }, 'createdBy');
      
      const fee = await storage.createDoctorsFee(payload);
      res.status(201).json(fee);
    } catch (error) {
      handleRouteError(error, "create doctors fee", res);
    }
  });

  app.patch("/api/pricing/doctors-fees/:id", authMiddleware, requireRole('admin'), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const updated = await storage.updateDoctorsFee(parseInt(req.params.id), organizationId, req.body);
      if (!updated) {
        return res.status(404).json({ error: "Doctors fee not found" });
      }
      res.json(updated);
    } catch (error) {
      handleRouteError(error, "update doctors fee", res);
    }
  });

  app.delete("/api/pricing/doctors-fees/:id", authMiddleware, requireRole('admin'), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const success = await storage.deleteDoctorsFee(parseInt(req.params.id), organizationId);
      if (!success) {
        return res.status(404).json({ error: "Doctors fee not found" });
      }
      res.json({ message: "Doctors fee deleted successfully" });
    } catch (error) {
      handleRouteError(error, "delete doctors fee", res);
    }
  });

  // Lab Test Pricing Routes
  app.get("/api/pricing/lab-tests", authMiddleware, requireRole(['admin', 'doctor', 'nurse']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const pricing = await storage.getLabTestPricing(organizationId);
      res.json(pricing);
    } catch (error) {
      handleRouteError(error, "fetch lab test pricing", res);
    }
  });

  app.get("/api/pricing/lab-tests/:id", authMiddleware, requireRole(['admin', 'doctor', 'nurse']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const pricing = await storage.getLabTestPricingById(parseInt(req.params.id), organizationId);
      if (!pricing) {
        return res.status(404).json({ error: "Lab test pricing not found" });
      }
      res.json(pricing);
    } catch (error) {
      handleRouteError(error, "fetch lab test pricing", res);
    }
  });

  app.post("/api/pricing/lab-tests", authMiddleware, requireRole('admin'), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const payload = enforceCreatedBy(req, {
        ...req.body,
        organizationId
      }, 'createdBy');
      
      const pricing = await storage.createLabTestPricing(payload);
      res.status(201).json(pricing);
    } catch (error) {
      handleRouteError(error, "create lab test pricing", res);
    }
  });

  app.patch("/api/pricing/lab-tests/:id", authMiddleware, requireRole('admin'), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const updated = await storage.updateLabTestPricing(parseInt(req.params.id), organizationId, req.body);
      if (!updated) {
        return res.status(404).json({ error: "Lab test pricing not found" });
      }
      res.json(updated);
    } catch (error) {
      handleRouteError(error, "update lab test pricing", res);
    }
  });

  app.delete("/api/pricing/lab-tests/:id", authMiddleware, requireRole('admin'), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const success = await storage.deleteLabTestPricing(parseInt(req.params.id), organizationId);
      if (!success) {
        return res.status(404).json({ error: "Lab test pricing not found" });
      }
      res.json({ message: "Lab test pricing deleted successfully" });
    } catch (error) {
      handleRouteError(error, "delete lab test pricing", res);
    }
  });

  // Imaging Pricing Routes
  app.get("/api/pricing/imaging", authMiddleware, requireRole(['doctor', 'nurse', 'patient', 'admin']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const pricing = await storage.getImagingPricing(organizationId);
      res.json(pricing);
    } catch (error) {
      handleRouteError(error, "fetch imaging pricing", res);
    }
  });

  app.get("/api/pricing/imaging/:id", authMiddleware, requireRole(['doctor', 'nurse', 'patient', 'admin']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const pricing = await storage.getImagingPricingById(parseInt(req.params.id), organizationId);
      if (!pricing) {
        return res.status(404).json({ error: "Imaging pricing not found" });
      }
      res.json(pricing);
    } catch (error) {
      handleRouteError(error, "fetch imaging pricing", res);
    }
  });

  app.post("/api/pricing/imaging", authMiddleware, requireRole(['admin']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const payload = enforceCreatedBy(req, {
        ...req.body,
        organizationId
      }, 'createdBy');
      
      const pricing = await storage.createImagingPricing(payload);
      res.status(201).json(pricing);
    } catch (error) {
      handleRouteError(error, "create imaging pricing", res);
    }
  });

  app.patch("/api/pricing/imaging/:id", authMiddleware, requireRole(['admin']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const updated = await storage.updateImagingPricing(parseInt(req.params.id), organizationId, req.body);
      if (!updated) {
        return res.status(404).json({ error: "Imaging pricing not found" });
      }
      res.json(updated);
    } catch (error) {
      handleRouteError(error, "update imaging pricing", res);
    }
  });

  app.delete("/api/pricing/imaging/:id", authMiddleware, requireRole(['admin']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const success = await storage.deleteImagingPricing(parseInt(req.params.id), organizationId);
      if (!success) {
        return res.status(404).json({ error: "Imaging pricing not found" });
      }
      res.json({ message: "Imaging pricing deleted successfully" });
    } catch (error) {
      handleRouteError(error, "delete imaging pricing", res);
    }
  });

  // Treatments Pricing Routes
  app.get("/api/pricing/treatments", authMiddleware, requireRole(['admin', 'doctor', 'nurse', 'patient']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const entries = await storage.getTreatments(organizationId);
      res.json(entries);
    } catch (error) {
      handleRouteError(error, "fetch treatments pricing", res);
    }
  });

  app.post("/api/pricing/treatments", authMiddleware, requireRole(['admin', 'doctor', 'nurse']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      
      // BUILD A CLEAN OBJECT: Drizzle-Zod can be very picky about extra fields or types
      const cleanPayload: any = {
        organizationId,
        createdBy: req.user!.id,
        name: String(req.body.name || "").trim(),
        basePrice: String(req.body.basePrice || "0"),
        colorCode: String(req.body.colorCode || "#2563eb"),
        currency: String(req.body.currency || "GBP"),
        isActive: req.body.isActive ?? true,
        version: Number(req.body.version || 1),
        notes: req.body.notes ? String(req.body.notes) : null,
        metadata: req.body.metadata || {}
      };

      // Only add doctor fields if they are provided
      if (req.body.doctorId) cleanPayload.doctorId = Number(req.body.doctorId);
      if (req.body.doctorName) cleanPayload.doctorName = String(req.body.doctorName);
      if (req.body.doctorRole) cleanPayload.doctorRole = String(req.body.doctorRole);

      console.log("Saving treatment with clean payload:", JSON.stringify(cleanPayload, null, 2));

      // Use the schema to validate the clean object
      const validatedData = insertTreatmentSchema.parse(cleanPayload);
      const treatment = await storage.createTreatment(validatedData);
      res.status(201).json(treatment);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Treatment validation failed:", JSON.stringify(error.format(), null, 2));
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.format(),
          receivedData: req.body 
        });
      }
      handleRouteError(error, "create treatment pricing", res);
    }
  });

  // Treatments Info (name + color metadata)
  app.post("/api/treatments-info", authMiddleware, requireRole(['admin', 'doctor', 'nurse']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = req.organizationId ?? req.user?.organizationId;
      if (!organizationId) {
        throw new Error("Organization context is missing for treatments info creation");
      }
      const payloadWithOrg = {
        ...req.body,
        organizationId
      };
      const preparedPayload = enforceCreatedBy(req, payloadWithOrg, 'createdBy');
      const validatedPayload = insertTreatmentsInfoSchema.parse(preparedPayload);
      const info = await storage.createTreatmentsInfo(validatedPayload);
      res.status(201).json(info);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Treatments info validation failed:", JSON.stringify(error.format(), null, 2));
        return res.status(400).json({
          error: "Validation failed",
          details: error.format(),
          receivedData: req.body
        });
      }
      handleRouteError(error, "create treatments info", res);
    }
  });

  app.get("/api/treatments-info", authMiddleware, requireRole(['admin', 'doctor', 'nurse']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const infos = await storage.getTreatmentsInfo(organizationId);
      res.json(infos);
    } catch (error) {
      handleRouteError(error, "fetch treatments info", res);
    }
  });

  app.patch("/api/treatments-info/:id", authMiddleware, requireRole(['admin', 'doctor', 'nurse']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const updatePayload: any = {};

      if (req.body.name !== undefined) updatePayload.name = String(req.body.name).trim();
      if (req.body.colorCode !== undefined) updatePayload.colorCode = String(req.body.colorCode);

      const validatedData = insertTreatmentsInfoSchema.partial().parse(updatePayload);
      const updated = await storage.updateTreatmentsInfo(parseInt(req.params.id), organizationId, validatedData);

      if (!updated) {
        return res.status(404).json({ error: "Treatment metadata not found" });
      }

      res.json(updated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Treatments info update validation failed:", JSON.stringify(error.format(), null, 2));
        return res.status(400).json({
          error: "Validation failed",
          details: error.format(),
          receivedData: req.body
        });
      }
      handleRouteError(error, "update treatments info", res);
    }
  });

  app.delete("/api/treatments-info/:id", authMiddleware, requireRole(['admin', 'doctor', 'nurse']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const success = await storage.deleteTreatmentsInfo(parseInt(req.params.id), organizationId);
      if (!success) {
        return res.status(404).json({ error: "Treatment metadata not found" });
      }
      res.json({ message: "Treatment metadata deleted successfully" });
    } catch (error) {
      handleRouteError(error, "delete treatments info", res);
    }
  });

  app.patch("/api/pricing/treatments/:id", authMiddleware, requireRole(['admin', 'doctor', 'nurse']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      
      // BUILD A CLEAN UPDATE OBJECT
      const updatePayload: any = {};
      if (req.body.name !== undefined) updatePayload.name = String(req.body.name).trim();
      if (req.body.basePrice !== undefined) updatePayload.basePrice = String(req.body.basePrice);
      if (req.body.colorCode !== undefined) updatePayload.colorCode = String(req.body.colorCode);
      if (req.body.currency !== undefined) updatePayload.currency = String(req.body.currency);
      if (req.body.isActive !== undefined) updatePayload.isActive = !!req.body.isActive;
      if (req.body.version !== undefined) updatePayload.version = Number(req.body.version);
      if (req.body.notes !== undefined) updatePayload.notes = req.body.notes ? String(req.body.notes) : null;
      if (req.body.metadata !== undefined) updatePayload.metadata = req.body.metadata;
      
      if (req.body.doctorId !== undefined) updatePayload.doctorId = req.body.doctorId ? Number(req.body.doctorId) : null;
      if (req.body.doctorName !== undefined) updatePayload.doctorName = req.body.doctorName ? String(req.body.doctorName) : null;
      if (req.body.doctorRole !== undefined) updatePayload.doctorRole = req.body.doctorRole ? String(req.body.doctorRole) : null;

      console.log(`Updating treatment ${req.params.id} with clean payload:`, JSON.stringify(updatePayload, null, 2));

      // Validate update payload with partial schema
      const validatedData = insertTreatmentSchema.partial().parse(updatePayload);
      
      const updated = await storage.updateTreatment(parseInt(req.params.id), organizationId, validatedData);
      
      if (!updated) {
        return res.status(404).json({ error: "Treatment pricing not found" });
      }
      res.json(updated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Treatment update validation failed:", JSON.stringify(error.format(), null, 2));
        return res.status(400).json({ 
          error: "Validation failed", 
          details: error.format(),
          receivedData: req.body 
        });
      }
      handleRouteError(error, "update treatment pricing", res);
    }
  });

  app.delete("/api/pricing/treatments/:id", authMiddleware, requireRole(['admin', 'doctor', 'nurse']), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const success = await storage.deleteTreatment(parseInt(req.params.id), organizationId);
      if (!success) {
        return res.status(404).json({ error: "Treatment pricing not found" });
      }
      res.json({ message: "Treatment pricing deleted successfully" });
    } catch (error) {
      handleRouteError(error, "delete treatment pricing", res);
    }
  });

  // ===== Clinic Headers & Footers Routes =====
  
  // Create or update clinic header
  app.post("/api/clinic-headers", authMiddleware, requireModulePermission('forms', 'edit'), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const validated = insertClinicHeaderSchema.parse({
        ...req.body,
        organizationId
      });
      
      // Check if header already exists for this organization
      const existingHeader = await storage.getActiveClinicHeader(organizationId);
      
      let header;
      if (existingHeader) {
        // Update existing header
        header = await storage.updateClinicHeader(existingHeader.id, organizationId, validated);
        res.json(header);
      } else {
        // Create new header
        header = await storage.createClinicHeader(validated);
        res.status(201).json(header);
      }
    } catch (error) {
      handleRouteError(error, "create or update clinic header", res);
    }
  });

  // Get active clinic header for organization
  app.get("/api/clinic-headers", authMiddleware, multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const header = await storage.getActiveClinicHeader(organizationId);
      res.json(header || null);
    } catch (error) {
      handleRouteError(error, "get clinic header", res);
    }
  });

  // Create or update clinic footer
  app.post("/api/clinic-footers", authMiddleware, requireModulePermission('forms', 'edit'), multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const validated = insertClinicFooterSchema.parse({
        ...req.body,
        organizationId
      });
      
      // Check if footer already exists for this organization
      const existingFooter = await storage.getActiveClinicFooter(organizationId);
      
      let footer;
      if (existingFooter) {
        // Update existing footer
        footer = await storage.updateClinicFooter(existingFooter.id, organizationId, validated);
        res.json(footer);
      } else {
        // Create new footer
        footer = await storage.createClinicFooter(validated);
        res.status(201).json(footer);
      }
    } catch (error) {
      handleRouteError(error, "create or update clinic footer", res);
    }
  });

  // Get active clinic footer for organization
  app.get("/api/clinic-footers", authMiddleware, multiTenantEnforcer(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const footer = await storage.getActiveClinicFooter(organizationId);
      res.json(footer || null);
    } catch (error) {
      handleRouteError(error, "get clinic footer", res);
    }
  });

  // ========================================
  // PHARMACY ROLE MODULE API ROUTES
  // ========================================

  // Pharmacist role check middleware
  const requirePharmacistRole = (roles: string[] = ['pharmacist', 'admin', 'store_manager']) => {
    return (req: TenantRequest, res: Response, next: NextFunction) => {
      if (!req.user) {
        return res.status(401).json({ error: "Authentication required" });
      }
      if (!roles.includes(req.user.role || '')) {
        return res.status(403).json({ error: "Pharmacy access denied. Required role: pharmacist, admin, or store_manager" });
      }
      next();
    };
  };

  // Pharmacy Dashboard Summary
  app.get("/api/pharmacy/dashboard", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const summary = await pharmacyService.getDashboardSummary(organizationId);
      res.json(summary);
    } catch (error) {
      handleRouteError(error, "get pharmacy dashboard", res);
    }
  });

  // Shift Management
  app.post("/api/pharmacy/shifts/start", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const userId = req.user!.id;
      
      const shiftData = {
        organizationId,
        pharmacistId: userId,
        shiftDate: new Date(),
        shiftStartTime: new Date(),
        openingCash: req.body.openingCash || "0.00",
        notes: req.body.notes,
      };

      const shift = await pharmacyService.startShift(shiftData);
      
      // Log activity
      await pharmacyService.logActivity({
        organizationId,
        userId,
        action: "shift_started",
        entityType: "shift",
        entityId: shift.id,
        ipAddress: req.ip,
      });

      res.status(201).json(shift);
    } catch (error) {
      handleRouteError(error, "start pharmacy shift", res);
    }
  });

  app.get("/api/pharmacy/shifts/current", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const userId = req.user!.id;
      const shift = await pharmacyService.getOpenShift(organizationId, userId);
      res.json(shift || null);
    } catch (error) {
      handleRouteError(error, "get current shift", res);
    }
  });

  app.post("/api/pharmacy/shifts/:id/close", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const userId = req.user!.id;
      const shiftId = parseInt(req.params.id);

      const shift = await pharmacyService.closeShift(shiftId, {
        closingCash: req.body.closingCash,
        discrepancyNotes: req.body.discrepancyNotes,
        notes: req.body.notes,
      });

      // Log activity
      await pharmacyService.logActivity({
        organizationId,
        userId,
        action: "shift_closed",
        entityType: "shift",
        entityId: shift.id,
        details: {
          saleAmount: parseFloat(shift.totalSalesAmount || "0"),
          returnAmount: parseFloat(shift.totalReturnsAmount || "0"),
        },
        ipAddress: req.ip,
      });

      res.json(shift);
    } catch (error) {
      handleRouteError(error, "close pharmacy shift", res);
    }
  });

  app.get("/api/pharmacy/shifts", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const filters: any = {};
      
      if (req.query.pharmacistId) {
        filters.pharmacistId = parseInt(req.query.pharmacistId as string);
      }
      if (req.query.startDate) {
        filters.startDate = new Date(req.query.startDate as string);
      }
      if (req.query.endDate) {
        filters.endDate = new Date(req.query.endDate as string);
      }
      if (req.query.status) {
        filters.status = req.query.status as string;
      }

      const shifts = await pharmacyService.getShiftHistory(organizationId, filters);
      res.json(shifts);
    } catch (error) {
      handleRouteError(error, "get shift history", res);
    }
  });

  app.post("/api/pharmacy/shifts/:id/approve", authMiddleware, multiTenantEnforcer(), requireRole(['admin', 'store_manager']), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const userId = req.user!.id;
      const shiftId = parseInt(req.params.id);

      const shift = await pharmacyService.approveShift(shiftId, userId, req.body.approvalNotes);

      // Log activity
      await pharmacyService.logActivity({
        organizationId,
        userId,
        action: "shift_approved",
        entityType: "shift",
        entityId: shift.id,
        ipAddress: req.ip,
      });

      res.json(shift);
    } catch (error) {
      handleRouteError(error, "approve shift", res);
    }
  });

  // Activity Logs
  app.get("/api/pharmacy/activity-logs", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const filters: any = {};

      if (req.query.userId) {
        filters.userId = parseInt(req.query.userId as string);
      }
      if (req.query.action) {
        filters.action = req.query.action as string;
      }
      if (req.query.entityType) {
        filters.entityType = req.query.entityType as string;
      }
      if (req.query.startDate) {
        filters.startDate = new Date(req.query.startDate as string);
      }
      if (req.query.endDate) {
        filters.endDate = new Date(req.query.endDate as string);
      }
      if (req.query.limit) {
        filters.limit = parseInt(req.query.limit as string);
      }

      const logs = await pharmacyService.getActivityLogs(organizationId, filters);
      res.json(logs);
    } catch (error) {
      handleRouteError(error, "get activity logs", res);
    }
  });

  // Reports
  app.get("/api/pharmacy/reports/daily-sales", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const date = req.query.date ? new Date(req.query.date as string) : new Date();
      const report = await pharmacyService.getDailySalesReport(organizationId, date);
      res.json(report);
    } catch (error) {
      handleRouteError(error, "get daily sales report", res);
    }
  });

  app.get("/api/pharmacy/reports/returns", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const startDate = req.query.startDate ? new Date(req.query.startDate as string) : new Date(new Date().setDate(new Date().getDate() - 30));
      const endDate = req.query.endDate ? new Date(req.query.endDate as string) : new Date();
      const report = await pharmacyService.getReturnSummaryReport(organizationId, startDate, endDate);
      res.json(report);
    } catch (error) {
      handleRouteError(error, "get returns report", res);
    }
  });

  app.get("/api/pharmacy/reports/item-wise-sales", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const startDate = req.query.startDate ? new Date(req.query.startDate as string) : new Date(new Date().setDate(new Date().getDate() - 30));
      const endDate = req.query.endDate ? new Date(req.query.endDate as string) : new Date();
      const report = await pharmacyService.getItemWiseSalesReport(organizationId, startDate, endDate);
      res.json(report);
    } catch (error) {
      handleRouteError(error, "get item-wise sales report", res);
    }
  });

  app.get("/api/pharmacy/reports/pharmacist-activity", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(['admin', 'store_manager']), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const startDate = req.query.startDate ? new Date(req.query.startDate as string) : new Date(new Date().setDate(new Date().getDate() - 30));
      const endDate = req.query.endDate ? new Date(req.query.endDate as string) : new Date();
      const report = await pharmacyService.getPharmacistActivityReport(organizationId, startDate, endDate);
      res.json(report);
    } catch (error) {
      handleRouteError(error, "get pharmacist activity report", res);
    }
  });

  // Invoices
  app.get("/api/pharmacy/invoices/sales", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const filters: any = {};

      if (req.query.startDate) {
        filters.startDate = new Date(req.query.startDate as string);
      }
      if (req.query.endDate) {
        filters.endDate = new Date(req.query.endDate as string);
      }
      if (req.query.patientId) {
        filters.patientId = parseInt(req.query.patientId as string);
      }
      if (req.query.invoiceNumber) {
        filters.invoiceNumber = req.query.invoiceNumber as string;
      }
      if (req.query.status) {
        filters.status = req.query.status as string;
      }

      const invoices = await pharmacyService.getSalesInvoices(organizationId, filters);
      res.json(invoices);
    } catch (error) {
      handleRouteError(error, "get sales invoices", res);
    }
  });

  app.get("/api/pharmacy/invoices/returns", authMiddleware, multiTenantEnforcer(), requirePharmacistRole(), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const filters: any = {};

      if (req.query.startDate) {
        filters.startDate = new Date(req.query.startDate as string);
      }
      if (req.query.endDate) {
        filters.endDate = new Date(req.query.endDate as string);
      }
      if (req.query.returnType) {
        filters.returnType = req.query.returnType as string;
      }
      if (req.query.status) {
        filters.status = req.query.status as string;
      }

      const invoices = await pharmacyService.getReturnInvoices(organizationId, filters);
      res.json(invoices);
    } catch (error) {
      handleRouteError(error, "get return invoices", res);
    }
  });

  // Permissions
  app.get("/api/pharmacy/permissions", authMiddleware, multiTenantEnforcer(), requireRole(['admin']), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const roleName = req.query.role as string || 'pharmacist';
      const permissions = await pharmacyService.getPermissions(organizationId, roleName);
      res.json(permissions);
    } catch (error) {
      handleRouteError(error, "get pharmacy permissions", res);
    }
  });

  app.post("/api/pharmacy/permissions", authMiddleware, multiTenantEnforcer(), requireRole(['admin']), async (req: TenantRequest, res) => {
    try {
      const organizationId = requireOrgId(req);
      const permission = await pharmacyService.setPermission({
        organizationId,
        roleName: req.body.roleName,
        permissionKey: req.body.permissionKey,
        isEnabled: req.body.isEnabled,
      });
      res.json(permission);
    } catch (error) {
      handleRouteError(error, "set pharmacy permission", res);
    }
  });
  
  // Add WebSocket support for real-time messaging
  const wss = new WebSocketServer({ server: httpServer, path: '/ws' });
  
  // Store connected clients by user ID for message broadcasting
  const connectedClients = new Map();
  
  wss.on('connection', (ws: any, req: any) => {
    console.log('üîó WebSocket client connected');
    console.log('üîç Current connected clients count:', connectedClients.size);
    
    // Send immediate ping to keep connection alive
    ws.ping();
    
    // Setup ping/pong to maintain connection
    const pingInterval = setInterval(() => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.ping();
      } else {
        clearInterval(pingInterval);
      }
    }, 30000); // Ping every 30 seconds
    
    ws.on('message', (message: Buffer) => {
      try {
        const data = JSON.parse(message.toString());
        console.log('üì• WebSocket message received from client:', data);
        
        // Handle client authentication and registration
        if (data.type === 'auth' && data.userId) {
          connectedClients.set(data.userId, ws);
          ws.userId = data.userId;
          console.log(`üë§ User ${data.userId} authenticated via WebSocket`);
          console.log('üîç Total authenticated clients:', connectedClients.size);
          console.log('üîç Authenticated client IDs:', Array.from(connectedClients.keys()));
        }
      } catch (error) {
        console.error('WebSocket message parsing error:', error);
      }
    });
    
    ws.on('close', () => {
      clearInterval(pingInterval);
      if (ws.userId) {
        connectedClients.delete(ws.userId);
        console.log(`üë§ User ${ws.userId} disconnected from WebSocket`);
        console.log('üîç Remaining connected clients:', connectedClients.size);
      } else {
        console.log('üîó WebSocket client disconnected (unauthenticated)');
      }
    });
  });
  
  // Export function to broadcast messages to specific users
  app.set('broadcastMessage', (targetUserId: number, messageData: any) => {
    const targetClient = connectedClients.get(targetUserId);
    if (targetClient && targetClient.readyState === WebSocket.OPEN) {
      targetClient.send(JSON.stringify({
        type: 'new_message',
        message: messageData.message || messageData,
        conversationId: messageData.conversationId,
        data: messageData
      }));
      console.log(`üì® Message broadcasted to user ${targetUserId}`);
      return true;
    }
    return false;
  });
  
  return httpServer;
}

